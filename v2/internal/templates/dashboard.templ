package templates

import (
	"encoding/json"
	"fmt"
	"strconv"
)

// Host represents a host in the dashboard
type Host struct {
	ID                   string
	Hostname             string
	HostType             string
	Status               string
	Online               bool
	AgentVersion         string
	ExpectedAgentVersion string             // Dashboard version for comparison
	OSVersion            string
	Generation           string
	LastSeen             string
	PendingCommand       string
	ThemeColor           string
	Metrics              *Metrics
	Location             string             // home, work, cloud
	DeviceType           string             // server, desktop, laptop, gaming
	TestProgress         *TestProgress      // current test progress, nil if not running
	UpdateStatus         *UpdateStatus      // three-compartment status (Git/Lock/System)
	RepoURL              string             // git repo URL (isolated mode)
	RepoDir              string             // local repo path
	AgentOutdated        bool               // true if agent version doesn't match dashboard version
	OperationProgress    *OperationProgress // P2700: detailed progress for STATUS column
}

// UpdateStatus contains the three-compartment update status.
type UpdateStatus struct {
	Git     StatusCheck `json:"git"`
	Lock    StatusCheck `json:"lock"`
	System  StatusCheck `json:"system"`
	RepoURL string      `json:"repo_url"` // git repo URL (for Git tooltip)
	RepoDir string      `json:"repo_dir"` // local repo path (for Git tooltip)
}

// StatusCheck represents a single status check result.
type StatusCheck struct {
	Status    string `json:"status"`     // "ok", "outdated", "error", "unknown"
	Message   string `json:"message"`    // Human-readable detail
	CheckedAt string `json:"checked_at"` // ISO timestamp
}

// Metrics contains system metrics from StaSysMo
type Metrics struct {
	CPU  float64 `json:"cpu"`  // percentage 0-100
	RAM  float64 `json:"ram"`  // percentage 0-100
	Swap float64 `json:"swap"` // percentage 0-100
	Load float64 `json:"load"` // 1-minute load average
}

// TestProgress contains current test execution state
type TestProgress struct {
	Current int    `json:"current"` // current test number (1-based)
	Total   int    `json:"total"`   // total tests
	Passed  int    `json:"passed"`  // passed so far
	Running bool   `json:"running"` // true if still running
	Result  string `json:"result"`  // summary when done (e.g., "8/10")
}

// OperationProgress tracks detailed progress for STATUS column (P2700).
type OperationProgress struct {
	Pull   *PhaseProgress `json:"pull,omitempty"`
	Lock   *PhaseProgress `json:"lock,omitempty"`
	System *PhaseProgress `json:"system,omitempty"`
	Tests  *TestsProgress `json:"tests,omitempty"`
}

// PhaseProgress tracks progress within a single phase.
type PhaseProgress struct {
	Current int    `json:"current"` // current step (0-based)
	Total   int    `json:"total"`   // total steps
	Status  string `json:"status"`  // "pending", "in_progress", "complete", "error"
}

// TestsProgress tracks individual test results.
type TestsProgress struct {
	Current int      `json:"current"` // current test number (0-based)
	Total   int      `json:"total"`   // total tests (capped at 8 for display)
	Results []string `json:"results"` // "pending", "pass", "fail" per test
	Status  string   `json:"status"`  // "pending", "in_progress", "complete"
}

// Stats represents dashboard statistics
type Stats struct {
	Online int
	Total  int
}

// FleetTarget represents the "gold standard" versions all hosts should match
type FleetTarget struct {
	GitCommit   string // Short git hash (e.g., "abc1234")
	GitFull     string // Full git hash for comparison
	Branch      string // e.g., "main"
	TimeAgo     string // e.g., "2h ago"
	Message     string // Commit message for tooltip
	RepoURL     string // For linking to GitHub
	AgentVer    string // Expected agent version (dashboard version)
	HasData     bool   // Whether we have version tracking data
}

// PendingPR represents a pending flake.lock update PR (P5300).
type PendingPR struct {
	Number    int    `json:"number"`
	Title     string `json:"title"`
	URL       string `json:"url"`
	CreatedAt string `json:"created_at"`
	Mergeable bool   `json:"mergeable"`
}

// DashboardData contains all data needed to render the dashboard
type DashboardData struct {
	Hosts             []Host
	Stats             Stats
	CSRFToken         string
	Version           string
	DashboardVersion  string    // For agent version comparison
	HeartbeatInterval int       // in seconds, for last-seen display
	FleetTarget       FleetTarget
	PendingPR         *PendingPR // Pending flake update PR (P5300)
}

// Dashboard renders the main dashboard page
templ Dashboard(data DashboardData) {
	@Base("NixFleet Dashboard", data.CSRFToken) {
		<!-- Config for JavaScript - P7000: added pending PR data -->
		<div
			id="config"
			data-heartbeat-interval={ strconv.Itoa(data.HeartbeatInterval) }
			data-pending-pr={ pendingPRJSON(data.PendingPR) }
			style="display:none;"
		></div>
		<header>
			<div class="header-brand">
				<img src="/static/nixfleet_favicon.png" alt="" class="brand-logo"/>
				<span class="brand-title">NixFleet</span>
			</div>
			<div class="header-center">
				@FleetTargetLine(data.FleetTarget)
			</div>
			<div class="header-actions">
				<div class="dropdown bulk-actions-dropdown">
					<button class="btn btn-header" onclick="toggleBulkMenu(event)" onkeydown="if(event.key==='ArrowDown'){event.preventDefault();toggleBulkMenu(event);}">
						<svg class="icon"><use href="#icon-more-vertical"></use></svg>
						More
					</button>
				<div class="dropdown-menu" id="bulk-actions-menu" onkeydown="handleBulkMenuKeydown(event)">
					<!-- P7000: Merge & Deploy moved here from global banner -->
					if data.PendingPR != nil && data.PendingPR.Mergeable {
						<button class="dropdown-item" onclick={ templ.ComponentScript{Call: fmt.Sprintf("mergeAndDeploy(%d); closeBulkMenu()", data.PendingPR.Number)} }>
							<svg class="icon"><use href="#icon-check"></use></svg>
							Merge & Deploy PR #{ strconv.Itoa(data.PendingPR.Number) }
						</button>
						<div class="dropdown-divider"></div>
					}
					<!-- P2500: Reordered - Do All first, removed duplicate "Update All" -->
					<button class="dropdown-item" onclick="bulkDoAll(); closeBulkMenu()">
						<svg class="icon"><use href="#icon-play"></use></svg>
						Do All
					</button>
					<div class="dropdown-divider"></div>
					<button class="dropdown-item" onclick="bulkCommand('pull'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-download"></use></svg>
						Pull All
					</button>
					<button class="dropdown-item" onclick="bulkCommand('switch'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-refresh"></use></svg>
						Switch All
					</button>
					<button class="dropdown-item" onclick="bulkCommand('test'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-flask"></use></svg>
						Test All
					</button>
					<div class="dropdown-divider"></div>
					<button class="dropdown-item" onclick="bulkCommand('restart'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-refresh-cw"></use></svg>
						Restart All Agents
					</button>
				</div>
				</div>
				<form method="POST" action="/logout">
					<input type="hidden" name="csrf_token" value={ data.CSRFToken }/>
					<button type="submit" class="btn btn-danger btn-header">Logout</button>
				</form>
			</div>
		</header>

		<!-- P7000: Flake Update Banner removed - Merge & Deploy moved to Bulk Actions -->

		<!-- Mobile: Card View -->
		<div class="host-grid" id="host-cards">
			for _, host := range data.Hosts {
				@HostCard(host, data.CSRFToken)
			}
		</div>

		<!-- Desktop: Table View -->
		<!-- P2700: Reduced from 9 to 7 columns (Loc+Dev+Type→TYPE, Tests→STATUS) -->
		<table class="host-table" id="host-table" x-data>
			<thead>
				<tr>
					<th class="col-hosts" title="Online / Total Hosts">
						<span class={ templ.KV("stat-online-positive", data.Stats.Online > 0) } id="stat-online">{ fmt.Sprint(data.Stats.Online) }</span>/{ fmt.Sprint(data.Stats.Total) } Hosts
					</th>
					<th class="col-center col-type" title="Location / Device / OS">Type</th>
					<th>Metrics</th>
					<th title="Update Status (Git/Lock/System)">Update</th>
					<th class="col-status" title="Operation Progress + Test Results">Status</th>
					<th class="col-right">Last Seen</th>
					<!-- P1050: Actions removed, P1060: Menu column -->
					<th class="col-menu"></th>
					<!-- P1030: Selection checkbox column (right side) -->
					<th class="col-select">
						<button
							type="button"
							class="select-toggle"
							@click="handleHeaderCheckboxClick()"
							:title="$store.selection.headerState === 'all' ? 'Deselect all' : ($store.selection.headerState === 'some' ? 'Clear selection' : 'Select all')"
						>
							<svg class="icon" x-show="$store.selection.headerState === 'none'"><use href="#icon-square"></use></svg>
							<svg class="icon" x-show="$store.selection.headerState === 'some'"><use href="#icon-minus-square"></use></svg>
							<svg class="icon" x-show="$store.selection.headerState === 'all'"><use href="#icon-check-square"></use></svg>
						</button>
					</th>
				</tr>
			</thead>
			<tbody>
				for _, host := range data.Hosts {
					@HostRow(host, data.CSRFToken)
				}
			</tbody>
		</table>

		<!-- Context Bar - unified hover preview + selection actions -->
		@ContextBar()

		<!-- Log Viewer (global, shown when command is running) -->
		<div class="log-panel hidden" id="log-panel" x-data="logViewer()">
			<div class="log-header" @click="toggle()">
				<div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
					<span>
						Command Output
						<span x-show="hostId" x-text="'(' + hostId + ')'"></span>
					</span>
					<!-- Progress indicator -->
					<span x-show="phase" class="progress-badge" x-text="phaseIcon + ' ' + phase + (buildCount ? ' (' + buildCurrent + '/' + buildCount + ')' : '')"></span>
				</div>
				<span class="chevron" :class="{ 'expanded': open }">▼</span>
			</div>
			<div class="log-content" x-show="open" x-ref="logContent">
				<template x-for="line in lines" :key="line.id">
					<div class="log-line" :class="{ 'error': line.isError, 'success': line.isSuccess }" x-text="line.text"></div>
				</template>
			</div>
		</div>

		<!-- P1040: Dependency Dialog -->
		@DependencyDialog()

		<!-- Remove Host Confirmation Modal (P4390) -->
		<div class="modal-overlay" id="removeHostModal">
			<div class="modal">
				<div class="modal-title">Remove Host</div>
				<div class="modal-body">
					Are you sure you want to remove <code id="removeHostName"></code>?
					<br/><br/>
					This will delete the host from the dashboard. The host can re-register when the agent reconnects.
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('removeHostModal')">Cancel</button>
					<button class="modal-btn modal-btn-danger" id="confirmRemoveBtn" onclick="doRemoveHost()">Remove</button>
				</div>
			</div>
		</div>

		<!-- Add Host Modal (P4390) -->
		<div class="modal-overlay" id="addHostModal">
			<div class="modal modal-wide">
				<div class="modal-title">Add Host</div>
				<div class="modal-body">
					<form id="addHostForm">
						<div class="form-group">
							<label>Hostname *</label>
							<input type="text" name="hostname" required pattern="[a-zA-Z][a-zA-Z0-9\-]{0,62}" placeholder="e.g., hsb1"/>
						</div>
						<div class="form-row">
							<div class="form-group">
								<label>OS Type</label>
								<select name="host_type">
									<option value="nixos">NixOS</option>
									<option value="macos">macOS</option>
								</select>
							</div>
							<div class="form-group">
								<label>Location</label>
								<select name="location">
									<option value="home">Home</option>
									<option value="work">Work</option>
									<option value="cloud">Cloud</option>
								</select>
							</div>
						</div>
						<div class="form-row">
							<div class="form-group">
								<label>Device Type</label>
								<select name="device_type">
									<option value="server">Server</option>
									<option value="desktop">Desktop</option>
									<option value="laptop">Laptop</option>
									<option value="gaming">Gaming</option>
								</select>
							</div>
							<div class="form-group">
								<label>Theme Color</label>
								<input type="color" name="theme_color" value="#7aa2f7"/>
							</div>
						</div>
					</form>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('addHostModal')">Cancel</button>
					<button class="modal-btn modal-btn-primary" onclick="doAddHost()">Add Host</button>
				</div>
			</div>
		</div>

		<footer class="site-footer">
			<div class="footer-left">
				<span class="connection-indicator" id="ws-status">
					<span class="status-dot status-offline"></span>
					Connecting...
				</span>
				<span class="footer-sep">•</span>
				<span>NixFleet { data.Version }</span>
				<a href="https://github.com/markus-barta/nixfleet" class="footer-link" target="_blank" rel="noopener">
					<svg class="icon"><use href="#icon-github"></use></svg>
					Source
				</a>
				<a href="https://www.gnu.org/licenses/agpl-3.0.html" class="footer-link" target="_blank" rel="noopener">
					<svg class="icon"><use href="#icon-license"></use></svg>
					AGPL-3.0
				</a>
			</div>
			<div class="footer-right">
				<span class="made-with">
					Made with <svg class="icon heart"><use href="#icon-heart"></use></svg> by
					<a href="https://x.com/markusbarta" target="_blank" rel="noopener">&#64;markusbarta</a>,
					Claude &amp; Cursor
				</span>
			</div>
		</footer>

		<!-- WebSocket and Alpine.js logic - P7000 Unified Host State Management -->
		<script>
			// ═══════════════════════════════════════════════════════════════════════════
			// CONSTANTS
			// ═══════════════════════════════════════════════════════════════════════════
			const HEARTBEAT_INTERVAL = parseInt(document.getElementById('config').dataset.heartbeatInterval) || 5;
			const CSRF_TOKEN = document.body.dataset.csrfToken;

			// ═══════════════════════════════════════════════════════════════════════════
			// SELECTION STORE (P1030) - Single Source of Truth for host selection
			// ═══════════════════════════════════════════════════════════════════════════
			document.addEventListener('alpine:init', () => {
				Alpine.store('selection', {
					selected: [],
					lastSelected: null,

					toggle(id) {
						const idx = this.selected.indexOf(id);
						if (idx === -1) {
							this.selected.push(id);
						} else {
							this.selected.splice(idx, 1);
						}
						this.lastSelected = id;
					},

					select(id) {
						if (!this.selected.includes(id)) {
							this.selected.push(id);
						}
						this.lastSelected = id;
					},

					deselect(id) {
						const idx = this.selected.indexOf(id);
						if (idx !== -1) {
							this.selected.splice(idx, 1);
						}
					},

					isSelected(id) {
						return this.selected.includes(id);
					},

					selectAll() {
						const allIds = this._getAllHostIds();
						this.selected = [...allIds];
						this.lastSelected = allIds[allIds.length - 1] || null;
					},

					selectNone() {
						this.selected = [];
						this.lastSelected = null;
					},

					selectRange(targetId) {
						if (!this.lastSelected) {
							this.toggle(targetId);
							return;
						}
						const allIds = this._getAllHostIds();
						const startIdx = allIds.indexOf(this.lastSelected);
						const endIdx = allIds.indexOf(targetId);
						if (startIdx === -1 || endIdx === -1) {
							this.toggle(targetId);
							return;
						}
						const minIdx = Math.min(startIdx, endIdx);
						const maxIdx = Math.max(startIdx, endIdx);
						for (let i = minIdx; i <= maxIdx; i++) {
							if (!this.selected.includes(allIds[i])) {
								this.selected.push(allIds[i]);
							}
						}
					},

					get count() {
						return this.selected.length;
					},

					get onlineCount() {
						return this.selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						}).length;
					},

					get headerState() {
						const allIds = this._getAllHostIds();
						if (allIds.length === 0) return 'none';
						if (this.selected.length === 0) return 'none';
						if (this.selected.length === allIds.length) return 'all';
						return 'some';
					},

					_getAllHostIds() {
						const ids = [];
						document.querySelectorAll('tr[data-host-id]').forEach(row => {
							ids.push(row.dataset.hostId);
						});
						return ids;
					}
				});
			});

			// ═══════════════════════════════════════════════════════════════════════════
			// GLOBAL STATE (non-host-specific)
			// ═══════════════════════════════════════════════════════════════════════════
			const globalState = {
				pendingPR: null, // { number, title, url, mergeable } or null
				wsConnected: false
			};

			// Hydrate globalState from config
			(function hydrateGlobalState() {
				const prData = document.getElementById('config').dataset.pendingPr;
				if (prData && prData !== 'null') {
					try {
						globalState.pendingPR = JSON.parse(prData);
					} catch (e) {
						console.warn('Failed to parse pendingPR:', e);
					}
				}
			})();

			// ═══════════════════════════════════════════════════════════════════════════
			// HOST STORE (Single Source of Truth) - P7000
			// ═══════════════════════════════════════════════════════════════════════════
			const hostStore = {
				_hosts: new Map(),

				// Initialize store from server-rendered DOM
				hydrate() {
					document.querySelectorAll('tr[data-host-id]').forEach((row) => {
						const id = row.dataset.hostId;
						if (this._hosts.has(id)) return;

						// Cache element references for O(1) access
						const card = document.querySelector(`.host-card[data-host-id="${id}"]`);

						this._hosts.set(id, {
							// Identity
							id: id,
							hostname: row.dataset.hostname || id,
							hostType: row.dataset.hostType || 'nixos',
							themeColor: row.dataset.themeColor || '#7aa2f7',

							// State
							online: !row.classList.contains('host-offline'),
							lastSeen: row.querySelector('[data-cell="last-seen"]')?.dataset.timestamp || null,
							pendingCommand: row.dataset.pendingCommand || null,

							// Data
							metrics: this._parseMetrics(row),
							updateStatus: this._parseUpdateStatus(row),
							generation: row.dataset.generation || null,
							agentVersion: row.dataset.agentVersion || null,
							agentOutdated: row.dataset.agentOutdated === 'true',

							// Cached DOM references
							_elements: { row, card }
						});
					});
					console.log(`hostStore: hydrated ${this._hosts.size} hosts`);
				},

				_parseMetrics(row) {
					const cell = row.querySelector('[data-cell="metrics"]');
					if (!cell) return null;
					const cpu = cell.querySelector('[data-metric="cpu"]');
					const ram = cell.querySelector('[data-metric="ram"]');
					if (!cpu && !ram) return null;
					return {
						cpu: parseFloat(cpu?.dataset.value) || 0,
						ram: parseFloat(ram?.dataset.value) || 0,
						swap: parseFloat(ram?.dataset.swap) || 0,
						load: parseFloat(ram?.dataset.load) || 0
					};
				},

				_parseUpdateStatus(row) {
					const container = row.querySelector('.update-status');
					if (!container) return null;
					try {
						return {
							git: JSON.parse(container.dataset.git || 'null'),
							lock: JSON.parse(container.dataset.lock || 'null'),
							system: JSON.parse(container.dataset.system || 'null'),
							repoUrl: container.dataset.repoUrl || '',
							repoDir: container.dataset.repoDir || ''
						};
					} catch (e) {
						console.warn('Failed to parse updateStatus:', e);
						return null;
					}
				},

				get(id) {
					return this._hosts.get(id);
				},

				all() {
					return Array.from(this._hosts.values());
				},

				// Update host state and trigger render
				update(id, patch) {
					const current = this._hosts.get(id);
					if (!current) {
						console.warn(`hostStore: unknown host ${id}`);
						return;
					}

					// Start with shallow merge
					const next = { ...current, ...patch };

					// Deep merge for known nested objects
					if (patch.metrics && current.metrics) {
						next.metrics = { ...current.metrics, ...patch.metrics };
					}
					if (patch.updateStatus && current.updateStatus) {
						next.updateStatus = { ...current.updateStatus, ...patch.updateStatus };
					}

					// Preserve cached elements
					next._elements = current._elements;

					this._hosts.set(id, next);
					renderHost(id);
				},

				setOffline(id) {
					this.update(id, { online: false, pendingCommand: null });
				}
			};

			// ═══════════════════════════════════════════════════════════════════════════
			// RENDER (Single Render Function) - P7000
			// ═══════════════════════════════════════════════════════════════════════════
			function renderHost(hostId) {
				const host = hostStore.get(hostId);
				if (!host) return;

				// Derived state
				const isOnline = host.online;
				const isBusy = !!host.pendingCommand;
				const buttonsEnabled = isOnline && !isBusy;

				// Use cached element references
				const { row, card } = host._elements || {};

				[row, card].filter(Boolean).forEach((el) => {
					// 1. Offline class
					el.classList.toggle('host-offline', !isOnline);

					// 2. Status indicator (ripple/dot)
					renderStatusIndicator(el, isOnline, isBusy);

					// 3. Progress badge
					renderProgressBadge(el, host.pendingCommand);

					// 4. Metrics
					if (host.metrics) {
						renderMetrics(el, host.metrics);
					}

					// 5. Update status compartments
					if (host.updateStatus) {
						renderUpdateStatus(el, host);
					}

					// 6. Button states: swap between cmd-buttons and stop button
					const cmdButtons = el.querySelector('.cmd-buttons');
					const stopBtn = el.querySelector('.btn-stop');
					if (cmdButtons) {
						cmdButtons.style.display = isBusy ? 'none' : '';
						cmdButtons.querySelectorAll('button').forEach(btn => {
							btn.disabled = !buttonsEnabled;
						});
					}
					if (stopBtn) {
						stopBtn.style.display = isBusy ? '' : 'none';
					}

					// 7. Last seen
					const lastSeenCell = el.querySelector('[data-cell="last-seen"]');
					if (lastSeenCell && host.lastSeen) {
						lastSeenCell.dataset.timestamp = host.lastSeen;
						const result = formatLastSeen(host.lastSeen);
						lastSeenCell.textContent = result.text;
						lastSeenCell.className = result.className;
					}
				});
			}

			// Helper: Render status indicator
			function renderStatusIndicator(el, isOnline, isBusy) {
				const wrapper = el.querySelector('.status-wrapper') || el.querySelector('.status-with-badge');
				if (!wrapper) return;

				const existing = wrapper.querySelector('.status-ripple, .status-dot');

				let html;
				if (isOnline && !isBusy) {
					if (existing?.classList.contains('status-ripple')) {
						triggerHeartbeat(existing);
						return;
					}
					html = '<span class="status-ripple"><span class="hb-wave"></span><span class="hb-wave"></span><span class="hb-wave"></span><span class="hb-core"></span></span>';
				} else if (isBusy) {
					html = '<span class="status-dot status-running"></span>';
				} else {
					html = '<span class="status-dot status-offline"></span>';
				}

				if (existing) {
					const temp = document.createElement('div');
					temp.innerHTML = html;
					existing.replaceWith(temp.firstChild);
					if (isOnline && !isBusy) {
						triggerHeartbeat(wrapper.querySelector('.status-ripple'));
					}
				}
			}

			// Helper: Render progress badge
			function renderProgressBadge(el, pendingCommand) {
				const wrapper = el.querySelector('.status-wrapper') || el.querySelector('.status-with-badge');
				if (!wrapper) return;

				let badge = wrapper.querySelector('.progress-badge-mini');
				if (pendingCommand) {
					if (!badge) {
						badge = document.createElement('span');
						badge.className = 'progress-badge-mini';
						wrapper.appendChild(badge);
					}
					badge.textContent = pendingCommand;
				} else if (badge) {
					badge.remove();
				}
			}

			// Helper: Render metrics
			function renderMetrics(el, metrics) {
				const cell = el.querySelector('[data-cell="metrics"]');
				if (!cell) return;

				const cpuEl = cell.querySelector('[data-metric="cpu"]');
				const ramEl = cell.querySelector('[data-metric="ram"]');

				if (cpuEl) {
					const val = cpuEl.querySelector('.metric-val');
					if (val) val.textContent = Math.round(metrics.cpu) + '%';
					cpuEl.classList.toggle('metric-high', metrics.cpu >= 80);
					cpuEl.dataset.value = metrics.cpu;
				}

				if (ramEl) {
					const val = ramEl.querySelector('.metric-val');
					if (val) val.textContent = Math.round(metrics.ram) + '%';
					ramEl.classList.toggle('metric-high', metrics.ram >= 80);
					ramEl.dataset.value = metrics.ram;
					ramEl.dataset.swap = metrics.swap;
					ramEl.dataset.load = metrics.load;
					ramEl.title = `RAM: ${Math.round(metrics.ram)}%, Swap: ${Math.round(metrics.swap)}%, Load: ${metrics.load.toFixed(2)}`;
				}

				// Replace "—" placeholder if needed
				const naSpan = cell.querySelector('.metrics-na');
				if (naSpan) {
					cell.innerHTML = `
						<span class="metric" data-metric="cpu" data-value="${metrics.cpu}">
							<svg class="metric-icon"><use href="#icon-cpu"></use></svg>
							<span class="metric-val">${Math.round(metrics.cpu)}%</span>
						</span>
						<span class="metric" data-metric="ram" data-value="${metrics.ram}">
							<svg class="metric-icon"><use href="#icon-ram"></use></svg>
							<span class="metric-val">${Math.round(metrics.ram)}%</span>
						</span>
					`;
				}
			}

			// Helper: Render update status compartments
			// P5100: Simplified - compartment styling constant, only indicator dot shows status
			function renderUpdateStatus(el, host) {
				const container = el.querySelector('.update-status');
				if (!container) return;

				const status = host.updateStatus;
				if (!status) return;

				const compartments = container.querySelectorAll('.update-compartment');

				['git', 'lock', 'system'].forEach((type, i) => {
					const comp = compartments[i];
					if (!comp) return;

					const check = status[type];
					
					// P5100: Only add 'unknown' class for dimming, no other state classes
					comp.className = 'update-compartment';
					if (!check || !check.status || check.status === 'unknown') {
						comp.classList.add('unknown');
					}

					// Update indicator dot - this is the ONLY status signal
					const indicator = comp.querySelector('.compartment-indicator');
					if (indicator && check) {
						indicator.className = 'compartment-indicator';
						// Map status to CSS class (outdated → warning to match server-side)
						const cssStatus = check.status === 'outdated' ? 'warning' : (check.status || 'unknown');
						indicator.classList.add(`compartment-indicator--${cssStatus}`);
					}

					// Lock-specific: agent outdated overrides indicator to error (red)
					if (type === 'lock') {
						if (indicator && host.agentOutdated) {
							indicator.className = 'compartment-indicator compartment-indicator--error';
						}
						// Pending PR indicator (small dot at top-right)
						comp.classList.toggle('has-pr', !!globalState.pendingPR);
					}
				});
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// REFRESH HOST (On-demand API call) - P7000
			// ═══════════════════════════════════════════════════════════════════════════
			async function refreshHost(hostId) {
				const host = hostStore.get(hostId);
				let btn = host?._elements?.row?.querySelector('.btn-refresh');
				if (!btn) {
					btn = document.querySelector(`button.btn-refresh[data-host-id="${hostId}"]`);
				}
				if (btn) btn.classList.add('loading');

				try {
					const resp = await fetch(`/api/hosts/${hostId}/refresh`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-CSRF-Token': CSRF_TOKEN
						}
					});

					if (resp.status === 404) {
						console.warn(`Host ${hostId} not found`);
						return;
					}

					if (!resp.ok) {
						console.error(`Refresh failed: ${resp.status} ${resp.statusText}`);
						return;
					}

					const data = await resp.json();

					// Update store with fresh data
					hostStore.update(hostId, {
						online: data.online,
						generation: data.generation,
						agentVersion: data.agent_version,
						agentOutdated: data.agent_outdated,
						updateStatus: data.update_status
					});

					// Update global PR state if included
					if (data.pending_pr !== undefined) {
						globalState.pendingPR = data.pending_pr;
					}

				} catch (err) {
					console.error('Refresh failed:', err);
				} finally {
					if (btn) btn.classList.remove('loading');
				}
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// WEBSOCKET - P7000 Simplified Messages
			// ═══════════════════════════════════════════════════════════════════════════
			let ws = null;
			let reconnectAttempts = 0;
			const maxReconnectDelay = 30000;

			function connectWebSocket() {
				const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
				ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

				ws.onopen = () => {
					console.log('WebSocket connected');
					reconnectAttempts = 0;
					updateConnectionStatus(true);
				};

				ws.onclose = () => {
					console.log('WebSocket disconnected');
					updateConnectionStatus(false);
					scheduleReconnect();
				};

				ws.onerror = (err) => {
					console.error('WebSocket error:', err);
				};

				ws.onmessage = (event) => {
					try {
						const msg = JSON.parse(event.data);
						handleMessage(msg);
					} catch (e) {
						console.error('Failed to parse message:', e);
					}
				};
			}

			function updateConnectionStatus(connected) {
				globalState.wsConnected = connected;
				const el = document.getElementById('ws-status');
				if (connected) {
					el.className = 'connection-indicator connected';
					el.innerHTML = '<span class="status-dot status-online"></span> Connected';
				} else {
					el.className = 'connection-indicator disconnected';
					el.innerHTML = '<span class="status-dot status-offline"></span> Disconnected';
				}
			}

			function scheduleReconnect() {
				reconnectAttempts++;
				const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
				console.log(`Reconnecting in ${delay}ms...`);
				setTimeout(connectWebSocket, delay);
			}

			// P7000: Simplified message handler
			function handleMessage(msg) {
				if (!msg || !msg.type) {
					console.warn('Invalid message:', msg);
					return;
				}

				const payload = msg.payload || {};
				const hostId = payload.host_id;

				switch (msg.type) {
					case 'host_heartbeat':
						if (!hostId) return;
						hostStore.update(hostId, {
							online: true,
							lastSeen: payload.last_seen,
							metrics: payload.metrics
						});
						break;

					case 'host_offline':
						if (!hostId) return;
						hostStore.setOffline(hostId);
						break;

					case 'command_queued':
						if (!hostId) return;
						hostStore.update(hostId, {
							pendingCommand: payload.command
						});
						showLogPanel(hostId);
						break;

					case 'command_output':
						appendLog(payload);
						break;

					case 'command_complete':
						if (!hostId) return;
						const host = hostStore.get(hostId);
						hostStore.update(hostId, {
							pendingCommand: null
						});
						window.dispatchEvent(new CustomEvent('log-complete', { detail: payload }));
						// P1010: Notify Action Bar of command completion
						window.dispatchEvent(new CustomEvent('command-complete', {
							detail: {
								hostId,
								hostname: host?.hostname || hostId,
								command: payload.command,
								exit_code: payload.exit_code || 0
							}
						}));
						break;

					case 'flake_update_job':
						// Keep for deployment progress display
						handleFlakeUpdateJob(payload);
						break;

					// P2800: State machine log messages
					case 'state_machine_log':
						handleStateMachineLog(payload);
						break;

					// P2700: Operation progress updates
					case 'operation_progress':
						if (!hostId) return;
						hostStore.update(hostId, {
							operationProgress: payload.progress
						});
						break;

					default:
						console.debug('Unknown WS message type:', msg.type);
				}
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// ACTIONS (User-initiated)
			// ═══════════════════════════════════════════════════════════════════════════
			function sendCommand(hostId, command) {
				const host = hostStore.get(hostId);
				const hostname = host?.hostname || hostId;

				// Immediate UI feedback
				hostStore.update(hostId, { pendingCommand: command });

				// P1010: Notify Action Bar of command start
				window.dispatchEvent(new CustomEvent('command-start', {
					detail: { hostId, hostname, command }
				}));

				fetch(`/api/hosts/${hostId}/command`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify({ command })
				}).then(resp => {
					if (!resp.ok) {
						return resp.text().then(text => { throw new Error(text); });
					}
					return resp.json();
				}).then(data => {
					console.log('Command queued:', data);
				}).catch(err => {
					console.error('Command failed:', err);
					// P2800: Parse validation error for friendly message
					let errorMsg = err.message || 'Unknown error';
					try {
						const parsed = JSON.parse(errorMsg);
						if (parsed.validation && parsed.validation.message) {
							errorMsg = parsed.validation.message;
						} else if (parsed.message) {
							errorMsg = parsed.message;
						}
					} catch (e) {
						// Not JSON, use original message
					}
					showToast(`Command failed: ${errorMsg}`, 'error');
					hostStore.update(hostId, { pendingCommand: null });
					// P1010: Notify Action Bar of failure
					window.dispatchEvent(new CustomEvent('command-complete', {
						detail: { hostId, hostname, command, exit_code: 1, error: errorMsg }
					}));
				});
			}

			function mergeAndDeploy(prNumber) {
				if (!confirm('Merge PR #' + prNumber + ' and deploy to all online hosts?')) return;

				fetch('/api/flake-updates/merge-and-deploy', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify({ pr_number: prNumber })
				})
				.then(resp => {
					if (!resp.ok) throw new Error('Failed to start deployment');
					return resp.json();
				})
				.then(data => {
					console.log('Deployment started:', data.job_id);
				})
				.catch(err => {
					alert('Failed to start deployment: ' + err.message);
				});
			}

			function bulkCommand(command) {
				const onlineHosts = hostStore.all().filter(h => h.online);
				if (onlineHosts.length === 0) {
					alert('No online hosts to send command to');
					return;
				}

				const confirmMsg = `Send "${command}" to ${onlineHosts.length} online host(s)?`;
				if (!confirm(confirmMsg)) return;

				onlineHosts.forEach(host => {
					sendCommand(host.id, command);
				});
			}

			// P2500: Do All - Pull → Switch → Test on ALL online hosts
			async function bulkDoAll() {
				const onlineHosts = hostStore.all().filter(h => h.online);
				if (onlineHosts.length === 0) {
					alert('No online hosts to send command to');
					return;
				}

				const confirmMsg = `Run Pull → Switch → Test on ${onlineHosts.length} online host(s)?`;
				if (!confirm(confirmMsg)) return;

				// Execute Pull → Switch → Test sequentially on all hosts
				for (const command of ['pull', 'switch', 'test']) {
					onlineHosts.forEach(host => sendCommand(host.id, command));
					// Wait a moment between command batches
					await new Promise(r => setTimeout(r, 500));
				}
			}

			function deleteHost(hostId) {
				if (!confirm(`Delete host "${hostId}"? This cannot be undone.`)) {
					return;
				}
				fetch(`/api/hosts/${hostId}`, {
					method: 'DELETE',
					headers: { 'X-CSRF-Token': CSRF_TOKEN }
				}).then(resp => {
					if (!resp.ok) {
						return resp.text().then(text => { throw new Error(text); });
					}
					return resp.json();
				}).then(data => {
					console.log('Host deleted:', data);
					document.querySelectorAll(`[data-host-id="${hostId}"]`).forEach(el => el.remove());
				}).catch(err => {
					console.error('Delete failed:', err);
					alert('Delete failed: ' + err.message);
				});
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// LOG PANEL (Alpine.js component - unchanged)
			// ═══════════════════════════════════════════════════════════════════════════
			function appendLog(payload) {
				window.dispatchEvent(new CustomEvent('log-line', { detail: payload }));
			}

			function showLogPanel(hostId) {
				const panel = document.getElementById('log-panel');
				panel.classList.remove('hidden');
				window.dispatchEvent(new CustomEvent('log-start', { detail: { hostId } }));
			}

			document.addEventListener('alpine:init', () => {
				Alpine.data('logViewer', () => ({
					open: true,
					lines: [],
					hostId: '',
					lineCounter: 0,
					phase: '',
					phaseIcon: '',
					buildCount: 0,
					buildCurrent: 0,

					init() {
						window.addEventListener('log-line', (e) => this.addLine(e.detail));
						window.addEventListener('log-start', (e) => {
							this.hostId = e.detail.hostId;
							this.lines = [];
							this.open = true;
							this.resetProgress();
						});
						window.addEventListener('log-complete', (e) => {
							this.phase = e.detail.exit_code === 0 ? 'Complete' : 'Failed';
							this.phaseIcon = e.detail.exit_code === 0 ? '✓' : '✗';
							this.addLine({
								line: `\n${this.phaseIcon} Command completed (exit code: ${e.detail.exit_code || 0})`,
								isSuccess: e.detail.exit_code === 0
							});
						});
					},

					resetProgress() {
						this.phase = '';
						this.phaseIcon = '';
						this.buildCount = 0;
						this.buildCurrent = 0;
					},

					parseProgress(line) {
						if (line.includes('evaluating derivation')) {
							this.phase = 'Evaluation';
							this.phaseIcon = '→';
						} else if (line.includes('these derivations will be built')) {
							const match = line.match(/these (\d+) derivations/);
							if (match) this.buildCount = parseInt(match[1], 10);
							this.phase = 'Building';
							this.phaseIcon = '●';
						} else if (line.includes("building '/nix/store/")) {
							this.buildCurrent++;
							this.phase = 'Building';
							this.phaseIcon = '●';
						} else if (line.includes('activating the configuration')) {
							this.phase = 'Activation';
							this.phaseIcon = '▶';
						} else if (line.includes('switching to configuration')) {
							this.phase = 'Switch';
							this.phaseIcon = '→';
						} else if (line.includes('setting up /etc')) {
							this.phase = 'Setup';
							this.phaseIcon = '○';
						} else if (line.includes('will be fetched')) {
							this.phase = 'Fetching';
							this.phaseIcon = '↓';
						}
					},

					toggle() { this.open = !this.open; },

					addLine(payload) {
						const text = payload.line;
						this.parseProgress(text);
						this.lines.push({
							id: ++this.lineCounter,
							text: text,
							isError: payload.is_error || payload.stream === 'stderr',
							isSuccess: payload.isSuccess || false
						});
						this.$nextTick(() => {
							const el = this.$refs.logContent;
							if (el) el.scrollTop = el.scrollHeight;
						});
					}
				}));
			});

			// ═══════════════════════════════════════════════════════════════════════════
			// UTILITIES
			// ═══════════════════════════════════════════════════════════════════════════
			function formatLastSeen(isoString) {
				if (!isoString) return { text: '—', className: '' };

				const date = new Date(isoString);
				const now = new Date();
				const diffMs = now - date;
				const diffSec = Math.max(0, Math.floor(diffMs / 1000));

				let text;
				if (diffSec < 60) {
					text = diffSec + 's';
				} else if (diffSec < 3600) {
					text = Math.floor(diffSec / 60) + 'm';
				} else if (diffSec < 86400) {
					text = Math.floor(diffSec / 3600) + 'h';
				} else {
					text = Math.floor(diffSec / 86400) + 'd';
				}

				let className;
				if (diffSec <= HEARTBEAT_INTERVAL * 2) {
					className = 'last-seen-ok';
				} else if (diffSec <= HEARTBEAT_INTERVAL * 10) {
					className = 'last-seen-warn';
				} else {
					className = 'last-seen-stale';
				}

				return { text, className };
			}

			function triggerHeartbeat(rippleEl) {
				if (!rippleEl) return;
				rippleEl.classList.add('heartbeat');
				setTimeout(() => rippleEl.classList.remove('heartbeat'), 1500);
			}

			function handleFlakeUpdateJob(job) {
				// P2600: Show deploy progress via toast
				const state = job.state || 'unknown';
				const message = job.message || '';
				
				switch (state) {
					case 'merging':
						showToast(`Merging PR #${job.pr_number || '?'}...`, 'info');
						break;
					case 'deploying':
						const hostCount = job.host_count || 'all';
						showToast(`Deploying to ${hostCount} hosts...`, 'info');
						break;
					case 'complete':
						showToast(message || 'Deploy complete!', 'success');
						break;
					case 'error':
						showToast(message || 'Deploy failed', 'error');
						break;
					default:
						// Log unknown states for debugging
						console.log('Flake update job:', state, message);
				}
			}

			// P2800: Handle state machine log messages
			function handleStateMachineLog(log) {
				// Dispatch to System Log component
				window.dispatchEvent(new CustomEvent('state-machine-log', { detail: log }));
				
				// Show important messages as toasts
				if (log.level === 'error') {
					showToast(`${log.host_id || 'System'}: ${log.message}`, 'error');
				} else if (log.level === 'warning' && log.state === 'VALIDATING→BLOCKED') {
					// Show blocked action warnings
					showToast(`${log.host_id}: ${log.message}`, 'info');
				}
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// MODALS & DROPDOWNS (Keep existing, no changes)
			// ═══════════════════════════════════════════════════════════════════════════
			function toggleDropdown(btn) {
				const dropdown = btn.closest('.dropdown');
				const wasOpen = dropdown.classList.contains('open');
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				if (!wasOpen) dropdown.classList.add('open');
			}

			document.addEventListener('click', (e) => {
				if (!e.target.closest('.dropdown')) {
					document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				}
			});

			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') {
					document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
					document.querySelectorAll('.modal-overlay.open').forEach(m => m.classList.remove('open'));
					closeBulkMenu();
				}
			});

			// P2100: Bulk menu with keyboard navigation
			let bulkMenuFocusedIndex = -1;

			function toggleBulkMenu(e) {
				e.stopPropagation();
				const menu = document.getElementById('bulk-actions-menu');
				const wasOpen = menu.classList.contains('open');
				menu.classList.toggle('open');
				if (!wasOpen) {
					bulkMenuFocusedIndex = 0;
					focusBulkMenuItem(0);
				} else {
					bulkMenuFocusedIndex = -1;
				}
			}

			function closeBulkMenu() {
				const menu = document.getElementById('bulk-actions-menu');
				if (menu) menu.classList.remove('open');
				bulkMenuFocusedIndex = -1;
			}

			function focusBulkMenuItem(idx) {
				const menu = document.getElementById('bulk-actions-menu');
				if (!menu) return;
				const items = [...menu.querySelectorAll('.dropdown-item')];
				if (items.length === 0) return;
				bulkMenuFocusedIndex = ((idx % items.length) + items.length) % items.length;
				items[bulkMenuFocusedIndex].focus();
			}

			function handleBulkMenuKeydown(e) {
				const menu = document.getElementById('bulk-actions-menu');
				if (!menu || !menu.classList.contains('open')) return;

				if (e.key === 'ArrowDown') {
					e.preventDefault();
					focusBulkMenuItem(bulkMenuFocusedIndex + 1);
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					focusBulkMenuItem(bulkMenuFocusedIndex - 1);
				} else if (e.key === 'Escape') {
					e.preventDefault();
					closeBulkMenu();
					// Return focus to the button
					const btn = document.querySelector('.bulk-actions-dropdown .btn');
					if (btn) btn.focus();
				}
			}

			document.addEventListener('click', (e) => {
				if (!e.target.closest('.bulk-actions-dropdown')) {
					closeBulkMenu();
				}
			});

			function unlockActions(btn) {
				const hostId = btn.dataset.hostId;
				hostStore.update(hostId, { pendingCommand: null });
				btn.closest('.dropdown').classList.remove('open');
			}

			function downloadLogs(hostId) {
				window.open(`/api/hosts/${hostId}/logs?download=true`, '_blank');
			}

			let pendingRemoveHostId = null;

			function confirmRemoveHost(hostId, hostname) {
				pendingRemoveHostId = hostId;
				document.getElementById('removeHostName').textContent = hostname;
				document.getElementById('removeHostModal').classList.add('open');
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
			}

			function doRemoveHost() {
				if (!pendingRemoveHostId) return;
				fetch(`/api/hosts/${pendingRemoveHostId}`, {
					method: 'DELETE',
					headers: { 'X-CSRF-Token': CSRF_TOKEN }
				}).then(resp => {
					if (!resp.ok) throw new Error('Failed to remove host');
					return resp.json();
				}).then(() => {
					document.querySelectorAll(`[data-host-id="${pendingRemoveHostId}"]`).forEach(el => el.remove());
					closeModal('removeHostModal');
				}).catch(err => {
					alert('Failed to remove host: ' + err.message);
				});
			}

			function closeModal(modalId) {
				document.getElementById(modalId).classList.remove('open');
				pendingRemoveHostId = null;
			}

			function openAddHostModal() {
				document.getElementById('addHostModal').classList.add('open');
			}

			function doAddHost() {
				const form = document.getElementById('addHostForm');
				const formData = new FormData(form);
				const data = Object.fromEntries(formData.entries());
				fetch('/api/hosts', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify(data)
				}).then(resp => {
					if (!resp.ok) throw new Error('Failed to add host');
					return resp.json();
				}).then(() => {
					closeModal('addHostModal');
					window.location.reload();
				}).catch(err => {
					alert('Failed to add host: ' + err.message);
				});
			}

			document.querySelectorAll('.modal-overlay').forEach(overlay => {
				overlay.addEventListener('click', (e) => {
					if (e.target === overlay) overlay.classList.remove('open');
				});
			});

			// ═══════════════════════════════════════════════════════════════════════════
			// ROW SELECTION HANDLERS (P1030)
			// ═══════════════════════════════════════════════════════════════════════════
			function handleHeaderCheckboxClick() {
				const store = Alpine.store('selection');
				if (store.headerState === 'none') {
					store.selectAll();
				} else {
					store.selectNone();
				}
			}

			function handleCheckboxClick(event, hostId) {
				event.stopPropagation();
				const store = Alpine.store('selection');
				if (event.shiftKey && store.lastSelected) {
					store.selectRange(hostId);
				} else {
					store.toggle(hostId);
				}
			}

			// Keyboard shortcuts for selection
			document.addEventListener('keydown', (e) => {
				if (e.target.matches('input, textarea, [contenteditable]')) return;

				// Ctrl/Cmd + A: Select all
				if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
					e.preventDefault();
					Alpine.store('selection').selectAll();
				}

				// Escape: Clear selection (if any)
				if (e.key === 'Escape') {
					const store = Alpine.store('selection');
					if (store.count > 0) {
						e.preventDefault();
						store.selectNone();
					}
				}
			});

			// ═══════════════════════════════════════════════════════════════════════════
			// CLICKABLE COMPARTMENTS (P1020)
			// ═══════════════════════════════════════════════════════════════════════════
			const compartmentCooldowns = new Map();
			const COOLDOWN_MS = 500;

			// P2500: Enhanced hover with full description
			function handleCompartmentHover(btn) {
				const hostId = btn.dataset.hostId;
				const hostname = btn.dataset.hostname;
				const compartment = btn.dataset.compartment;
				const action = btn.dataset.action;
				const description = btn.dataset.description || '';

				// Don't show preview for error/info actions
				if (action === 'error' || action === 'info') return;

				window.dispatchEvent(new CustomEvent('action-preview', {
					detail: { hostId, hostname, command: action, compartment, description }
				}));
			}

			function handleCompartmentLeave() {
				window.dispatchEvent(new CustomEvent('action-clear'));
			}

			function handleCompartmentClick(btn) {
				const hostId = btn.dataset.hostId;
				const hostname = btn.dataset.hostname;
				const compartment = btn.dataset.compartment;
				const action = btn.dataset.action;

				// Rate limiting
				const cooldownKey = `${hostId}-${compartment}`;
				if (compartmentCooldowns.has(cooldownKey)) return;

				compartmentCooldowns.set(cooldownKey, true);
				btn.classList.add('rate-limited');
				setTimeout(() => {
					compartmentCooldowns.delete(cooldownKey);
					btn.classList.remove('rate-limited');
				}, COOLDOWN_MS);

				// Execute action
				switch (action) {
					case 'refresh':
						refreshHost(hostId);
						showToast(`${hostname}: Status is up to date`, 'success');
						break;
					case 'pull':
						sendCommand(hostId, 'pull');
						break;
					case 'switch':
						sendCommand(hostId, 'switch');
						break;
					case 'info':
						showToast('Dependencies outdated — merge the PR to update flake.lock', 'info');
						break;
					case 'error':
						showToast(btn.title || 'Status check failed', 'error');
						break;
					default:
						refreshHost(hostId);
				}
			}

			function showToast(message, type = 'info') {
				const existing = document.querySelector('.toast');
				if (existing) existing.remove();

				const toast = document.createElement('div');
				toast.className = `toast toast-${type}`;
				toast.textContent = message;
				document.body.appendChild(toast);

				requestAnimationFrame(() => toast.classList.add('show'));

				setTimeout(() => {
					toast.classList.remove('show');
					setTimeout(() => toast.remove(), 300);
				}, 3000);
			}

			// P1060: Clipboard utility
			async function copyToClipboard(text, message) {
				try {
					await navigator.clipboard.writeText(text);
					showToast(message, 'success');
				} catch (err) {
					console.error('Failed to copy:', err);
					showToast('Failed to copy to clipboard', 'error');
				}
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// CONTEXT BAR COMPONENT - Unified hover preview + selection actions
			// ═══════════════════════════════════════════════════════════════════════════
			// P2500: Enhanced Context Bar with full descriptions and PR support
			document.addEventListener('alpine:init', () => {
				Alpine.data('contextBar', () => ({
					// Hover state
					hoverAction: null,
					_clearTimer: null,

					init() {
						// Listen for hover events from compartments
						window.addEventListener('action-preview', (e) => this.handlePreview(e.detail));
						window.addEventListener('action-clear', () => this.handleClear());
					},

					// Computed properties
					get selectedCount() {
						return Alpine.store('selection').selected.length;
					},

					get onlineCount() {
						const selected = Alpine.store('selection').selected;
						return selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						}).length;
					},

					get pendingPR() {
						return globalState.pendingPR;
					},

					get hasContent() {
						return this.hoverAction !== null || this.selectedCount > 0 || this.pendingPR !== null;
					},

					get selectionText() {
						const total = this.selectedCount;
						const online = this.onlineCount;
						if (total === 0) return '';
						const hostWord = total === 1 ? 'host' : 'hosts';
						if (online === total) return `${total} ${hostWord}`;
						return `${total} ${hostWord} (${online} online)`;
					},

					// Hover handlers - P2500: now includes description
					handlePreview(detail) {
						if (this._clearTimer) {
							clearTimeout(this._clearTimer);
							this._clearTimer = null;
						}
						this.hoverAction = {
							command: detail.command,
							hostname: detail.hostname,
							hostId: detail.hostId,
							description: detail.description || ''
						};
					},

					handleClear() {
						// Debounce clearing to prevent flicker
						this._clearTimer = setTimeout(() => {
							this.hoverAction = null;
							this._clearTimer = null;
						}, 200);
					},

					// Bulk actions
					bulkCommand(command) {
						const selected = Alpine.store('selection').selected;
						const onlineHostIds = selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						});
						if (onlineHostIds.length === 0) return;
						onlineHostIds.forEach(hostId => sendCommand(hostId, command));
					},

					// Do All: Pull → Switch → Test in sequence
					async doAll() {
						const selected = Alpine.store('selection').selected;
						const onlineHostIds = selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						});
						if (onlineHostIds.length === 0) return;

						// Execute Pull → Switch → Test sequentially on all hosts
						for (const command of ['pull', 'switch', 'test']) {
							onlineHostIds.forEach(hostId => sendCommand(hostId, command));
							// Wait a moment between commands
							await new Promise(r => setTimeout(r, 500));
						}
					},

					// P2500: Merge and deploy PR
					mergeAndDeployPR() {
						if (!this.pendingPR) return;
						mergeAndDeploy(this.pendingPR.number);
					},

					// P2500: Get human-readable PR description for sysop context
					getPRDescription() {
						const pr = this.pendingPR;
						if (!pr) return '';
						
						// Build context-rich description
						const parts = [];
						if (pr.title) {
							parts.push(pr.title);
						} else {
							parts.push('Ready to merge');
						}
						
						// Add info about how many hosts would be affected
						const totalHosts = hostStore.all().length;
						const onlineHosts = hostStore.all().filter(h => h.online).length;
						if (totalHosts > 0) {
							parts.push(`• will deploy to ${onlineHosts}/${totalHosts} hosts`);
						}
						
						return parts.join(' ');
					},

					clearSelection() {
						Alpine.store('selection').selectNone();
					}
				}));

				// ═══════════════════════════════════════════════════════════════════════════
				// DEPENDENCY DIALOG COMPONENT (P1040)
				// ═══════════════════════════════════════════════════════════════════════════
				Alpine.data('dependencyDialog', () => ({
					show: false,
					title: '',
					message: '',
					hosts: [],
					executing: false,
					progressText: '',
					cancelled: false,
					_completionHandlers: [],

					init() {
						window.addEventListener('show-dependency-dialog', (e) => this.open(e.detail));
					},

					open(detail) {
						this.title = detail.title;
						this.message = detail.message;
						this.hosts = detail.hosts;
						this.executing = false;
						this.progressText = '';
						this.cancelled = false;
						this.show = true;
					},

					close() {
						if (this.executing) return;
						this.show = false;
						this._cleanup();
					},

					handleEscape() {
						if (this.executing) {
							this.cancelExecution();
						} else {
							this.close();
						}
					},

					async choose(action) {
						switch (action) {
							case 'pull':
								sendCommand(this.hosts[0].id, 'pull');
								this.show = false;
								break;
							case 'switch':
								sendCommand(this.hosts[0].id, 'switch');
								this.show = false;
								break;
							case 'pull-switch':
								await this.executePullThenSwitch([this.hosts[0]]);
								break;
							case 'switch-all':
								this.hosts.forEach(h => sendCommand(h.id, 'switch'));
								this.show = false;
								break;
							case 'pull-switch-all':
								await this.executePullThenSwitch(this.hosts);
								break;
						}
					},

					async executePullThenSwitch(hosts) {
						this.executing = true;
						this.cancelled = false;

						const hostsToPull = hosts.filter(h => h.needsPull);
						const hostsToSwitchOnly = hosts.filter(h => !h.needsPull);

						try {
							if (hostsToPull.length > 0) {
								this.progressText = `Pulling ${hostsToPull.length} host${hostsToPull.length > 1 ? 's' : ''}...`;
								await Promise.all(hostsToPull.map(h => {
									if (this.cancelled) throw new Error('Cancelled');
									return this._sendCommandAndWait(h.id, 'pull');
								}));
							}

							if (this.cancelled) {
								this._showCancelled();
								return;
							}

							const allToSwitch = [...hostsToPull, ...hostsToSwitchOnly];
							this.progressText = `Switching ${allToSwitch.length} host${allToSwitch.length > 1 ? 's' : ''}...`;
							allToSwitch.forEach(h => {
								if (!this.cancelled) sendCommand(h.id, 'switch');
							});

							this.show = false;
							this._cleanup();
						} catch (err) {
							if (err.message === 'Cancelled') {
								this._showCancelled();
							} else {
								console.error('Pull+Switch failed:', err);
								this.progressText = `Error: ${err.message}`;
								setTimeout(() => { this.executing = false; }, 2000);
							}
						}
					},

					cancelExecution() {
						this.cancelled = true;
						this.progressText = 'Cancelling...';
					},

					_showCancelled() {
						this.progressText = 'Cancelled';
						setTimeout(() => {
							this.show = false;
							this.executing = false;
							this._cleanup();
						}, 1000);
					},

					_sendCommandAndWait(hostId, command) {
						return new Promise((resolve, reject) => {
							const handler = (e) => {
								const detail = e.detail;
								if (detail.hostId === hostId) {
									window.removeEventListener('command-complete', handler);
									const idx = this._completionHandlers.indexOf(handler);
									if (idx !== -1) this._completionHandlers.splice(idx, 1);
									if (detail.exit_code === 0) {
										resolve();
									} else {
										reject(new Error(`${command} failed on ${hostId} (exit ${detail.exit_code})`));
									}
								}
							};
							window.addEventListener('command-complete', handler);
							this._completionHandlers.push(handler);
							sendCommand(hostId, command);
						});
					},

					_cleanup() {
						this._completionHandlers.forEach(handler => {
							window.removeEventListener('command-complete', handler);
						});
						this._completionHandlers = [];
					}
				}));
			});

			// ═══════════════════════════════════════════════════════════════════════════
			// DEPENDENCY CHECK HELPER (P1040)
			// ═══════════════════════════════════════════════════════════════════════════
			function checkDependenciesAndExecute(hostIds, command) {
				if (command !== 'switch') {
					hostIds.forEach(id => sendCommand(id, command));
					return;
				}

				const hostsNeedingPull = [];
				const hostsReady = [];

				hostIds.forEach(id => {
					const host = hostStore.get(id);
					if (!host) return;

					const gitStatus = host.updateStatus?.git?.status;
					if (gitStatus === 'outdated') {
						hostsNeedingPull.push({ id: host.id, hostname: host.hostname, needsPull: true });
					} else {
						hostsReady.push({ id: host.id, hostname: host.hostname, needsPull: false });
					}
				});

				if (hostsNeedingPull.length === 0) {
					hostIds.forEach(id => sendCommand(id, 'switch'));
					return;
				}

				const allHosts = [...hostsNeedingPull, ...hostsReady];
				const isSingle = allHosts.length === 1;

				window.dispatchEvent(new CustomEvent('show-dependency-dialog', {
					detail: {
						title: isSingle
							? `Git is behind on ${allHosts[0].hostname}`
							: `${hostsNeedingPull.length} of ${allHosts.length} hosts need Pull first`,
						message: 'Running Switch without Pull may deploy old code.',
						hosts: allHosts
					}
				}));
			}

			// ═══════════════════════════════════════════════════════════════════════════
			// INIT - P7000
			// ═══════════════════════════════════════════════════════════════════════════
			hostStore.hydrate();
			connectWebSocket();

			// Update last-seen every second
			setInterval(() => {
				hostStore.all().forEach(host => {
					if (host.lastSeen) {
						const { row, card } = host._elements || {};
						[row, card].filter(Boolean).forEach(el => {
							const cell = el.querySelector('[data-cell="last-seen"]');
							if (cell) {
								const result = formatLastSeen(host.lastSeen);
								cell.textContent = result.text;
								cell.className = result.className;
							}
						});
					}
				});
			}, 1000);
		</script>
	}
}

// P2500: ContextBar - Unified bar with stacked rows for PR, hover, and selection
templ ContextBar() {
	<div
		id="context-bar"
		class="context-bar"
		x-data="contextBar"
		:class="{ 'context-bar-empty': !hasContent }"
	>
		<!-- Row 1: PR info (when pending PR) -->
		<template x-if="pendingPR && pendingPR.mergeable">
			<div class="context-row context-row-pr">
				<div class="context-row-info">
					<svg class="icon icon-pr"><use href="#icon-git-pull-request"></use></svg>
					<span class="pr-label">PR #<span x-text="pendingPR.number"></span></span>
					<span class="pr-detail" x-text="getPRDescription()"></span>
				</div>
				<button class="btn btn-merge" @click="mergeAndDeployPR()">
					<svg class="icon"><use href="#icon-git-merge"></use></svg>
					<span>Merge & Deploy</span>
				</button>
			</div>
		</template>

		<!-- Row 2: Hover context (when hovering a compartment) -->
		<template x-if="hoverAction">
			<div class="context-row context-row-hover">
				<span class="context-host" x-text="hoverAction.hostname"></span>
				<span class="context-description" x-text="hoverAction.description"></span>
			</div>
		</template>

		<!-- Row 3: Selection + Actions (when hosts selected) -->
		<template x-if="$store.selection.selected.length > 0">
			<div class="context-row context-row-selection">
				<div class="context-row-info">
					<svg class="icon icon-check"><use href="#icon-check-square"></use></svg>
					<span x-text="selectionText"></span>
				</div>
				<div class="context-actions">
					<button
						class="btn btn-context"
						:disabled="onlineCount === 0"
						@click="bulkCommand('pull')"
					>
						<svg class="icon"><use href="#icon-download"></use></svg>
						<span class="btn-label">Pull</span>
					</button>
					<button
						class="btn btn-context"
						:disabled="onlineCount === 0"
						@click="bulkCommand('switch')"
					>
						<svg class="icon"><use href="#icon-refresh"></use></svg>
						<span class="btn-label">Switch</span>
					</button>
					<button
						class="btn btn-context"
						:disabled="onlineCount === 0"
						@click="bulkCommand('test')"
					>
						<svg class="icon"><use href="#icon-flask"></use></svg>
						<span class="btn-label">Test</span>
					</button>
					<button
						class="btn btn-primary btn-do-all"
						:disabled="onlineCount === 0"
						@click="doAll()"
					>
						<svg class="icon"><use href="#icon-play"></use></svg>
						<span class="btn-label">Do All</span>
					</button>
					<button
						class="btn btn-clear"
						@click="clearSelection()"
					>
						<svg class="icon"><use href="#icon-x"></use></svg>
					</button>
				</div>
			</div>
		</template>
	</div>
}

// DependencyDialog renders the dependency warning modal (P1040)
templ DependencyDialog() {
	<div
		id="dependency-dialog"
		class="modal-overlay"
		x-data="dependencyDialog"
		x-show="show"
		x-cloak
		@keydown.escape.window="handleEscape()"
		@click.self="close()"
	>
		<div class="modal dialog-modal" @click.stop>
			<div class="dialog-header">
				<svg class="dialog-icon warning"><use href="#icon-alert-triangle"></use></svg>
				<h3 class="dialog-title" x-text="title"></h3>
			</div>

			<div class="dialog-body">
				<p class="dialog-message" x-text="message"></p>

				<!-- Host list for multi-host -->
				<template x-if="hosts.length > 1">
					<ul class="dialog-host-list">
						<template x-for="host in hosts" :key="host.id">
							<li :class="{ 'needs-action': host.needsPull }">
								<span class="host-name" x-text="host.hostname"></span>
								<span class="host-status" x-text="host.needsPull ? 'Git is behind' : 'OK (will switch)'"></span>
							</li>
						</template>
					</ul>
				</template>
			</div>

			<div class="dialog-footer">
				<button type="button" class="btn btn-cancel" @click="close()">
					Cancel
				</button>

				<div class="dialog-actions">
					<!-- Single-host buttons -->
					<template x-if="hosts.length === 1">
						<div class="dialog-action-group">
							<button type="button" class="btn" @click="choose('pull')">
								Pull Only
							</button>
							<button type="button" class="btn" @click="choose('switch')">
								Switch Anyway
							</button>
							<button type="button" class="btn btn-primary" @click="choose('pull-switch')">
								Pull + Switch
							</button>
						</div>
					</template>

					<!-- Multi-host buttons -->
					<template x-if="hosts.length > 1">
						<div class="dialog-action-group">
							<button type="button" class="btn" @click="choose('switch-all')">
								Switch All Anyway
							</button>
							<button type="button" class="btn btn-primary" @click="choose('pull-switch-all')">
								Pull + Switch All
							</button>
						</div>
					</template>
				</div>
			</div>

			<!-- Progress overlay -->
			<div class="dialog-progress" x-show="executing" x-cloak>
				<div class="progress-content">
					<svg class="icon spinning"><use href="#icon-loader"></use></svg>
					<span x-text="progressText"></span>
					<button type="button" class="btn btn-cancel-small" @click="cancelExecution()">
						Cancel
					</button>
				</div>
			</div>
		</div>
	</div>
}

// FleetTargetLine renders the fleet target info in the header
templ FleetTargetLine(target FleetTarget) {
	<div class="fleet-target">
		if target.HasData {
			<span class="target-label">Target:</span>
			<svg class="target-icon"><use href="#icon-git-branch"></use></svg>
			<a
				href={ templ.SafeURL("https://github.com/" + target.RepoURL + "/commit/" + target.GitFull) }
				target="_blank"
				rel="noopener"
				class="target-commit"
				title={ "Latest commit: " + target.Message }
			>
				{ target.GitCommit }
			</a>
			<span class="target-branch">({ target.Branch }, { target.TimeAgo })</span>
			<span class="target-separator">•</span>
			<span class="target-agent-label">Agent:</span>
			<span class="target-agent" title={ "Expected agent version: " + target.AgentVer }>{ target.AgentVer }</span>
		} else {
			<span class="target-label">Target:</span>
			<span class="target-unavailable">Version tracking not configured</span>
		}
	</div>
}

// P7000: FlakeUpdateBanner removed - functionality moved to Bulk Actions dropdown

// HostCard renders a host as a card (mobile view)
templ HostCard(host Host, csrfToken string) {
	<div class={ "host-card", templ.KV("host-offline", !host.Online) } data-host-id={ host.ID } x-data="{ expanded: false }">
		<div class="host-card-header" @click="expanded = !expanded">
			<div class="host-name">
				<span class="status-with-badge">
					@StatusIndicator(host)
					if host.PendingCommand != "" {
						<span class="progress-badge-mini">{ host.PendingCommand }</span>
					}
				</span>
				<span style={ hostColorStyle(host) }>{ host.Hostname }</span>
			</div>
			<span class="chevron" :class="{ 'expanded': expanded }">▼</span>
		</div>
		<div class="host-card-body" x-show="expanded" x-collapse>
			<div class="host-card-row">
				<span class="host-card-label">Type</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@osTypeIcon(host.HostType)
					{ host.HostType }
				</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Location</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@locationIcon(host.Location)
					{ host.Location }
				</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Device</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@deviceTypeIcon(host.DeviceType)
					{ host.DeviceType }
				</span>
			</div>
			if host.Metrics != nil {
				<div class="host-card-row">
					<span class="host-card-label">Metrics</span>
					<span class="metrics-cell">
						<span class={ metricsClass("cpu", host.Metrics.CPU) }><svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.CPU) }</span></span>
						<span class={ metricsClass("ram", host.Metrics.RAM) }><svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.RAM) }</span></span>
						<span class="metric"><span class="metric-val">{ formatLoad(host.Metrics.Load) }</span></span>
					</span>
				</div>
			}
			if host.TestProgress != nil {
				<div class="host-card-row">
					<span class="host-card-label">Tests</span>
					@TestsCell(host.TestProgress)
				</div>
			}
			<div class="host-card-row">
				<span class="host-card-label">OS Version</span>
				<span>{ valueOrDash(host.OSVersion) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Generation</span>
				<span>{ valueOrDash(host.Generation) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Agent</span>
				<span>{ valueOrDash(host.AgentVersion) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Last Seen</span>
				<span data-cell="last-seen" data-timestamp={ host.LastSeen }>{ valueOrDash(host.LastSeen) }</span>
			</div>
			<div class="host-card-actions">
				@CommandButton(host.ID, "pull", "Pull", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "switch", "Switch", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "test", "Test", "btn", host.Online && host.PendingCommand == "")
				@DeleteButton(host.ID, !host.Online)
			</div>
		</div>
	</div>
}

// HostRow renders a host as a table row (desktop view)
// P7000: data-* attributes for client-side hydration
// P1030: x-data for Alpine.js selection bindings
templ HostRow(host Host, csrfToken string) {
	<tr
		data-host-id={ host.ID }
		data-hostname={ host.Hostname }
		data-host-type={ host.HostType }
		data-theme-color={ host.ThemeColor }
		data-generation={ host.Generation }
		data-agent-version={ host.AgentVersion }
		data-agent-outdated={ strconv.FormatBool(host.AgentOutdated) }
		data-pending-command={ host.PendingCommand }
		class={ templ.KV("host-offline", !host.Online) }
		x-data
		x-bind:class={ selectionClassBinding(host.ID) }
	>
		<td class="status-cell-with-badge">
			<span class="status-wrapper">
				@StatusIndicator(host)
				<span style={ hostColorStyle(host) }>{ host.Hostname }</span>
				if host.PendingCommand != "" {
					<span class="progress-badge-mini">{ host.PendingCommand }</span>
				}
			</span>
		</td>
		<!-- P2700: Composite TYPE column (Location + Device + OS) -->
		<td class="col-center col-type">
			@CompositeTypeCell(host)
		</td>
		<td class="metrics-cell" data-cell="metrics">
			if host.Metrics != nil {
				<span class={ metricsClass("cpu", host.Metrics.CPU) } data-metric="cpu" title={ "CPU: " + formatPercent(host.Metrics.CPU) }>
					<svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.CPU) }</span>
				</span>
				<span class={ metricsClass("ram", host.Metrics.RAM) } data-metric="ram" title={ "RAM: " + formatPercent(host.Metrics.RAM) + ", Swap: " + formatPercent(host.Metrics.Swap) + ", Load: " + formatLoad(host.Metrics.Load) }>
					<svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.RAM) }</span>
				</span>
			} else {
				<span class="metrics-na">—</span>
			}
		</td>
		<td class="update-cell" data-cell="update">
			@UpdateStatusCell(host)
		</td>
		<!-- P2700: STATUS column replaces TESTS -->
		<td class="status-progress-cell" data-cell="status">
			@StatusProgressCell(host)
		</td>
		<td class="col-right" data-cell="last-seen" data-timestamp={ host.LastSeen }>{ valueOrDash(host.LastSeen) }</td>
		<!-- P1050: Actions column removed - Pull/Switch via compartments, Test via menu -->
		<td class="col-menu">
			@ActionDropdown(host)
		</td>
		<!-- P1030: Selection checkbox (right side, subtle button style) -->
		<td class="col-select">
			<button
				type="button"
				class="select-toggle row-select-toggle"
				@click={ checkboxClickHandler(host.ID) }
				x-bind:class={ rowSelectedClass(host.ID) }
				title="Select host"
			>
				<svg class="icon" x-bind:style={ iconVisibility(host.ID, false) }><use href="#icon-square"></use></svg>
				<svg class="icon" x-bind:style={ iconVisibility(host.ID, true) }><use href="#icon-check-square"></use></svg>
			</button>
		</td>
	</tr>
}

// StatusIndicator renders the appropriate status indicator (ripple for online, dot for offline)
templ StatusIndicator(host Host) {
	if host.Online && host.PendingCommand == "" {
		<span class="status-ripple">
			<span class="hb-wave"></span>
			<span class="hb-wave"></span>
			<span class="hb-wave"></span>
			<span class="hb-core"></span>
		</span>
	} else if host.PendingCommand != "" {
		<span class="status-dot status-running"></span>
	} else {
		<span class="status-dot status-offline"></span>
	}
}

// CommandButton renders a command button with proper onclick handling and SVG icon
templ CommandButton(hostID, command, label, classes string, enabled bool) {
	if enabled {
		<button 
			class={ classes }
			data-host-id={ hostID }
			data-command={ command }
			onclick="sendCommand(this.dataset.hostId, this.dataset.command)"
			title={ commandTitle(command) }
		>
			@commandIcon(command)
			if label != "" {
				{ label }
			}
		</button>
	} else {
		<button class={ classes } disabled title={ commandTitle(command) }>
			@commandIcon(command)
			if label != "" {
				{ label }
			}
		</button>
	}
}

// commandTitle returns a human-readable title for button tooltips
func commandTitle(command string) string {
	switch command {
	case "pull":
		return "Pull latest code from Git"
	case "switch":
		return "Apply configuration (nixos-rebuild switch)"
	case "test":
		return "Test configuration (nixos-rebuild test)"
	case "stop":
		return "Stop running command"
	default:
		return command
	}
}

// commandIcon renders the SVG icon for a command
templ commandIcon(command string) {
	switch command {
		case "pull":
			<svg class="icon"><use href="#icon-download"></use></svg>
		case "switch":
			<svg class="icon"><use href="#icon-refresh"></use></svg>
		case "test":
			<svg class="icon"><use href="#icon-flask"></use></svg>
		case "stop":
			<svg class="icon"><use href="#icon-stop"></use></svg>
		default:
			// No icon for unknown commands
	}
}

// osTypeIcon renders the OS type icon (NixOS or macOS)
templ osTypeIcon(hostType string) {
	switch hostType {
		case "nixos":
			<svg class="icon type-icon" title="NixOS"><use href="#icon-nixos"></use></svg>
		case "macos":
			<svg class="icon type-icon" title="macOS"><use href="#icon-apple"></use></svg>
		default:
			<span>{ hostType }</span>
	}
}

// locationIcon renders the location icon
templ locationIcon(location string) {
	switch location {
		case "home":
			<svg class="icon location-icon" title="Home"><use href="#icon-home"></use></svg>
		case "work":
			<svg class="icon location-icon" title="Work"><use href="#icon-office"></use></svg>
		case "cloud":
			<svg class="icon location-icon" title="Cloud"><use href="#icon-cloud"></use></svg>
		default:
			<svg class="icon location-icon" title="Home"><use href="#icon-home"></use></svg>
	}
}

// deviceTypeIcon renders the device type icon
templ deviceTypeIcon(deviceType string) {
	switch deviceType {
		case "server":
			<svg class="icon device-icon" title="Server"><use href="#icon-server"></use></svg>
		case "desktop":
			<svg class="icon device-icon" title="Desktop"><use href="#icon-desktop"></use></svg>
		case "laptop":
			<svg class="icon device-icon" title="Laptop"><use href="#icon-laptop"></use></svg>
		case "gaming":
			<svg class="icon device-icon" title="Gaming"><use href="#icon-game"></use></svg>
		default:
			<svg class="icon device-icon" title="Desktop"><use href="#icon-desktop"></use></svg>
	}
}

// TestsCell renders the test progress/results cell
templ TestsCell(progress *TestProgress) {
	if progress != nil {
		if progress.Running {
			<span class="test-progress">{ strconv.Itoa(progress.Current) }/{ strconv.Itoa(progress.Total) }</span>
		} else if progress.Result != "" {
			if progress.Passed == progress.Total {
				<span class="test-result pass">{ progress.Result }</span>
			} else {
				<span class="test-result fail">{ progress.Result }</span>
			}
		} else {
			<span class="tests-na">—</span>
		}
	} else {
		<span class="tests-na">—</span>
	}
}

// P2700: CompositeTypeCell renders the combined Location/Device/OS type cell
templ CompositeTypeCell(host Host) {
	<div
		class="type-composite"
		data-host-id={ host.ID }
		data-location={ host.Location }
		data-device={ host.DeviceType }
		data-os={ host.HostType }
		title={ compositeTypeTitle(host) }
	>
		<!-- LOC icon (80%, center-Y, left-aligned) -->
		<span class="type-loc">
			@locationIcon(host.Location)
		</span>
		<!-- DEV icon (25%, top-right superscript) -->
		<span class="type-dev">
			@deviceTypeIcon(host.DeviceType)
		</span>
		<!-- OS icon (25%, bottom-right subscript) -->
		<span class="type-os">
			@osTypeIcon(host.HostType)
		</span>
	</div>
}

// P2700: StatusProgressCell renders the segmented progress bar + test results
templ StatusProgressCell(host Host) {
	<div
		class="status-progress"
		data-host-id={ host.ID }
		data-pending={ host.PendingCommand }
	>
		<!-- PULL segment (4 dots) -->
		<span class="progress-segment segment-pull" data-phase="pull">
			@progressDots(getPhaseProgress(host.OperationProgress, "pull"), 4)
		</span>
		<!-- LOCK segment (2 dots) -->
		<span class="progress-segment segment-lock" data-phase="lock">
			@progressDots(getPhaseProgress(host.OperationProgress, "lock"), 2)
		</span>
		<!-- SYSTEM segment (3 dots) -->
		<span class="progress-segment segment-system" data-phase="system">
			@progressDots(getPhaseProgress(host.OperationProgress, "system"), 3)
		</span>
		<!-- TESTS segment (variable, max 8) -->
		<span class="progress-segment segment-tests" data-phase="tests">
			@testsDots(host)
		</span>
	</div>
}

// progressDots renders dots for a progress phase
templ progressDots(progress *PhaseProgress, total int) {
	for i := 0; i < total; i++ {
		<span class={ progressDotClass(progress, i) }>{ progressDotChar(progress, i) }</span>
	}
}

// testsDots renders dots for test results
templ testsDots(host Host) {
	if host.TestProgress != nil && host.TestProgress.Total > 0 {
		for i := 0; i < minInt(host.TestProgress.Total, 8); i++ {
			<span class={ testDotClass(host.TestProgress, i) }>{ testDotChar(host.TestProgress, i) }</span>
		}
	} else if host.OperationProgress != nil && host.OperationProgress.Tests != nil {
		for i := 0; i < minInt(host.OperationProgress.Tests.Total, 8); i++ {
			<span class={ operationTestDotClass(host.OperationProgress.Tests, i) }>{ operationTestDotChar(host.OperationProgress.Tests, i) }</span>
		}
	} else {
		<span class="tests-dash">—</span>
	}
}

// UpdateStatusCell renders the update status indicator (3 compartments with agent badge overlay on Lock)
// P7000: data-* attributes for client-side hydration
// P1020: UpdateStatusCell with clickable compartments
templ UpdateStatusCell(host Host) {
	<div
		class="update-status"
		data-host-id={ host.ID }
		data-git={ updateStatusJSON(host.UpdateStatus, "git") }
		data-lock={ updateStatusJSON(host.UpdateStatus, "lock") }
		data-system={ updateStatusJSON(host.UpdateStatus, "system") }
		data-repo-url={ host.RepoURL }
		data-repo-dir={ host.RepoDir }
	>
		<!-- Git compartment (P2500: added data-description for context bar) -->
		<button
			type="button"
			class={ compartmentButtonClass(host.UpdateStatus, "git") }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="git"
			data-status={ getCompartmentStatus(host.UpdateStatus, "git") }
			data-action={ getCompartmentActionType(host.UpdateStatus, "git") }
			data-description={ gitContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			<svg class="update-icon"><use href="#icon-git-branch"></use></svg>
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "git") }></span>
		</button>
		<!-- Lock compartment (P2500: added data-description for context bar) -->
		<button
			type="button"
			class={ lockCompartmentButtonClass(host) }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="lock"
			data-status={ getLockStatus(host) }
			data-action={ getLockActionType(host) }
			data-description={ lockContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			<svg class="update-icon"><use href="#icon-lock"></use></svg>
			<span class={ lockIndicatorClass(host) }></span>
		</button>
		<!-- System compartment (P2500: added data-description for context bar) -->
		<button
			type="button"
			class={ compartmentButtonClass(host.UpdateStatus, "system") }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="system"
			data-status={ getCompartmentStatus(host.UpdateStatus, "system") }
			data-action={ getCompartmentActionType(host.UpdateStatus, "system") }
			data-description={ systemContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			if host.HostType == "macos" {
				<svg class="update-icon"><use href="#icon-home"></use></svg>
			} else {
				<svg class="update-icon"><use href="#icon-nixos"></use></svg>
			}
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "system") }></span>
		</button>
	</div>
}

// ActionDropdown renders the per-host action dropdown menu
// P1060: ActionDropdown with reorganized menu (Test at top, grouped items)
// P2100: Added keyboard navigation (arrow keys, escape)
templ ActionDropdown(host Host) {
	<div class="dropdown" x-data="{
		open: false,
		focusedIndex: -1,
		get items() { return [...this.$refs.menu.querySelectorAll('.dropdown-item:not([disabled])')]; },
		focusItem(idx) {
			const items = this.items;
			if (items.length === 0) return;
			this.focusedIndex = ((idx % items.length) + items.length) % items.length;
			items[this.focusedIndex].focus();
		},
		toggle() {
			this.open = !this.open;
			if (this.open) {
				this.$nextTick(() => this.focusItem(0));
			} else {
				this.focusedIndex = -1;
			}
		}
	}">
		<button
			type="button"
			class="dropdown-toggle"
			@click="toggle()"
			@click.outside="open = false; focusedIndex = -1"
			@keydown.arrow-down.prevent="if (!open) { toggle() } else { focusItem(focusedIndex + 1) }"
			@keydown.escape.prevent="open = false; focusedIndex = -1"
			title="More actions"
		>
			<svg class="icon"><use href="#icon-more-vertical"></use></svg>
		</button>
		<div class="dropdown-menu" x-ref="menu" x-show="open" x-cloak
			@keydown.arrow-down.prevent="focusItem(focusedIndex + 1)"
			@keydown.arrow-up.prevent="focusItem(focusedIndex - 1)"
			@keydown.escape.prevent="open = false; focusedIndex = -1; $el.previousElementSibling.focus()"
			@keydown.tab="open = false; focusedIndex = -1"
			@click="open = false; focusedIndex = -1">
			<!-- P2500: Deployment Group -->
			<button
				type="button"
				class="dropdown-item"
				onclick={ sendCommandScript(host.ID, "pull") }
				disabled?={ !host.Online }
			>
				<svg class="icon"><use href="#icon-download"></use></svg>
				<span>Pull</span>
			</button>
			<button
				type="button"
				class="dropdown-item"
				onclick={ sendCommandScript(host.ID, "switch") }
				disabled?={ !host.Online }
			>
				<svg class="icon"><use href="#icon-refresh"></use></svg>
				<span>Switch</span>
			</button>
			<button
				type="button"
				class="dropdown-item"
				onclick={ sendCommandScript(host.ID, "test") }
				disabled?={ !host.Online }
			>
				<svg class="icon"><use href="#icon-flask"></use></svg>
				<span>Test</span>
			</button>
			if host.PendingCommand != "" {
				<button
					type="button"
					class="dropdown-item"
					onclick={ sendCommandScript(host.ID, "stop") }
				>
					<svg class="icon"><use href="#icon-stop"></use></svg>
					<span>Stop</span>
				</button>
			}
			<hr class="dropdown-divider"/>
			<!-- P2500: Management Group -->
			<button
				type="button"
				class="dropdown-item"
				onclick={ sendCommandScript(host.ID, "restart") }
				disabled?={ !host.Online }
			>
				<svg class="icon"><use href="#icon-refresh-cw"></use></svg>
				<span>Restart Agent</span>
			</button>
			<hr class="dropdown-divider"/>
			<!-- P2500: Utilities Group -->
			<button
				type="button"
				class="dropdown-item"
				onclick={ copyHostnameScript(host.Hostname) }
			>
				<svg class="icon"><use href="#icon-copy"></use></svg>
				<span>Copy Hostname</span>
			</button>
			<button
				type="button"
				class="dropdown-item"
				onclick={ copySSHScript(host) }
			>
				<svg class="icon"><use href="#icon-terminal"></use></svg>
				<span>SSH Command</span>
			</button>
			<hr class="dropdown-divider"/>
			<!-- P2500: Diagnostics Group -->
			<button
				type="button"
				class="dropdown-item"
				onclick={ downloadLogsScript(host.ID) }
			>
				<svg class="icon"><use href="#icon-file"></use></svg>
				<span>Download Logs</span>
			</button>
			<hr class="dropdown-divider"/>
			<!-- P2500: Danger Zone -->
			<button
				type="button"
				class="dropdown-item danger"
				onclick={ removeHostScript(host.ID, host.Hostname) }
			>
				<svg class="icon"><use href="#icon-trash"></use></svg>
				<span>Remove Host</span>
			</button>
		</div>
	</div>
}

// P1060: Script helpers for ActionDropdown
func sendCommandScript(hostID, command string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("sendCommand('%s', '%s')", hostID, command)}
}

func copyHostnameScript(hostname string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("copyToClipboard('%s', 'Hostname copied')", hostname)}
}

func copySSHScript(host Host) templ.ComponentScript {
	user := "mba"
	if host.HostType == "macos" {
		user = "markus"
	}
	sshCmd := fmt.Sprintf("ssh %s@%s", user, host.Hostname)
	return templ.ComponentScript{Call: fmt.Sprintf("copyToClipboard('%s', 'SSH command copied')", sshCmd)}
}

func downloadLogsScript(hostID string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("downloadLogs('%s')", hostID)}
}

func removeHostScript(hostID, hostname string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("confirmRemoveHost('%s', '%s')", hostID, hostname)}
}

// DeleteButton renders a delete button for offline hosts
templ DeleteButton(hostID string, enabled bool) {
	if enabled {
		<button 
			class="btn btn-danger"
			data-host-id={ hostID }
			onclick="deleteHost(this.dataset.hostId)"
			title="Delete offline host"
		>
			<svg class="icon"><use href="#icon-trash"></use></svg>
		</button>
	} else {
		<button class="btn btn-danger" disabled title="Cannot delete online host">
			<svg class="icon"><use href="#icon-trash"></use></svg>
		</button>
	}
}

// Helper functions
func statusClass(host Host) string {
	if host.PendingCommand != "" {
		return "status-running"
	}
	if host.Online {
		return "status-online"
	}
	return "status-offline"
}

func hostColorStyle(host Host) string {
	if host.ThemeColor != "" {
		return "color: " + host.ThemeColor
	}
	return ""
}

func valueOrDash(v string) string {
	if v == "" {
		return "—"
	}
	return v
}

// visibleWhen returns CSS display style based on condition
func visibleWhen(visible bool) string {
	if visible {
		return ""
	}
	return "display: none"
}

// P1030: Helper functions for Alpine.js selection bindings
func selectionClassBinding(hostID string) string {
	return fmt.Sprintf("{ 'selected': $store.selection.isSelected('%s') }", hostID)
}

func checkboxClickHandler(hostID string) string {
	return fmt.Sprintf("handleCheckboxClick($event, '%s')", hostID)
}

func rowSelectedClass(hostID string) string {
	return fmt.Sprintf("{ 'is-selected': $store.selection.isSelected('%s') }", hostID)
}

func iconVisibility(hostID string, checked bool) string {
	if checked {
		return fmt.Sprintf("$store.selection.isSelected('%s') ? '' : 'display: none'", hostID)
	}
	return fmt.Sprintf("$store.selection.isSelected('%s') ? 'display: none' : ''", hostID)
}

func formatPercent(v float64) string {
	return strconv.FormatFloat(v, 'f', 0, 64) + "%"
}

func formatLoad(v float64) string {
	return strconv.FormatFloat(v, 'f', 2, 64)
}

func metricsClass(metricType string, value float64) string {
	base := "metric " + metricType
	if value >= 80 {
		return base + " high"
	}
	return base
}

// updateCompartmentClass returns CSS classes for an update status compartment
// P5100: Simplified - only indicator dot shows status, compartment styling is constant
func updateCompartmentClass(status *UpdateStatus, compartment string) string {
	base := "update-compartment"
	if status == nil {
		return base + " unknown" // Slightly dimmed for stale/unknown data
	}
	
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	
	// Only add "unknown" class for dimming effect, all other states look the same
	if check.Status == "" || check.Status == "unknown" {
		return base + " unknown"
	}
	return base
}

// compartmentIndicatorClass returns CSS classes for the status indicator dot (P5010)
func compartmentIndicatorClass(status *UpdateStatus, compartment string) string {
	base := "compartment-indicator"
	if status == nil {
		return base + " compartment-indicator--unknown"
	}
	
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	
	switch check.Status {
	case "ok":
		return base + " compartment-indicator--ok"
	case "outdated":
		return base + " compartment-indicator--warning"
	case "error":
		return base + " compartment-indicator--error"
	default:
		return base + " compartment-indicator--unknown"
	}
}

// lockCompartmentClass returns CSS classes for Lock compartment
// P5100: Simplified - only indicator dot shows status (including agent outdated)
func lockCompartmentClass(host Host) string {
	base := "update-compartment"
	
	// Only add "unknown" class for dimming effect when no status data
	if host.UpdateStatus == nil {
		return base + " unknown"
	}
	
	if host.UpdateStatus.Lock.Status == "" || host.UpdateStatus.Lock.Status == "unknown" {
		return base + " unknown"
	}
	return base
}

// lockIndicatorClass returns CSS classes for Lock indicator dot (worst status wins)
func lockIndicatorClass(host Host) string {
	base := "compartment-indicator"
	
	// Agent outdated = error (red) - this is the worst status
	if host.AgentOutdated {
		return base + " compartment-indicator--error"
	}
	
	if host.UpdateStatus == nil {
		return base + " compartment-indicator--unknown"
	}
	
	switch host.UpdateStatus.Lock.Status {
	case "ok":
		return base + " compartment-indicator--ok"
	case "outdated":
		return base + " compartment-indicator--warning"
	case "error":
		return base + " compartment-indicator--error"
	default:
		return base + " compartment-indicator--unknown"
	}
}

// P1020: compartmentButtonClass returns CSS classes for clickable compartment button
func compartmentButtonClass(status *UpdateStatus, compartment string) string {
	base := "compartment-btn"
	if status == nil {
		return base + " unknown"
	}

	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "system":
		check = status.System
	}

	if check.Status == "" || check.Status == "unknown" {
		return base + " unknown"
	}
	return base
}

// P1020: lockCompartmentButtonClass returns CSS classes for Lock button
func lockCompartmentButtonClass(host Host) string {
	base := "compartment-btn"
	if host.UpdateStatus == nil {
		return base + " unknown"
	}
	if host.UpdateStatus.Lock.Status == "" || host.UpdateStatus.Lock.Status == "unknown" {
		return base + " unknown"
	}
	// Lock outdated is info-only (no action)
	if host.UpdateStatus.Lock.Status == "outdated" && !host.AgentOutdated {
		return base + " info-only"
	}
	return base
}

// P1020: getCompartmentStatus returns status string for data attribute
func getCompartmentStatus(status *UpdateStatus, compartment string) string {
	if status == nil {
		return "unknown"
	}
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	if check.Status == "" {
		return "unknown"
	}
	return check.Status
}

// P1020: getLockStatus returns status for Lock (considers agent outdated)
func getLockStatus(host Host) string {
	if host.AgentOutdated {
		return "error"
	}
	if host.UpdateStatus == nil {
		return "unknown"
	}
	return host.UpdateStatus.Lock.Status
}

// P1020: getCompartmentActionType returns action type for routing
func getCompartmentActionType(status *UpdateStatus, compartment string) string {
	if status == nil {
		return "refresh"
	}

	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
		switch check.Status {
		case "ok":
			return "refresh"
		case "outdated":
			return "pull"
		case "error":
			return "error"
		default:
			return "refresh"
		}
	case "system":
		check = status.System
		switch check.Status {
		case "ok":
			return "refresh"
		case "outdated":
			return "switch"
		case "error":
			return "error"
		default:
			return "refresh"
		}
	}
	return "refresh"
}

// P1020: getLockActionType returns action type for Lock compartment
func getLockActionType(host Host) string {
	if host.AgentOutdated {
		return "switch"
	}
	if host.UpdateStatus == nil {
		return "refresh"
	}
	switch host.UpdateStatus.Lock.Status {
	case "ok":
		return "refresh"
	case "outdated":
		return "info" // No action, just info
	case "error":
		return "error"
	default:
		return "refresh"
	}
}

// P2500: Context bar description functions
// These return concise, human-readable descriptions for the context bar

// gitContextDescription returns a short description for context bar
func gitContextDescription(host Host) string {
	status := host.UpdateStatus
	if status == nil {
		return "Checking git status..."
	}
	check := status.Git
	switch check.Status {
	case "ok":
		return "Code is up to date"
	case "outdated":
		if check.Message != "" {
			return check.Message
		}
		return "Code is behind — click to pull"
	case "error":
		if check.Message != "" {
			return check.Message
		}
		return "Git check failed"
	default:
		return "Checking git status..."
	}
}

// lockContextDescription returns a short description for context bar (flake.lock status)
func lockContextDescription(host Host) string {
	status := host.UpdateStatus
	if status == nil {
		return "Checking dependencies..."
	}
	check := status.Lock
	switch check.Status {
	case "ok":
		return fmt.Sprintf("Dependencies up to date (flake.lock synced)")
	case "outdated":
		if check.Message != "" {
			return check.Message
		}
		return "flake.lock outdated — merge PR to update dependencies"
	case "error":
		if check.Message != "" {
			return check.Message
		}
		return "Lock check failed"
	default:
		return "Checking dependencies..."
	}
}

// systemContextDescription returns a short description for context bar
func systemContextDescription(host Host) string {
	status := host.UpdateStatus
	isMac := host.HostType == "macos"
	if status == nil {
		if isMac {
			return "Checking Home Manager..."
		}
		return "Checking system..."
	}
	check := status.System
	switch check.Status {
	case "ok":
		if host.Generation != "" {
			return fmt.Sprintf("Configuration applied (gen %s)", host.Generation)
		}
		if isMac {
			return "Home Manager up to date"
		}
		return "System up to date"
	case "outdated":
		if check.Message != "" {
			return check.Message
		}
		if isMac {
			return "Home Manager changed — click to switch"
		}
		return "Config changed — click to switch"
	case "error":
		if check.Message != "" {
			return check.Message
		}
		return "System check failed"
	default:
		if isMac {
			return "Checking Home Manager..."
		}
		return "Checking system..."
	}
}

// formatStatus converts status codes to human-readable text
func formatStatus(status string) string {
	switch status {
	case "ok":
		return "✓ Up to date"
	case "outdated":
		return "⚠ Needs update"
	case "error":
		return "✗ Error"
	default:
		return "? Unknown"
	}
}

// formatTimestamp formats an ISO timestamp for display
func formatTimestamp(ts string) string {
	// Just return as-is for now; can be enhanced later
	if len(ts) > 19 {
		return ts[:19] // Trim to "2024-12-17T10:30:00"
	}
	return ts
}

// updateStatusJSON returns JSON for a compartment's status (P7000 hydration)
func updateStatusJSON(status *UpdateStatus, compartment string) string {
	if status == nil {
		return "null"
	}
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	data, err := json.Marshal(check)
	if err != nil {
		return "null"
	}
	return string(data)
}

// pendingPRJSON returns JSON for pending PR or "null" (P7000 hydration)
func pendingPRJSON(pr *PendingPR) string {
	if pr == nil {
		return "null"
	}
	data, err := json.Marshal(pr)
	if err != nil {
		return "null"
	}
	return string(data)
}

// ═══════════════════════════════════════════════════════════════════════════
// P2700: Composite TYPE and STATUS column helpers
// ═══════════════════════════════════════════════════════════════════════════

// compositeTypeTitle returns tooltip text for the composite type cell
func compositeTypeTitle(host Host) string {
	loc := host.Location
	if loc == "" {
		loc = "home"
	}
	dev := host.DeviceType
	if dev == "" {
		dev = "desktop"
	}
	os := host.HostType
	if os == "" {
		os = "nixos"
	}
	return fmt.Sprintf("%s: %s %s running %s", host.Hostname, capitalizeWord(loc), dev, os)
}

// capitalizeWord capitalizes the first letter of a word
func capitalizeWord(s string) string {
	if s == "" {
		return s
	}
	if s[0] >= 'a' && s[0] <= 'z' {
		return string(s[0]-32) + s[1:]
	}
	return s
}

// getPhaseProgress extracts phase progress from OperationProgress
func getPhaseProgress(op *OperationProgress, phase string) *PhaseProgress {
	if op == nil {
		return nil
	}
	switch phase {
	case "pull":
		return op.Pull
	case "lock":
		return op.Lock
	case "system":
		return op.System
	default:
		return nil
	}
}

// progressDotClass returns CSS class for a progress dot
func progressDotClass(p *PhaseProgress, step int) string {
	base := "progress-dot"
	if p == nil {
		// Idle state: show as 90% transparent green (completed)
		return base + " dot-idle"
	}
	
	switch p.Status {
	case "complete":
		return base + " dot-complete"
	case "error":
		if step < p.Current {
			return base + " dot-complete"
		}
		return base + " dot-error"
	case "in_progress":
		if step < p.Current {
			return base + " dot-complete"
		}
		if step == p.Current {
			return base + " dot-in-progress"
		}
		return base + " dot-pending"
	default: // pending
		return base + " dot-pending"
	}
}

// progressDotChar returns the character for a progress dot
func progressDotChar(p *PhaseProgress, step int) string {
	if p == nil {
		return "●" // Idle: completed
	}
	
	switch p.Status {
	case "complete":
		return "●"
	case "error":
		if step < p.Current {
			return "●"
		}
		return "✗"
	case "in_progress":
		if step < p.Current {
			return "●"
		}
		if step == p.Current {
			return "◐"
		}
		return "○"
	default:
		return "○"
	}
}

// testDotClass returns CSS class for a test result dot
func testDotClass(tp *TestProgress, idx int) string {
	base := "progress-dot test-dot"
	if tp == nil {
		return base + " dot-pending"
	}
	
	if tp.Running {
		if idx < tp.Current-1 {
			// Already ran
			if idx < tp.Passed {
				return base + " dot-complete"
			}
			return base + " dot-error"
		}
		if idx == tp.Current-1 {
			return base + " dot-in-progress"
		}
		return base + " dot-pending"
	}
	
	// Completed: show results
	if idx < tp.Passed {
		return base + " dot-complete"
	}
	if idx < tp.Total {
		return base + " dot-error"
	}
	return base + " dot-pending"
}

// testDotChar returns character for a test result dot
func testDotChar(tp *TestProgress, idx int) string {
	if tp == nil {
		return "○"
	}
	
	if tp.Running {
		if idx < tp.Current-1 {
			if idx < tp.Passed {
				return "●"
			}
			return "✗"
		}
		if idx == tp.Current-1 {
			return "◐"
		}
		return "○"
	}
	
	if idx < tp.Passed {
		return "●"
	}
	if idx < tp.Total {
		return "✗"
	}
	return "○"
}

// operationTestDotClass returns CSS class for operation test dots
func operationTestDotClass(tp *TestsProgress, idx int) string {
	base := "progress-dot test-dot"
	if tp == nil || idx >= len(tp.Results) {
		return base + " dot-pending"
	}
	
	switch tp.Results[idx] {
	case "pass":
		return base + " dot-complete"
	case "fail":
		return base + " dot-error"
	default:
		if tp.Status == "in_progress" && idx == tp.Current {
			return base + " dot-in-progress"
		}
		return base + " dot-pending"
	}
}

// operationTestDotChar returns character for operation test dots
func operationTestDotChar(tp *TestsProgress, idx int) string {
	if tp == nil || idx >= len(tp.Results) {
		return "○"
	}
	
	switch tp.Results[idx] {
	case "pass":
		return "●"
	case "fail":
		return "✗"
	default:
		if tp.Status == "in_progress" && idx == tp.Current {
			return "◐"
		}
		return "○"
	}
}

// minInt returns the minimum of two integers
func minInt(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// updateCompartmentTitle returns the tooltip for an update status compartment (legacy, kept for JS)
func updateCompartmentTitle(status *UpdateStatus, compartment string, hostType string) string {
	if status == nil {
		switch compartment {
		case "git":
			return "Git: Checking..."
		case "lock":
			return "Lock: Checking..."
		case "system":
			if hostType == "macos" {
				return "Home Manager: Checking..."
			}
			return "System: Checking..."
		}
		return "Checking..."
	}
	
	var check StatusCheck
	var label string
	switch compartment {
	case "git":
		check = status.Git
		label = "Git"
	case "lock":
		check = status.Lock
		label = "Lock"
	case "system":
		check = status.System
		if hostType == "macos" {
			label = "Home Manager"
		} else {
			label = "System"
		}
	}
	
	if check.Message != "" {
		return label + ": " + check.Message
	}
	
	switch check.Status {
	case "ok":
		return label + ": Up to date"
	case "outdated":
		return label + ": Needs attention"
	case "error":
		return label + ": Error"
	default:
		return label + ": Unknown"
	}
}

