package templates

import (
	"fmt"
	"strconv"
)

// Host represents a host in the dashboard
type Host struct {
	ID             string
	Hostname       string
	HostType       string
	Status         string
	Online         bool
	AgentVersion   string
	OSVersion      string
	Generation     string
	LastSeen       string
	PendingCommand string
	ThemeColor     string
	Metrics        *Metrics
	Location       string        // home, work, cloud
	DeviceType     string        // server, desktop, laptop, gaming
	TestProgress   *TestProgress // current test progress, nil if not running
	UpdateStatus   *UpdateStatus // three-compartment status (Git/Lock/System)
	RepoURL        string        // git repo URL (isolated mode)
	RepoDir        string        // local repo path
	AgentOutdated  bool          // true if agent version doesn't match dashboard version
}

// UpdateStatus contains the three-compartment update status.
type UpdateStatus struct {
	Git     StatusCheck `json:"git"`
	Lock    StatusCheck `json:"lock"`
	System  StatusCheck `json:"system"`
	RepoURL string      `json:"repo_url"` // git repo URL (for Git tooltip)
	RepoDir string      `json:"repo_dir"` // local repo path (for Git tooltip)
}

// StatusCheck represents a single status check result.
type StatusCheck struct {
	Status    string `json:"status"`     // "ok", "outdated", "error", "unknown"
	Message   string `json:"message"`    // Human-readable detail
	CheckedAt string `json:"checked_at"` // ISO timestamp
}

// Metrics contains system metrics from StaSysMo
type Metrics struct {
	CPU  float64 `json:"cpu"`  // percentage 0-100
	RAM  float64 `json:"ram"`  // percentage 0-100
	Swap float64 `json:"swap"` // percentage 0-100
	Load float64 `json:"load"` // 1-minute load average
}

// TestProgress contains current test execution state
type TestProgress struct {
	Current int    `json:"current"` // current test number (1-based)
	Total   int    `json:"total"`   // total tests
	Passed  int    `json:"passed"`  // passed so far
	Running bool   `json:"running"` // true if still running
	Result  string `json:"result"`  // summary when done (e.g., "8/10")
}

// Stats represents dashboard statistics
type Stats struct {
	Online int
	Total  int
}

// FleetTarget represents the "gold standard" versions all hosts should match
type FleetTarget struct {
	GitCommit   string // Short git hash (e.g., "abc1234")
	GitFull     string // Full git hash for comparison
	Branch      string // e.g., "main"
	TimeAgo     string // e.g., "2h ago"
	Message     string // Commit message for tooltip
	RepoURL     string // For linking to GitHub
	AgentVer    string // Expected agent version (dashboard version)
	HasData     bool   // Whether we have version tracking data
}

// DashboardData contains all data needed to render the dashboard
type DashboardData struct {
	Hosts             []Host
	Stats             Stats
	CSRFToken         string
	Version           string
	HeartbeatInterval int // in seconds, for last-seen display
	FleetTarget       FleetTarget
}

// Dashboard renders the main dashboard page
templ Dashboard(data DashboardData) {
	@Base("NixFleet Dashboard", data.CSRFToken) {
		<!-- Config for JavaScript -->
		<div id="config" data-heartbeat-interval={ strconv.Itoa(data.HeartbeatInterval) } style="display:none;"></div>
		<header>
			<div class="brand">
				<h1>
					<img src="/static/nixfleet_favicon.png" alt="" class="brand-logo"/>
					NixFleet
				</h1>
				@FleetTargetLine(data.FleetTarget)
			</div>
			<div class="header-actions">
				<div class="dropdown bulk-actions-dropdown">
					<button class="btn btn-header" onclick="toggleBulkMenu(event)">
						<svg class="icon"><use href="#icon-fleet"></use></svg>
						Bulk Actions
					</button>
					<div class="dropdown-menu" id="bulk-actions-menu">
						<button class="dropdown-item" onclick="bulkCommand('update'); closeBulkMenu()">
							<svg class="icon"><use href="#icon-refresh"></use></svg>
							Update All
						</button>
						<button class="dropdown-item" onclick="bulkCommand('pull'); closeBulkMenu()">
							<svg class="icon"><use href="#icon-download"></use></svg>
							Pull All
						</button>
						<button class="dropdown-item" onclick="bulkCommand('switch'); closeBulkMenu()">
							<svg class="icon"><use href="#icon-refresh"></use></svg>
							Switch All
						</button>
						<button class="dropdown-item" onclick="bulkCommand('test'); closeBulkMenu()">
							<svg class="icon"><use href="#icon-flask"></use></svg>
							Test All
						</button>
					</div>
				</div>
				<form method="POST" action="/logout">
					<input type="hidden" name="csrf_token" value={ data.CSRFToken }/>
					<button type="submit" class="btn btn-danger btn-header">Logout</button>
				</form>
			</div>
		</header>

		<!-- Mobile: Card View -->
		<div class="host-grid" id="host-cards">
			for _, host := range data.Hosts {
				@HostCard(host, data.CSRFToken)
			}
		</div>

		<!-- Desktop: Table View -->
		<table class="host-table" id="host-table">
			<thead>
				<tr>
					<th class="col-hosts" title="Online / Total Hosts">
						<span class={ templ.KV("stat-online-positive", data.Stats.Online > 0) } id="stat-online">{ fmt.Sprint(data.Stats.Online) }</span>/{ fmt.Sprint(data.Stats.Total) } Hosts
					</th>
					<th class="col-center" title="Location">Loc</th>
					<th class="col-center" title="Device Type">Dev</th>
					<th class="col-center" title="Host Type">Type</th>
					<th>Metrics</th>
					<th title="Update Status (Git/Lock/System)">Update</th>
					<th class="col-center">Tests</th>
					<th class="col-right">Last Seen</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				for _, host := range data.Hosts {
					@HostRow(host, data.CSRFToken)
				}
			</tbody>
		</table>

		<!-- Log Viewer (global, shown when command is running) -->
		<div class="log-panel hidden" id="log-panel" x-data="logViewer()">
			<div class="log-header" @click="toggle()">
				<div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
					<span>
						Command Output
						<span x-show="hostId" x-text="'(' + hostId + ')'"></span>
					</span>
					<!-- Progress indicator -->
					<span x-show="phase" class="progress-badge" x-text="phaseIcon + ' ' + phase + (buildCount ? ' (' + buildCurrent + '/' + buildCount + ')' : '')"></span>
				</div>
				<span class="chevron" :class="{ 'expanded': open }">▼</span>
			</div>
			<div class="log-content" x-show="open" x-ref="logContent">
				<template x-for="line in lines" :key="line.id">
					<div class="log-line" :class="{ 'error': line.isError, 'success': line.isSuccess }" x-text="line.text"></div>
				</template>
			</div>
		</div>

		<!-- Remove Host Confirmation Modal (P4390) -->
		<div class="modal-overlay" id="removeHostModal">
			<div class="modal">
				<div class="modal-title">Remove Host</div>
				<div class="modal-body">
					Are you sure you want to remove <code id="removeHostName"></code>?
					<br/><br/>
					This will delete the host from the dashboard. The host can re-register when the agent reconnects.
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('removeHostModal')">Cancel</button>
					<button class="modal-btn modal-btn-danger" id="confirmRemoveBtn" onclick="doRemoveHost()">Remove</button>
				</div>
			</div>
		</div>

		<!-- Add Host Modal (P4390) -->
		<div class="modal-overlay" id="addHostModal">
			<div class="modal modal-wide">
				<div class="modal-title">Add Host</div>
				<div class="modal-body">
					<form id="addHostForm">
						<div class="form-group">
							<label>Hostname *</label>
							<input type="text" name="hostname" required pattern="[a-zA-Z][a-zA-Z0-9\-]{0,62}" placeholder="e.g., hsb1"/>
						</div>
						<div class="form-row">
							<div class="form-group">
								<label>OS Type</label>
								<select name="host_type">
									<option value="nixos">NixOS</option>
									<option value="macos">macOS</option>
								</select>
							</div>
							<div class="form-group">
								<label>Location</label>
								<select name="location">
									<option value="home">Home</option>
									<option value="work">Work</option>
									<option value="cloud">Cloud</option>
								</select>
							</div>
						</div>
						<div class="form-row">
							<div class="form-group">
								<label>Device Type</label>
								<select name="device_type">
									<option value="server">Server</option>
									<option value="desktop">Desktop</option>
									<option value="laptop">Laptop</option>
									<option value="gaming">Gaming</option>
								</select>
							</div>
							<div class="form-group">
								<label>Theme Color</label>
								<input type="color" name="theme_color" value="#7aa2f7"/>
							</div>
						</div>
					</form>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('addHostModal')">Cancel</button>
					<button class="modal-btn modal-btn-primary" onclick="doAddHost()">Add Host</button>
				</div>
			</div>
		</div>

		<footer class="site-footer">
			<div class="footer-left">
				<span class="connection-indicator" id="ws-status">
					<span class="status-dot status-offline"></span>
					Connecting...
				</span>
				<span class="footer-sep">•</span>
				<span>NixFleet { data.Version }</span>
				<a href="https://github.com/markus-barta/nixfleet" class="footer-link" target="_blank" rel="noopener">
					<svg class="icon"><use href="#icon-github"></use></svg>
					Source
				</a>
				<a href="https://www.gnu.org/licenses/agpl-3.0.html" class="footer-link" target="_blank" rel="noopener">
					<svg class="icon"><use href="#icon-license"></use></svg>
					AGPL-3.0
				</a>
			</div>
			<div class="footer-right">
				<span class="made-with">
					Made with <svg class="icon heart"><use href="#icon-heart"></use></svg> by
					<a href="https://x.com/markusbarta" target="_blank" rel="noopener">&#64;markusbarta</a>,
					Claude &amp; Cursor
				</span>
			</div>
		</footer>

		<!-- WebSocket and Alpine.js logic -->
		<script>
			// WebSocket connection
			let ws = null;
			let reconnectAttempts = 0;
			const maxReconnectDelay = 30000;

			function connectWebSocket() {
				const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
				ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

				ws.onopen = () => {
					console.log('WebSocket connected');
					reconnectAttempts = 0;
					updateConnectionStatus(true);
				};

				ws.onclose = () => {
					console.log('WebSocket disconnected');
					updateConnectionStatus(false);
					scheduleReconnect();
				};

				ws.onerror = (err) => {
					console.error('WebSocket error:', err);
				};

				ws.onmessage = (event) => {
					try {
						const msg = JSON.parse(event.data);
						handleMessage(msg);
					} catch (e) {
						console.error('Failed to parse message:', e);
					}
				};
			}

			function updateConnectionStatus(connected) {
				const el = document.getElementById('ws-status');
				if (connected) {
					el.className = 'connection-indicator connected';
					el.innerHTML = '<span class="status-dot status-online"></span> Connected';
				} else {
					el.className = 'connection-indicator disconnected';
					el.innerHTML = '<span class="status-dot status-offline"></span> Disconnected';
				}
			}

			function scheduleReconnect() {
				reconnectAttempts++;
				const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
				console.log(`Reconnecting in ${delay}ms...`);
				setTimeout(connectWebSocket, delay);
			}

			function handleMessage(msg) {
				switch (msg.type) {
					case 'host_update':
						updateHost(msg.payload);
						break;
					case 'command_output':
						appendLog(msg.payload);
						break;
					case 'command_queued':
						showLogPanel(msg.payload.host_id);
						break;
					case 'command_complete':
						markCommandComplete(msg.payload);
						break;
				}
			}

			function updateHost(host) {
				// Update table row
				const row = document.querySelector(`tr[data-host-id="${host.host_id}"]`);
				if (row) {
					updateStatusIndicator(row, host);
					row.classList.toggle('host-offline', !host.online);
					if (host.pending_command !== undefined) {
						row.dataset.pendingCommand = host.pending_command || '';
						applyButtonStates(row);
						updateProgressBadge(row, host.pending_command);
					}
					// Update data cells
					updateCellData(row, host);
				}

				// Update card
				const card = document.querySelector(`.host-card[data-host-id="${host.host_id}"]`);
				if (card) {
					updateStatusIndicator(card, host);
					card.classList.toggle('host-offline', !host.online);
					if (host.pending_command !== undefined) {
						card.dataset.pendingCommand = host.pending_command || '';
						applyButtonStates(card);
						updateProgressBadge(card, host.pending_command);
					}
				}
			}

			function updateCellData(row, host) {
				// Update generation
				if (host.generation !== undefined) {
					const genCell = row.querySelector('[data-cell="generation"]');
					if (genCell) genCell.textContent = host.generation || '—';
				}

				// Update last seen (format as relative time with color)
				if (host.last_seen !== undefined) {
					const lastSeenCell = row.querySelector('[data-cell="last-seen"]');
					if (lastSeenCell) {
						lastSeenCell.dataset.timestamp = host.last_seen;
						const result = formatLastSeen(host.last_seen);
						lastSeenCell.textContent = result.text;
						lastSeenCell.className = result.className;
					}
				}

				// Update metrics
				if (host.metrics) {
					const metricsCell = row.querySelector('[data-cell="metrics"]');
					if (metricsCell) {
						updateMetrics(metricsCell, host.metrics);
					}
				}
			}

			function updateMetrics(cell, metrics) {
				// Update CPU
				const cpuEl = cell.querySelector('[data-metric="cpu"]');
				if (cpuEl && metrics.cpu !== undefined) {
					const val = cpuEl.querySelector('.metric-val');
					if (val) val.textContent = Math.round(metrics.cpu) + '%';
					cpuEl.className = getMetricClass('cpu', metrics.cpu);
					cpuEl.title = 'CPU: ' + Math.round(metrics.cpu) + '%';
				}

				// Update RAM
				const ramEl = cell.querySelector('[data-metric="ram"]');
				if (ramEl && metrics.ram !== undefined) {
					const val = ramEl.querySelector('.metric-val');
					if (val) val.textContent = Math.round(metrics.ram) + '%';
					ramEl.className = getMetricClass('ram', metrics.ram);
					const swap = metrics.swap !== undefined ? Math.round(metrics.swap) : 0;
					const load = metrics.load !== undefined ? metrics.load.toFixed(2) : '0.00';
					ramEl.title = `RAM: ${Math.round(metrics.ram)}%, Swap: ${swap}%, Load: ${load}`;
				}

				// If metrics cell was showing "—", replace with proper structure
				const naSpan = cell.querySelector('.metrics-na');
				if (naSpan && (metrics.cpu !== undefined || metrics.ram !== undefined)) {
					cell.innerHTML = `
						<span class="${getMetricClass('cpu', metrics.cpu || 0)}" data-metric="cpu" title="CPU: ${Math.round(metrics.cpu || 0)}%">
							<svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">${Math.round(metrics.cpu || 0)}%</span>
						</span>
						<span class="${getMetricClass('ram', metrics.ram || 0)}" data-metric="ram" title="RAM: ${Math.round(metrics.ram || 0)}%">
							<svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">${Math.round(metrics.ram || 0)}%</span>
						</span>
					`;
				}
			}

			function getMetricClass(type, value) {
				let cls = 'metric';
				if (type === 'cpu' && value >= 80) cls += ' metric-high';
				if (type === 'ram' && value >= 80) cls += ' metric-high';
				return cls;
			}

			// Heartbeat interval in seconds (from server config)
			const HEARTBEAT_INTERVAL = parseInt(document.getElementById('config').dataset.heartbeatInterval) || 5;

			function formatLastSeen(isoString) {
				if (!isoString) return { text: '—', className: '' };
				
				const date = new Date(isoString);
				const now = new Date();
				const diffMs = now - date;
				// Clamp to 0 to handle clock skew (client ahead of server)
				const diffSec = Math.max(0, Math.floor(diffMs / 1000));
				
				// Format the time text
				let text;
				if (diffSec < 60) {
					text = diffSec + 's';
				} else if (diffSec < 3600) {
					text = Math.floor(diffSec / 60) + 'm';
				} else if (diffSec < 86400) {
					text = Math.floor(diffSec / 3600) + 'h';
				} else {
					text = Math.floor(diffSec / 86400) + 'd';
				}

				// Determine color class based on heartbeat interval
				let className;
				if (diffSec <= HEARTBEAT_INTERVAL * 2) {
					className = 'last-seen-ok';      // Within 2x heartbeat: gray
				} else if (diffSec <= HEARTBEAT_INTERVAL * 10) {
					className = 'last-seen-warn';    // Within 10x heartbeat: yellow
				} else {
					className = 'last-seen-stale';   // Beyond 10x heartbeat: red
				}

				return { text, className };
			}

			function updateProgressBadge(container, command) {
				// Find the wrapper element (for table rows: .status-wrapper, for cards: .status-with-badge)
				const wrapper = container.querySelector('.status-wrapper') || container.querySelector('.status-with-badge');
				if (!wrapper) return;
				
				let badge = wrapper.querySelector('.progress-badge-mini');
				if (command) {
					if (!badge) {
						badge = document.createElement('span');
						badge.className = 'progress-badge-mini';
						wrapper.appendChild(badge);
					}
					badge.textContent = command;
				} else if (badge) {
					badge.remove();
				}
			}

			function updateStatusIndicator(container, host) {
				// Find the wrapper or host-name (for mobile cards)
				const wrapper = container.querySelector('.status-wrapper') || container.querySelector('.status-with-badge');
				if (!wrapper) return;

				const existing = wrapper.querySelector('.status-ripple, .status-dot');

				if (host.online && !host.pending_command) {
					// Online idle - static green with heartbeat animation on update
					if (existing && existing.classList.contains('status-ripple')) {
						// Already a ripple - just trigger heartbeat animation
						triggerHeartbeat(existing);
					} else {
						// Create new ripple indicator
						const html = '<span class="status-ripple"><span class="hb-wave"></span><span class="hb-wave"></span><span class="hb-wave"></span><span class="hb-core"></span></span>';
						const wrapper = document.createElement('div');
						wrapper.innerHTML = html;
						const newEl = wrapper.firstChild;
						if (existing) {
							existing.replaceWith(newEl);
						}
						// Trigger heartbeat on new element
						triggerHeartbeat(newEl);
					}
				} else if (host.pending_command) {
					// Running - pulsing yellow
					const html = '<span class="status-dot status-running"></span>';
					if (existing) {
						const wrapper = document.createElement('div');
						wrapper.innerHTML = html;
						existing.replaceWith(wrapper.firstChild);
					}
				} else {
					// Offline - static red
					const html = '<span class="status-dot status-offline"></span>';
					if (existing) {
						const wrapper = document.createElement('div');
						wrapper.innerHTML = html;
						existing.replaceWith(wrapper.firstChild);
					}
				}
			}

			function triggerHeartbeat(rippleEl) {
				// Add heartbeat class to trigger animation
				rippleEl.classList.add('heartbeat');
				// Remove after animation completes (1.5s total)
				setTimeout(() => {
					rippleEl.classList.remove('heartbeat');
				}, 1500);
			}

			function appendLog(payload) {
				// Dispatch to Alpine component
				window.dispatchEvent(new CustomEvent('log-line', { detail: payload }));
			}

			function showLogPanel(hostId) {
				const panel = document.getElementById('log-panel');
				panel.classList.remove('hidden');
				window.dispatchEvent(new CustomEvent('log-start', { detail: { hostId } }));
			}

			function markCommandComplete(payload) {
				window.dispatchEvent(new CustomEvent('log-complete', { detail: payload }));
				// Clear busy state - command is done
				setHostBusy(payload.host_id, null);
			}

			// Send command to host
			function sendCommand(hostId, command) {
				// Immediate UI feedback - disable buttons
				setHostBusy(hostId, command);

				const csrfToken = document.body.dataset.csrfToken;
				fetch(`/api/hosts/${hostId}/command`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': csrfToken
					},
					body: JSON.stringify({ command })
				}).then(resp => {
					if (!resp.ok) {
						return resp.text().then(text => { throw new Error(text); });
					}
					return resp.json();
				}).then(data => {
					console.log('Command queued:', data);
					// WebSocket will update state when command completes
				}).catch(err => {
					console.error('Command failed:', err);
					alert('Command failed: ' + err.message);
					// On error, re-enable buttons
					setHostBusy(hostId, null);
				});
			}

			function setHostBusy(hostId, command) {
				// Update table row
				const row = document.querySelector(`tr[data-host-id="${hostId}"]`);
				if (row) {
					row.dataset.pendingCommand = command || '';
					applyButtonStates(row);
				}

				// Update card
				const card = document.querySelector(`.host-card[data-host-id="${hostId}"]`);
				if (card) {
					card.dataset.pendingCommand = command || '';
					applyButtonStates(card);
				}
			}

			function applyButtonStates(container) {
				const pending = container.dataset.pendingCommand;
				const hostId = container.dataset.hostId;
				const btns = container.querySelectorAll('button[data-command]');
				
				btns.forEach(btn => {
					const cmd = btn.dataset.command;
					
					if (cmd === 'test') {
						// Swap Test button with Stop button when command is running
						if (pending) {
							btn.dataset.command = 'stop';
							btn.onclick = function() { sendCommand(hostId, 'stop'); };
							btn.disabled = false; // Stop is always enabled
							btn.classList.add('btn-danger');
							btn.innerHTML = '<svg class="icon"><use href="#icon-stop"></use></svg>' + 
								(btn.textContent.includes('Test') ? ' Stop' : '');
						}
					} else if (cmd === 'stop') {
						// Swap Stop button back to Test when no command running
						if (!pending) {
							btn.dataset.command = 'test';
							btn.onclick = function() { sendCommand(hostId, 'test'); };
							btn.classList.remove('btn-danger');
							btn.innerHTML = '<svg class="icon"><use href="#icon-flask"></use></svg>' + 
								(btn.textContent.includes('Stop') ? ' Test' : '');
						}
						// Stop button always enabled
						btn.disabled = false;
					} else {
						// All other buttons disabled when pending
						btn.disabled = !!pending;
					}
				});

				// Update progress badge (mini version next to status dot)
				const wrapper = container.querySelector('.status-wrapper') || container.querySelector('.status-with-badge');
				if (!wrapper) return;
				
				let badge = wrapper.querySelector('.progress-badge-mini');
				if (pending) {
					if (!badge) {
						badge = document.createElement('span');
						badge.className = 'progress-badge-mini';
						wrapper.appendChild(badge);
					}
					badge.textContent = pending;
				} else if (badge) {
					badge.remove();
				}
			}

			// Delete host
			function deleteHost(hostId) {
				if (!confirm(`Delete host "${hostId}"? This cannot be undone.`)) {
					return;
				}
				const csrfToken = document.body.dataset.csrfToken;
				fetch(`/api/hosts/${hostId}`, {
					method: 'DELETE',
					headers: {
						'X-CSRF-Token': csrfToken
					}
				}).then(resp => {
					if (!resp.ok) {
						return resp.text().then(text => { throw new Error(text); });
					}
					return resp.json();
				}).then(data => {
					console.log('Host deleted:', data);
					// Remove host from DOM
					document.querySelectorAll(`[data-host-id="${hostId}"]`).forEach(el => el.remove());
				}).catch(err => {
					console.error('Delete failed:', err);
					alert('Delete failed: ' + err.message);
				});
			}

			// Alpine.js log viewer component
			document.addEventListener('alpine:init', () => {
				Alpine.data('logViewer', () => ({
					open: true,
					lines: [],
					hostId: '',
					lineCounter: 0,
					// Progress tracking
					phase: '',
					phaseIcon: '',
					buildCount: 0,
					buildCurrent: 0,

					init() {
						window.addEventListener('log-line', (e) => {
							this.addLine(e.detail);
						});
						window.addEventListener('log-start', (e) => {
							this.hostId = e.detail.hostId;
							this.lines = [];
							this.open = true;
							this.resetProgress();
						});
						window.addEventListener('log-complete', (e) => {
							this.phase = e.detail.exit_code === 0 ? 'Complete' : 'Failed';
							this.phaseIcon = e.detail.exit_code === 0 ? '✓' : '✗';
							this.addLine({
								line: `\n${this.phaseIcon} Command completed (exit code: ${e.detail.exit_code || 0})`,
								isSuccess: e.detail.exit_code === 0
							});
						});
					},

					resetProgress() {
						this.phase = '';
						this.phaseIcon = '';
						this.buildCount = 0;
						this.buildCurrent = 0;
					},

					parseProgress(line) {
						// NixOS rebuild phases
						if (line.includes('evaluating derivation')) {
							this.phase = 'Evaluation';
							this.phaseIcon = '→';
						} else if (line.includes('these derivations will be built')) {
							// Extract count: "these 42 derivations will be built"
							const match = line.match(/these (\d+) derivations/);
							if (match) this.buildCount = parseInt(match[1], 10);
							this.phase = 'Building';
							this.phaseIcon = '●';
						} else if (line.includes("building '/nix/store/")) {
							this.buildCurrent++;
							this.phase = 'Building';
							this.phaseIcon = '●';
						} else if (line.includes('activating the configuration')) {
							this.phase = 'Activation';
							this.phaseIcon = '▶';
						} else if (line.includes('switching to configuration')) {
							this.phase = 'Switch';
							this.phaseIcon = '→';
						} else if (line.includes('setting up /etc')) {
							this.phase = 'Setup';
							this.phaseIcon = '○';
						} else if (line.includes('will be fetched')) {
							this.phase = 'Fetching';
							this.phaseIcon = '↓';
						}
					},

					toggle() {
						this.open = !this.open;
					},

					addLine(payload) {
						const text = payload.line;
						this.parseProgress(text);
						this.lines.push({
							id: ++this.lineCounter,
							text: text,
							isError: payload.is_error || payload.stream === 'stderr',
							isSuccess: payload.isSuccess || false
						});
						// Auto-scroll
						this.$nextTick(() => {
							const el = this.$refs.logContent;
							if (el) el.scrollTop = el.scrollHeight;
						});
					}
				}));
			});

			// Format all last-seen cells on page load
			function initLastSeenCells() {
				document.querySelectorAll('[data-cell="last-seen"]').forEach(cell => {
					const timestamp = cell.dataset.timestamp;
					if (timestamp) {
						const result = formatLastSeen(timestamp);
						cell.textContent = result.text;
						cell.className = result.className;
					}
				});
			}

			// Update last-seen cells every second for smooth counting
			function startLastSeenUpdater() {
				setInterval(() => {
					document.querySelectorAll('[data-cell="last-seen"]').forEach(cell => {
						const timestamp = cell.dataset.timestamp;
						if (timestamp) {
							const result = formatLastSeen(timestamp);
							cell.textContent = result.text;
							cell.className = result.className;
						}
					});
				}, 1000);
			}

			// ===== Dropdown Menu (P4380) =====
			function toggleDropdown(btn) {
				const dropdown = btn.closest('.dropdown');
				const wasOpen = dropdown.classList.contains('open');
				
				// Close all dropdowns first
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				
				// Toggle this one
				if (!wasOpen) {
					dropdown.classList.add('open');
				}
			}

			// Close dropdowns when clicking outside
			document.addEventListener('click', (e) => {
				if (!e.target.closest('.dropdown')) {
					document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				}
			});

			// Close dropdowns on Escape key
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') {
					document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
					document.querySelectorAll('.modal-overlay.open').forEach(m => m.classList.remove('open'));
					closeBulkMenu();
				}
			});

			// ===== Bulk Actions Menu =====
			function toggleBulkMenu(e) {
				e.stopPropagation();
				const menu = document.getElementById('bulk-actions-menu');
				menu.classList.toggle('open');
			}

			function closeBulkMenu() {
				const menu = document.getElementById('bulk-actions-menu');
				if (menu) menu.classList.remove('open');
			}

			// Close bulk menu when clicking outside
			document.addEventListener('click', (e) => {
				if (!e.target.closest('.bulk-actions-dropdown')) {
					closeBulkMenu();
				}
			});

			function unlockActions(btn) {
				const hostId = btn.dataset.hostId;
				setHostBusy(hostId, null);
				// Close dropdown
				btn.closest('.dropdown').classList.remove('open');
			}

			function downloadLogs(hostId) {
				window.open(`/api/hosts/${hostId}/logs?download=true`, '_blank');
			}

			// ===== Modal Functions (P4390) =====
			let pendingRemoveHostId = null;

			function confirmRemoveHost(hostId, hostname) {
				pendingRemoveHostId = hostId;
				document.getElementById('removeHostName').textContent = hostname;
				document.getElementById('removeHostModal').classList.add('open');
				// Close dropdown
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
			}

			function doRemoveHost() {
				if (!pendingRemoveHostId) return;
				
				const csrfToken = document.body.dataset.csrfToken;
				fetch(`/api/hosts/${pendingRemoveHostId}`, {
					method: 'DELETE',
					headers: { 'X-CSRF-Token': csrfToken }
				}).then(resp => {
					if (!resp.ok) throw new Error('Failed to remove host');
					return resp.json();
				}).then(() => {
					document.querySelectorAll(`[data-host-id="${pendingRemoveHostId}"]`).forEach(el => el.remove());
					closeModal('removeHostModal');
				}).catch(err => {
					alert('Failed to remove host: ' + err.message);
				});
			}

			function closeModal(modalId) {
				document.getElementById(modalId).classList.remove('open');
				pendingRemoveHostId = null;
			}

			function openAddHostModal() {
				document.getElementById('addHostModal').classList.add('open');
			}

			function doAddHost() {
				const form = document.getElementById('addHostForm');
				const formData = new FormData(form);
				const data = Object.fromEntries(formData.entries());
				
				const csrfToken = document.body.dataset.csrfToken;
				fetch('/api/hosts', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': csrfToken
					},
					body: JSON.stringify(data)
				}).then(resp => {
					if (!resp.ok) throw new Error('Failed to add host');
					return resp.json();
				}).then(() => {
					closeModal('addHostModal');
					window.location.reload();
				}).catch(err => {
					alert('Failed to add host: ' + err.message);
				});
			}

			// Close modal on overlay click
			document.querySelectorAll('.modal-overlay').forEach(overlay => {
				overlay.addEventListener('click', (e) => {
					if (e.target === overlay) {
						overlay.classList.remove('open');
					}
				});
			});

			// ===== Bulk Actions (P5000) =====
			function bulkCommand(command) {
				const onlineHosts = document.querySelectorAll('tr[data-host-id]:not(.host-offline)');
				if (onlineHosts.length === 0) {
					alert('No online hosts to send command to');
					return;
				}

				const confirmMsg = `Send "${command}" to ${onlineHosts.length} online host(s)?`;
				if (!confirm(confirmMsg)) return;

				onlineHosts.forEach(row => {
					const hostId = row.dataset.hostId;
					if (command === 'update') {
						// Update = pull then switch (sequential via promise chain would be complex, just do both)
						sendCommand(hostId, 'pull');
						// Note: In a real implementation, you'd wait for pull to complete before switch
					} else {
						sendCommand(hostId, command);
					}
				});
			}

			// ===== Update Status Refresh (P5000) =====
			function refreshStatus(compartment, statusType) {
				const hostId = compartment.closest('.update-status').dataset.hostId;
				console.log(`Refreshing ${statusType} status for ${hostId}`);
				// TODO: Implement API call to refresh specific status check
				// For now, just show visual feedback
				compartment.classList.add('unknown');
				setTimeout(() => {
					compartment.classList.remove('unknown');
				}, 2000);
			}

			// Initialize page
			initLastSeenCells();
			startLastSeenUpdater();
			connectWebSocket();
		</script>
	}
}

// FleetTargetLine renders the fleet target info in the header
templ FleetTargetLine(target FleetTarget) {
	<div class="fleet-target">
		if target.HasData {
			<span class="target-label">Target:</span>
			<svg class="target-icon"><use href="#icon-git-branch"></use></svg>
			<a
				href={ templ.SafeURL("https://github.com/" + target.RepoURL + "/commit/" + target.GitFull) }
				target="_blank"
				rel="noopener"
				class="target-commit"
				title={ "Latest commit: " + target.Message }
			>
				{ target.GitCommit }
			</a>
			<span class="target-branch">({ target.Branch }, { target.TimeAgo })</span>
			<span class="target-separator">•</span>
			<span class="target-agent" title={ "Expected agent version: " + target.AgentVer }>{ target.AgentVer }</span>
		} else {
			<span class="target-label">Target:</span>
			<span class="target-unavailable">Version tracking not configured</span>
		}
	</div>
}

// HostCard renders a host as a card (mobile view)
templ HostCard(host Host, csrfToken string) {
	<div class={ "host-card", templ.KV("host-offline", !host.Online) } data-host-id={ host.ID } x-data="{ expanded: false }">
		<div class="host-card-header" @click="expanded = !expanded">
			<div class="host-name">
				<span class="status-with-badge">
					@StatusIndicator(host)
					if host.PendingCommand != "" {
						<span class="progress-badge-mini">{ host.PendingCommand }</span>
					}
				</span>
				<span style={ hostColorStyle(host) }>{ host.Hostname }</span>
			</div>
			<span class="chevron" :class="{ 'expanded': expanded }">▼</span>
		</div>
		<div class="host-card-body" x-show="expanded" x-collapse>
			<div class="host-card-row">
				<span class="host-card-label">Type</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@osTypeIcon(host.HostType)
					{ host.HostType }
				</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Location</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@locationIcon(host.Location)
					{ host.Location }
				</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Device</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@deviceTypeIcon(host.DeviceType)
					{ host.DeviceType }
				</span>
			</div>
			if host.Metrics != nil {
				<div class="host-card-row">
					<span class="host-card-label">Metrics</span>
					<span class="metrics-cell">
						<span class={ metricsClass("cpu", host.Metrics.CPU) }><svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.CPU) }</span></span>
						<span class={ metricsClass("ram", host.Metrics.RAM) }><svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.RAM) }</span></span>
						<span class="metric"><span class="metric-val">{ formatLoad(host.Metrics.Load) }</span></span>
					</span>
				</div>
			}
			if host.TestProgress != nil {
				<div class="host-card-row">
					<span class="host-card-label">Tests</span>
					@TestsCell(host.TestProgress)
				</div>
			}
			<div class="host-card-row">
				<span class="host-card-label">OS Version</span>
				<span>{ valueOrDash(host.OSVersion) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Generation</span>
				<span>{ valueOrDash(host.Generation) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Agent</span>
				<span>{ valueOrDash(host.AgentVersion) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Last Seen</span>
				<span data-cell="last-seen" data-timestamp={ host.LastSeen }>{ valueOrDash(host.LastSeen) }</span>
			</div>
			<div class="host-card-actions">
				@CommandButton(host.ID, "pull", "Pull", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "switch", "Switch", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "test", "Test", "btn", host.Online && host.PendingCommand == "")
				@DeleteButton(host.ID, !host.Online)
			</div>
		</div>
	</div>
}

// HostRow renders a host as a table row (desktop view)
templ HostRow(host Host, csrfToken string) {
	<tr data-host-id={ host.ID } class={ templ.KV("host-offline", !host.Online) }>
		<td class="status-cell-with-badge">
			<span class="status-wrapper">
				@StatusIndicator(host)
				<span style={ hostColorStyle(host) }>{ host.Hostname }</span>
				if host.PendingCommand != "" {
					<span class="progress-badge-mini">{ host.PendingCommand }</span>
				}
			</span>
		</td>
		<td class="col-center" title={ host.Location }>@locationIcon(host.Location)</td>
		<td class="col-center" title={ host.DeviceType }>@deviceTypeIcon(host.DeviceType)</td>
		<td class="col-center">@osTypeIcon(host.HostType)</td>
		<td class="metrics-cell" data-cell="metrics">
			if host.Metrics != nil {
				<span class={ metricsClass("cpu", host.Metrics.CPU) } data-metric="cpu" title={ "CPU: " + formatPercent(host.Metrics.CPU) }>
					<svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.CPU) }</span>
				</span>
				<span class={ metricsClass("ram", host.Metrics.RAM) } data-metric="ram" title={ "RAM: " + formatPercent(host.Metrics.RAM) + ", Swap: " + formatPercent(host.Metrics.Swap) + ", Load: " + formatLoad(host.Metrics.Load) }>
					<svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.RAM) }</span>
				</span>
			} else {
				<span class="metrics-na">—</span>
			}
		</td>
		<td class="update-cell" data-cell="update">
			@UpdateStatusCell(host)
		</td>
		<td class="tests-cell col-center" data-cell="tests">
			@TestsCell(host.TestProgress)
		</td>
		<td class="col-right" data-cell="last-seen" data-timestamp={ host.LastSeen }>{ valueOrDash(host.LastSeen) }</td>
		<td class="actions-cell">
			<div class="action-buttons">
				@CommandButton(host.ID, "pull", "", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "switch", "", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "test", "", "btn", host.Online && host.PendingCommand == "")
				@ActionDropdown(host)
			</div>
		</td>
	</tr>
}

// StatusIndicator renders the appropriate status indicator (ripple for online, dot for offline)
templ StatusIndicator(host Host) {
	if host.Online && host.PendingCommand == "" {
		<span class="status-ripple">
			<span class="hb-wave"></span>
			<span class="hb-wave"></span>
			<span class="hb-wave"></span>
			<span class="hb-core"></span>
		</span>
	} else if host.PendingCommand != "" {
		<span class="status-dot status-running"></span>
	} else {
		<span class="status-dot status-offline"></span>
	}
}

// CommandButton renders a command button with proper onclick handling and SVG icon
templ CommandButton(hostID, command, label, classes string, enabled bool) {
	if enabled {
		<button 
			class={ classes }
			data-host-id={ hostID }
			data-command={ command }
			onclick="sendCommand(this.dataset.hostId, this.dataset.command)"
		>
			@commandIcon(command)
			if label != "" {
				{ label }
			}
		</button>
	} else {
		<button class={ classes } disabled>
			@commandIcon(command)
			if label != "" {
				{ label }
			}
		</button>
	}
}

// commandIcon renders the SVG icon for a command
templ commandIcon(command string) {
	switch command {
		case "pull":
			<svg class="icon"><use href="#icon-download"></use></svg>
		case "switch":
			<svg class="icon"><use href="#icon-refresh"></use></svg>
		case "test":
			<svg class="icon"><use href="#icon-flask"></use></svg>
		case "stop":
			<svg class="icon"><use href="#icon-stop"></use></svg>
		default:
			// No icon for unknown commands
	}
}

// osTypeIcon renders the OS type icon (NixOS or macOS)
templ osTypeIcon(hostType string) {
	switch hostType {
		case "nixos":
			<svg class="icon type-icon" title="NixOS"><use href="#icon-nixos"></use></svg>
		case "macos":
			<svg class="icon type-icon" title="macOS"><use href="#icon-apple"></use></svg>
		default:
			<span>{ hostType }</span>
	}
}

// locationIcon renders the location icon
templ locationIcon(location string) {
	switch location {
		case "home":
			<svg class="icon location-icon" title="Home"><use href="#icon-home"></use></svg>
		case "work":
			<svg class="icon location-icon" title="Work"><use href="#icon-office"></use></svg>
		case "cloud":
			<svg class="icon location-icon" title="Cloud"><use href="#icon-cloud"></use></svg>
		default:
			<svg class="icon location-icon" title="Home"><use href="#icon-home"></use></svg>
	}
}

// deviceTypeIcon renders the device type icon
templ deviceTypeIcon(deviceType string) {
	switch deviceType {
		case "server":
			<svg class="icon device-icon" title="Server"><use href="#icon-server"></use></svg>
		case "desktop":
			<svg class="icon device-icon" title="Desktop"><use href="#icon-desktop"></use></svg>
		case "laptop":
			<svg class="icon device-icon" title="Laptop"><use href="#icon-laptop"></use></svg>
		case "gaming":
			<svg class="icon device-icon" title="Gaming"><use href="#icon-game"></use></svg>
		default:
			<svg class="icon device-icon" title="Desktop"><use href="#icon-desktop"></use></svg>
	}
}

// TestsCell renders the test progress/results cell
templ TestsCell(progress *TestProgress) {
	if progress != nil {
		if progress.Running {
			<span class="test-progress">{ strconv.Itoa(progress.Current) }/{ strconv.Itoa(progress.Total) }</span>
		} else if progress.Result != "" {
			if progress.Passed == progress.Total {
				<span class="test-result pass">{ progress.Result }</span>
			} else {
				<span class="test-result fail">{ progress.Result }</span>
			}
		} else {
			<span class="tests-na">—</span>
		}
	} else {
		<span class="tests-na">—</span>
	}
}

// UpdateStatusCell renders the update status indicator (3 compartments + optional Agent)
templ UpdateStatusCell(host Host) {
	<div class="update-status" data-host-id={ host.ID }>
		<!-- Git compartment -->
		<span class={ updateCompartmentClass(host.UpdateStatus, "git") } title={ updateCompartmentTitle(host.UpdateStatus, "git", host.HostType) } onclick="refreshStatus(this, 'git')">
			<svg class="update-icon"><use href="#icon-git-branch"></use></svg>
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "git") }></span>
		</span>
		<!-- Lock compartment -->
		<span class={ updateCompartmentClass(host.UpdateStatus, "lock") } title={ updateCompartmentTitle(host.UpdateStatus, "lock", host.HostType) } onclick="refreshStatus(this, 'lock')">
			<svg class="update-icon"><use href="#icon-lock"></use></svg>
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "lock") }></span>
		</span>
		<!-- System compartment (NixOS snowflake or macOS home) -->
		<span class={ updateCompartmentClass(host.UpdateStatus, "system") } title={ updateCompartmentTitle(host.UpdateStatus, "system", host.HostType) } onclick="refreshStatus(this, 'system')">
			if host.HostType == "macos" {
				<svg class="update-icon"><use href="#icon-home"></use></svg>
			} else {
				<svg class="update-icon"><use href="#icon-nixos"></use></svg>
			}
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "system") }></span>
		</span>
		<!-- Agent compartment (only shown when outdated) -->
		if host.AgentOutdated {
			<span class="update-compartment agent-outdated" title={ "Agent version " + host.AgentVersion + " is outdated" }>
				<span class="agent-letter">A</span>
				<span class="compartment-indicator compartment-indicator--error"></span>
			</span>
		}
	</div>
}

// ActionDropdown renders the per-host action dropdown menu
templ ActionDropdown(host Host) {
	<div class="dropdown" data-host-id={ host.ID }>
		<button class="btn btn-more" onclick="toggleDropdown(this)" title="More actions">
			<svg class="icon"><use href="#icon-more"></use></svg>
		</button>
		<div class="dropdown-menu">
			<button class="dropdown-item" onclick="unlockActions(this)" data-host-id={ host.ID }>
				<svg class="icon"><use href="#icon-refresh"></use></svg>
				Unlock actions
			</button>
			if host.Online {
				<button class="dropdown-item" onclick="sendCommand(this.dataset.hostId, 'restart')" data-host-id={ host.ID }>
					<svg class="icon"><use href="#icon-refresh"></use></svg>
					Restart Agent
				</button>
			}
			<div class="dropdown-divider"></div>
			<button class="dropdown-item" onclick="downloadLogs(this.dataset.hostId)" data-host-id={ host.ID }>
				<svg class="icon"><use href="#icon-file"></use></svg>
				Download Logs
			</button>
			<div class="dropdown-divider"></div>
			<button class="dropdown-item danger" onclick="confirmRemoveHost(this.dataset.hostId, this.dataset.hostname)" data-host-id={ host.ID } data-hostname={ host.Hostname }>
				<svg class="icon"><use href="#icon-trash"></use></svg>
				Remove Host
			</button>
		</div>
	</div>
}

// DeleteButton renders a delete button for offline hosts
templ DeleteButton(hostID string, enabled bool) {
	if enabled {
		<button 
			class="btn btn-danger"
			data-host-id={ hostID }
			onclick="deleteHost(this.dataset.hostId)"
			title="Delete offline host"
		>
			<svg class="icon"><use href="#icon-trash"></use></svg>
		</button>
	} else {
		<button class="btn btn-danger" disabled title="Cannot delete online host">
			<svg class="icon"><use href="#icon-trash"></use></svg>
		</button>
	}
}

// Helper functions
func statusClass(host Host) string {
	if host.PendingCommand != "" {
		return "status-running"
	}
	if host.Online {
		return "status-online"
	}
	return "status-offline"
}

func hostColorStyle(host Host) string {
	if host.ThemeColor != "" {
		return "color: " + host.ThemeColor
	}
	return ""
}

func valueOrDash(v string) string {
	if v == "" {
		return "—"
	}
	return v
}

func formatPercent(v float64) string {
	return strconv.FormatFloat(v, 'f', 0, 64) + "%"
}

func formatLoad(v float64) string {
	return strconv.FormatFloat(v, 'f', 2, 64)
}

func metricsClass(metricType string, value float64) string {
	base := "metric " + metricType
	if value >= 80 {
		return base + " high"
	}
	return base
}

// updateCompartmentClass returns CSS classes for an update status compartment
func updateCompartmentClass(status *UpdateStatus, compartment string) string {
	base := "update-compartment"
	if status == nil {
		return base + " unknown"
	}
	
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	
	switch check.Status {
	case "ok":
		return base
	case "outdated":
		return base + " needs-update"
	case "error":
		return base + " error"
	default:
		return base + " unknown"
	}
}

// compartmentIndicatorClass returns CSS classes for the status indicator dot (P5010)
func compartmentIndicatorClass(status *UpdateStatus, compartment string) string {
	base := "compartment-indicator"
	if status == nil {
		return base + " compartment-indicator--unknown"
	}
	
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	
	switch check.Status {
	case "ok":
		return base + " compartment-indicator--ok"
	case "outdated":
		return base + " compartment-indicator--warning"
	case "error":
		return base + " compartment-indicator--error"
	default:
		return base + " compartment-indicator--unknown"
	}
}

// updateCompartmentTitle returns the tooltip for an update status compartment
func updateCompartmentTitle(status *UpdateStatus, compartment string, hostType string) string {
	if status == nil {
		switch compartment {
		case "git":
			return "Git: Checking..."
		case "lock":
			return "Lock: Checking..."
		case "system":
			if hostType == "macos" {
				return "Home Manager: Checking..."
			}
			return "System: Checking..."
		}
		return "Checking..."
	}
	
	var check StatusCheck
	var label string
	switch compartment {
	case "git":
		check = status.Git
		label = "Git"
		// Build Git-specific tooltip with repo info
		tooltip := label
		if check.Message != "" {
			tooltip += ": " + check.Message
		} else {
			switch check.Status {
			case "ok":
				tooltip += ": Up to date"
			case "outdated":
				tooltip += ": Needs attention"
			case "error":
				tooltip += ": Error"
			default:
				tooltip += ": Checking..."
			}
		}
		// Add repo paths
		if status.RepoURL != "" {
			tooltip += " | Remote: " + status.RepoURL
		}
		if status.RepoDir != "" {
			tooltip += " | Local: " + status.RepoDir
		}
		return tooltip
	case "lock":
		check = status.Lock
		label = "Lock"
	case "system":
		check = status.System
		if hostType == "macos" {
			label = "Home Manager"
		} else {
			label = "System"
		}
	}
	
	if check.Message != "" {
		return label + ": " + check.Message
	}
	
	switch check.Status {
	case "ok":
		return label + ": Up to date"
	case "outdated":
		return label + ": Needs attention"
	case "error":
		return label + ": Error"
	default:
		return label + ": Unknown"
	}
}

