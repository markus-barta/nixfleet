package templates

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
)

// Host represents a host in the dashboard
type Host struct {
	ID                   string
	Hostname             string
	HostType             string
	Status               string
	Online               bool
	AgentVersion         string
	ExpectedAgentVersion string             // Dashboard version for comparison
	OSVersion            string
	Generation           string
	LastSeen             string
	PendingCommand       string
	ThemeColor           string
	Metrics              *Metrics
	Location             string             // home, work, cloud
	DeviceType           string             // server, desktop, laptop, gaming
	TestProgress         *TestProgress      // current test progress, nil if not running
	UpdateStatus         *UpdateStatus      // three-compartment status (Git/Lock/System)
	RepoURL              string             // git repo URL (isolated mode)
	RepoDir              string             // local repo path
	AgentOutdated        bool               // true if agent version doesn't match dashboard version
	OperationProgress    *OperationProgress // P2700: detailed progress for STATUS column
	AvailableOps         []string           // P5100: Server-calculated available operations (thin frontend)
}

// UpdateStatus contains the three-compartment update status.
type UpdateStatus struct {
	Git     StatusCheck `json:"git"`
	Lock    StatusCheck `json:"lock"`
	System  StatusCheck `json:"system"`
	RepoURL string      `json:"repo_url"` // git repo URL (for Git tooltip)
	RepoDir string      `json:"repo_dir"` // local repo path (for Git tooltip)
}

// StatusCheck represents a single status check result.
type StatusCheck struct {
	Status    string `json:"status"`     // "ok", "outdated", "error", "unknown"
	Message   string `json:"message"`    // Human-readable detail
	CheckedAt string `json:"checked_at"` // ISO timestamp
}

// Metrics contains system metrics from StaSysMo
type Metrics struct {
	CPU  float64 `json:"cpu"`  // percentage 0-100
	RAM  float64 `json:"ram"`  // percentage 0-100
	Swap float64 `json:"swap"` // percentage 0-100
	Load float64 `json:"load"` // 1-minute load average
}

// TestProgress contains current test execution state
type TestProgress struct {
	Current int    `json:"current"` // current test number (1-based)
	Total   int    `json:"total"`   // total tests
	Passed  int    `json:"passed"`  // passed so far
	Running bool   `json:"running"` // true if still running
	Result  string `json:"result"`  // summary when done (e.g., "8/10")
}

// OperationProgress tracks detailed progress for STATUS column (P2700).
type OperationProgress struct {
	Pull   *PhaseProgress `json:"pull,omitempty"`
	Lock   *PhaseProgress `json:"lock,omitempty"`
	System *PhaseProgress `json:"system,omitempty"`
	Tests  *TestsProgress `json:"tests,omitempty"`
}

// PhaseProgress tracks progress within a single phase.
type PhaseProgress struct {
	Current int    `json:"current"` // current step (0-based)
	Total   int    `json:"total"`   // total steps
	Status  string `json:"status"`  // "pending", "in_progress", "complete", "error"
}

// TestsProgress tracks individual test results.
type TestsProgress struct {
	Current int      `json:"current"` // current test number (0-based)
	Total   int      `json:"total"`   // total tests (capped at 8 for display)
	Results []string `json:"results"` // "pending", "pass", "fail" per test
	Status  string   `json:"status"`  // "pending", "in_progress", "complete"
}

// Stats represents dashboard statistics
type Stats struct {
	Online int
	Total  int
}

// FleetTarget represents the "gold standard" versions all hosts should match
type FleetTarget struct {
	GitCommit   string // Short git hash (e.g., "abc1234")
	GitFull     string // Full git hash for comparison
	Branch      string // e.g., "main"
	TimeAgo     string // e.g., "2h ago"
	Message     string // Commit message for tooltip
	RepoURL     string // For linking to GitHub
	AgentVer    string // Expected agent version (dashboard version)
	HasData     bool   // Whether we have version tracking data
}

// PendingPR represents a pending flake.lock update PR (P5300).
type PendingPR struct {
	Number    int    `json:"number"`
	Title     string `json:"title"`
	URL       string `json:"url"`
	CreatedAt string `json:"created_at"`
	Mergeable bool   `json:"mergeable"`
}

// DashboardData contains all data needed to render the dashboard
type DashboardData struct {
	Hosts             []Host
	Stats             Stats
	CSRFToken         string
	Version           string
	DashboardVersion  string    // For agent version comparison
	HeartbeatInterval int       // in seconds, for last-seen display
	FleetTarget       FleetTarget
	PendingPR         *PendingPR // Pending flake update PR (P5300)
}

// Dashboard renders the main dashboard page
templ Dashboard(data DashboardData) {
	@Base("NixFleet Dashboard", data.CSRFToken) {
		<!-- Config for JavaScript - P7000: added pending PR data -->
		<div
			id="config"
			data-heartbeat-interval={ strconv.Itoa(data.HeartbeatInterval) }
			data-pending-pr={ pendingPRJSON(data.PendingPR) }
			style="display:none;"
		></div>
		<header>
			<div class="header-brand">
				<img src="/static/nixfleet_favicon.png" alt="" class="brand-logo"/>
				<span class="brand-title">NixFleet</span>
			</div>
			<div class="header-center">
				@FleetTargetLine(data.FleetTarget)
			</div>
			<div class="header-actions">
				<div class="dropdown bulk-actions-dropdown">
					<button class="btn btn-header" onclick="toggleBulkMenu(event)" onkeydown="if(event.key==='ArrowDown'){event.preventDefault();toggleBulkMenu(event);}">
						<svg class="icon"><use href="#icon-more-vertical"></use></svg>
						More
					</button>
				<div class="dropdown-menu" id="bulk-actions-menu" onkeydown="handleBulkMenuKeydown(event)">
					<!-- P7000: Merge & Deploy moved here from global banner -->
					if data.PendingPR != nil && data.PendingPR.Mergeable {
						<button class="dropdown-item" onclick={ templ.ComponentScript{Call: fmt.Sprintf("mergeAndDeploy(%d); closeBulkMenu()", data.PendingPR.Number)} }>
							<svg class="icon"><use href="#icon-check"></use></svg>
							Merge & Deploy PR #{ strconv.Itoa(data.PendingPR.Number) }
						</button>
						<div class="dropdown-divider"></div>
					}
					<!-- P2500: Reordered - Do All first, removed duplicate "Update All" -->
					<button class="dropdown-item" onclick="bulkDoAll(); closeBulkMenu()">
						<svg class="icon"><use href="#icon-play"></use></svg>
						Do All
					</button>
					<div class="dropdown-divider"></div>
					<button class="dropdown-item" onclick="bulkCommand('pull'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-download"></use></svg>
						Pull All
					</button>
					<button class="dropdown-item" onclick="bulkCommand('switch'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-refresh"></use></svg>
						Switch All
					</button>
					<button class="dropdown-item" onclick="bulkCommand('test'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-flask"></use></svg>
						Test All
					</button>
					<div class="dropdown-divider"></div>
					<button class="dropdown-item" onclick="bulkCommand('restart'); closeBulkMenu()">
						<svg class="icon"><use href="#icon-refresh-cw"></use></svg>
						Restart All Agents
					</button>
					<div class="dropdown-divider"></div>
					<button class="dropdown-item" onclick="forceRefresh()">
						<svg class="icon"><use href="#icon-trash"></use></svg>
						Clear Cache & Reload
					</button>
					<button class="dropdown-item" onclick="toggleDebugPanel()">
						<svg class="icon"><use href="#icon-terminal"></use></svg>
						Toggle Debug Panel
					</button>
				</div>
				</div>
				<form method="POST" action="/logout">
					<input type="hidden" name="csrf_token" value={ data.CSRFToken }/>
					<button type="submit" class="btn btn-danger btn-header">Logout</button>
				</form>
			</div>
		</header>

		<!-- P7000: Flake Update Banner removed - Merge & Deploy moved to Bulk Actions -->

		<!-- Mobile: Card View -->
		<div class="host-grid" id="host-cards">
			for _, host := range data.Hosts {
				@HostCard(host, data.CSRFToken)
			}
		</div>

		<!-- Desktop: Table View -->
		<!-- P7230: Reordered columns - checkbox first -->
		<table class="host-table" id="host-table" x-data>
			<thead>
				<tr>
					<!-- P7230: Selection checkbox column moved to first -->
					<th class="col-select">
						<button
							type="button"
							class="select-toggle"
							@click="handleHeaderCheckboxClick()"
							:title="$store.selection.headerState === 'all' ? 'Deselect all' : ($store.selection.headerState === 'some' ? 'Clear selection' : 'Select all')"
						>
							<svg class="icon" x-show="$store.selection.headerState === 'none'"><use href="#icon-square"></use></svg>
							<svg class="icon" x-show="$store.selection.headerState === 'some'"><use href="#icon-minus-square"></use></svg>
							<svg class="icon" x-show="$store.selection.headerState === 'all'"><use href="#icon-check-square"></use></svg>
						</button>
					</th>
					<th class="col-hosts" title="Online / Total Hosts">
						<span class={ templ.KV("stat-online-positive", data.Stats.Online > 0) } id="stat-online">{ fmt.Sprint(data.Stats.Online) }</span>/{ fmt.Sprint(data.Stats.Total) } Hosts
					</th>
					<th class="col-center col-type" title="Location / OS">Type</th>
					<th>Metrics</th>
					<th class="col-right col-last-seen">Last Seen</th>
					<th class="col-agent" title="Agent Version">Agent</th>
					<th title="Git/Lock/System Status">Status</th>
					<th class="col-menu"></th>
				</tr>
			</thead>
			<tbody>
				for _, host := range data.Hosts {
					@HostRow(host, data.CSRFToken)
				}
			</tbody>
		</table>

		<!-- Context Bar - unified hover preview + selection actions -->
		@ContextBar()

		<!-- P4020: Tabbed Output Panel (always visible) -->
		<div class="output-panel" id="output-panel" x-data="outputPanel()" @keydown.window="handleKeyboard($event)">
			<!-- Tab Bar -->
			<div class="output-tabs">
				<div class="tab-list">
					<!-- System Log Tab (always visible) -->
					<button
						type="button"
						class="output-tab"
						:class="{ 'active': activeTab === 'system' }"
						@click="switchTab('system')"
					>
						<span class="tab-indicator" :class="systemLogIndicator"></span>
						<span>ğŸ“‹ Log</span>
					</button>
					<!-- Host Tabs -->
					<template x-for="(tab, index) in tabs" :key="tab.hostId">
						<button
							type="button"
							class="output-tab"
							:class="{ 'active': activeTab === tab.hostId }"
							@click="switchTab(tab.hostId)"
						>
							<span class="tab-indicator" :class="tab.indicator"></span>
							<span x-text="tab.hostname"></span>
							<span class="tab-close" @click.stop="closeTab(tab.hostId)" title="Close">Ã—</span>
						</button>
					</template>
				</div>
				<!-- Hosts Dropdown: show all hosts, toggle tabs -->
				<div class="tab-overflow">
					<button 
						type="button" 
						class="tab-overflow-btn"
						@click="overflowOpen = !overflowOpen"
					>
						<span>Hosts</span>
						<span>â–¼</span>
					</button>
					<div class="tab-overflow-menu" x-show="overflowOpen" @click.away="overflowOpen = false">
						<template x-for="host in getAllHosts()" :key="'host-' + host.id">
							<button 
								type="button"
								class="tab-overflow-item"
								:class="{ 'active': hasTab(host.id) }"
								@click="toggleHostTab(host.id, host.hostname, host.themeColor)"
							>
								<span class="tab-indicator" :class="getHostTabIndicator(host.id)"></span>
								<span x-text="host.hostname" :style="{ color: host.themeColor }"></span>
								<span class="tab-toggle" x-text="hasTab(host.id) ? 'âœ“' : ''"></span>
							</button>
						</template>
					</div>
				</div>
				<!-- Panel Actions -->
				<div class="tab-actions">
					<button type="button" class="tab-action-btn" @click="closeAllTabs()" title="Close All Tabs" x-show="tabs.length > 0">
						Close All
					</button>
					<button type="button" class="tab-action-btn font-size-btn" @click="decreaseFontSize()" title="Decrease font size">
						Aâˆ’
					</button>
					<button type="button" class="tab-action-btn font-size-btn" @click="increaseFontSize()" title="Increase font size">
						A+
					</button>
					<button type="button" class="tab-action-btn" @click="toggleCollapse()" :title="collapsed ? 'Expand' : 'Collapse'">
						<span x-text="collapsed ? 'â–²' : 'â–¼'"></span>
					</button>
				</div>
			</div>

			<!-- Content Area -->
			<div class="output-content" x-show="!collapsed" x-ref="outputContent" :style="{ maxHeight: panelHeight + 'px' }">
				<!-- System Log Content -->
				<template x-if="activeTab === 'system'">
					<div>
						<template x-for="entry in systemLog" :key="entry.id">
							<div class="system-log-entry" :class="entry.category">
								<span class="log-icon" x-text="entry.icon"></span>
								<span class="log-time">
									<span x-text="entry.timeDisplay"></span>
									<span class="log-time-relative" x-text="'(' + entry.relativeTime + ')'"></span>
								</span>
								<span class="log-message" x-text="entry.message"></span>
							</div>
						</template>
						<div x-show="systemLog.length === 0" style="color: var(--fg-muted); text-align: center; padding: 1rem;">
							No system events yet
						</div>
					</div>
				</template>
				<!-- Host Output Content: Flat log per host - single div per line, no x-show -->
				<template x-for="tab in tabs" :key="tab.hostId">
					<div x-show="tab.hostId === activeTab">
						<template x-for="line in tab.lines" :key="line.id">
							<!-- Single div per line - use classes for styling -->
							<div 
								class="log-line"
								:class="{
									'command-separator': line.isSeparator === true,
									'status-line': line.isStatus === true,
									'host-output': line.isSeparator !== true && line.isStatus !== true,
									'error': line.isError === true,
									'success': line.isSuccess === true
								}"
								:style="line.isSeparator !== true && line.isStatus !== true ? { color: tab.themeColor } : {}"
							>
								<!-- Host output prefix icon (only for non-separator/status lines) -->
								<template x-if="line.isSeparator !== true && line.isStatus !== true">
									<svg class="log-line-icon" :style="{ color: tab.themeColor }">
										<use :href="'#icon-' + tab.deviceType"></use>
									</svg>
								</template>
								<span x-text="line.text"></span>
							</div>
						</template>
					</div>
				</template>
			</div>

			<!-- Footer with Clear/Copy -->
			<div class="output-footer" x-show="!collapsed">
				<!-- Progress indicator for active host tab -->
				<template x-for="tab in tabs.filter(t => t.hostId === activeTab && t.phase)" :key="'prog-' + tab.hostId">
					<span class="progress-badge" x-text="tab.phaseIcon + ' ' + tab.phase + (tab.buildCount ? ' (' + tab.buildCurrent + '/' + tab.buildCount + ')' : '')"></span>
				</template>
				<span style="flex: 1;"></span>
				<button type="button" class="tab-action-btn" @click="clearActiveTab()">Clear</button>
				<button type="button" class="tab-action-btn" @click="copyActiveTab()">Copy</button>
			</div>
			<!-- Resize Handle (bottom) -->
			<div 
				class="output-resize-handle" 
				:class="{ 'resizing': isResizing }"
				@mousedown="startResize($event)"
				x-show="!collapsed"
			>
				<span class="resize-grip">â‹®â‹®</span>
			</div>
		</div>

		<!-- P1040: Dependency Dialog -->
		@DependencyDialog()

		<!-- Remove Host Confirmation Modal (P4390) -->
		<div class="modal-overlay" id="removeHostModal">
			<div class="modal">
				<div class="modal-title">Remove Host</div>
				<div class="modal-body">
					Are you sure you want to remove <code id="removeHostName"></code>?
					<br/><br/>
					This will delete the host from the dashboard. The host can re-register when the agent reconnects.
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('removeHostModal')">Cancel</button>
					<button class="modal-btn modal-btn-danger" id="confirmRemoveBtn" onclick="doRemoveHost()">Remove</button>
				</div>
			</div>
		</div>

		<!-- P6900: Reboot Host Modal with TOTP -->
		<div class="modal-overlay" id="rebootModal">
			<div class="modal">
				<div class="modal-title">
					<svg class="modal-icon" style="width:24px;height:24px;margin-right:8px;color:var(--danger)">
						<use href="#icon-power"></use>
					</svg>
					Reboot Host
				</div>
				<div class="modal-body">
					<p class="reboot-warning">
						<strong>âš ï¸ Warning:</strong> This will immediately reboot <code id="rebootHostName"></code>.
						<br/>This action cannot be undone.
					</p>
					<div class="form-group" style="margin-top: 1.5rem;">
						<label for="rebootTotp" style="display: block; margin-bottom: 0.5rem;">
							Enter TOTP Code to confirm:
						</label>
						<input
							type="text"
							id="rebootTotp"
							class="form-control totp-input"
							autocomplete="one-time-code"
							inputmode="numeric"
							pattern="[0-9]*"
							maxlength="6"
							placeholder="000000"
							oninput="validateRebootTotp(this)"
							onkeydown="if(event.key==='Enter' && this.value.length===6) doReboot()"
							style="width: 100%; padding: 0.75rem; letter-spacing: 0.3em; text-align: center; font-size: 1.2rem; font-family: var(--font-mono);"
						/>
					</div>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeRebootModal()">Cancel</button>
					<button class="modal-btn modal-btn-danger" id="rebootConfirmBtn" onclick="doReboot()" disabled>
						<span id="rebootBtnText">Reboot</span>
						<span id="rebootBtnSpinner" style="display: none;">Sending...</span>
					</button>
				</div>
			</div>
		</div>

		<!-- Add Host Modal (P4390) -->
		<div class="modal-overlay" id="addHostModal">
			<div class="modal modal-wide">
				<div class="modal-title">Add Host</div>
				<div class="modal-body">
					<form id="addHostForm">
						<div class="form-group">
							<label>Hostname *</label>
							<input type="text" name="hostname" required pattern="[a-zA-Z][a-zA-Z0-9\-]{0,62}" placeholder="e.g., hsb1"/>
						</div>
						<div class="form-row">
							<div class="form-group">
								<label>OS Type</label>
								<select name="host_type">
									<option value="nixos">NixOS</option>
									<option value="macos">macOS</option>
								</select>
							</div>
							<div class="form-group">
								<label>Location</label>
								<select name="location">
									<option value="home">Home</option>
									<option value="work">Work</option>
									<option value="cloud">Cloud</option>
								</select>
							</div>
						</div>
						<div class="form-row">
							<div class="form-group">
								<label>Device Type</label>
								<select name="device_type">
									<option value="server">Server</option>
									<option value="desktop">Desktop</option>
									<option value="laptop">Laptop</option>
									<option value="gaming">Gaming</option>
								</select>
							</div>
							<div class="form-group">
								<label>Theme Color</label>
								<input type="color" name="theme_color" value="#7aa2f7"/>
							</div>
						</div>
					</form>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('addHostModal')">Cancel</button>
					<button class="modal-btn modal-btn-primary" onclick="doAddHost()">Add Host</button>
				</div>
			</div>
		</div>

		<!-- P2950: Color Picker Modal -->
		<div class="modal-overlay" id="colorPickerModal">
			<div class="modal modal-wide">
				<div class="modal-title">Change Theme Color</div>
				<div class="modal-body">
					<p class="color-picker-host">Host: <code id="colorPickerHostname"></code></p>
					
					<!-- Preset palettes -->
					<div class="form-group">
						<label>Presets</label>
						<div class="color-presets">
							<button type="button" class="color-preset" data-color="#98b8d8" data-palette="iceBlue" title="Ice Blue (cloud)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #98b8d8"></span>
							</button>
							<button type="button" class="color-preset" data-color="#769ff0" data-palette="blue" title="Blue (cloud)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #769ff0"></span>
							</button>
							<button type="button" class="color-preset" data-color="#d4c060" data-palette="yellow" title="Yellow (home)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #d4c060"></span>
							</button>
							<button type="button" class="color-preset" data-color="#68c878" data-palette="green" title="Green (home)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #68c878"></span>
							</button>
							<button type="button" class="color-preset" data-color="#e09050" data-palette="orange" title="Orange (home)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #e09050"></span>
							</button>
							<button type="button" class="color-preset" data-color="#9868d0" data-palette="purple" title="Purple (gaming)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #9868d0"></span>
							</button>
							<button type="button" class="color-preset" data-color="#e070a0" data-palette="pink" title="Pink (gaming)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #e070a0"></span>
							</button>
							<button type="button" class="color-preset" data-color="#a8aeb8" data-palette="lightGray" title="Light Gray (work)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #a8aeb8"></span>
							</button>
							<button type="button" class="color-preset" data-color="#686c70" data-palette="darkGray" title="Dark Gray (work)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #686c70"></span>
							</button>
							<button type="button" class="color-preset" data-color="#a8a098" data-palette="warmGray" title="Warm Gray (work)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #a8a098"></span>
							</button>
							<button type="button" class="color-preset" data-color="#c8a8a0" data-palette="roseGold" title="Rose Gold (work)" onclick="selectPreset(this)">
								<span class="color-swatch" style="background: #c8a8a0"></span>
							</button>
						</div>
					</div>

					<!-- Custom color picker -->
					<div class="form-group">
						<label>Custom Color</label>
						<div class="custom-color-row">
							<input type="color" id="colorPickerInput" value="#7aa2f7" onchange="updateColorPreview(this.value)"/>
							<input type="text" id="colorPickerHex" value="#7aa2f7" pattern="^#[0-9a-fA-F]{6}$" placeholder="#rrggbb" oninput="syncHexInput(this.value)"/>
						</div>
					</div>

					<!-- Preview -->
					<div class="form-group">
						<label>Preview</label>
						<div class="color-preview-row" id="colorPreviewRow">
							<span class="preview-segment preview-lightest"></span>
							<span class="preview-segment preview-primary"></span>
							<span class="preview-segment preview-secondary"></span>
							<span class="preview-segment preview-midDark"></span>
							<span class="preview-segment preview-dark"></span>
							<span class="preview-segment preview-darker"></span>
							<span class="preview-segment preview-darkest"></span>
						</div>
					</div>

					<input type="hidden" id="colorPickerHostId"/>
					<input type="hidden" id="colorPickerPalette" value=""/>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('colorPickerModal')">Cancel</button>
					<button class="modal-btn modal-btn-primary" onclick="applyColor()">Apply Color</button>
				</div>
			</div>
		</div>

		<!-- P2800: Pre-Check Dialog -->
		<div class="modal-overlay hidden" id="preCheckDialog">
			<div class="modal">
				<div class="modal-title">
					<svg class="modal-icon warning" style="width:24px;height:24px;margin-right:8px;color:var(--warning)">
						<use href="#icon-alert-triangle"></use>
					</svg>
					Cannot <span id="preCheckCommand">Switch</span>
				</div>
				<div class="modal-body">
					<p>Host: <code id="preCheckHostname">hostname</code></p>
					<p id="preCheckMessage" style="margin-top:12px;color:var(--fg)">Pre-check message here</p>
					<p style="margin-top:8px;font-size:0.85rem;color:var(--muted)">(Status may be cached - code: <code id="preCheckCode">code</code>)</p>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('preCheckDialog')">Cancel</button>
					<button class="modal-btn" id="preCheckAltAction" style="background:var(--info)">Refresh Status</button>
					<button class="modal-btn modal-btn-danger" onclick="forceCommand()">Force</button>
				</div>
			</div>
		</div>

		<!-- System Refresh Confirmation Dialog -->
		<div class="modal-overlay hidden" id="systemRefreshDialog">
			<div class="modal">
				<div class="modal-title">
					<svg class="modal-icon" style="width:24px;height:24px;margin-right:8px;color:var(--info)">
						<use href="#icon-nixos"></use>
					</svg>
					Refresh System Status
				</div>
				<div class="modal-body">
					<p>Host: <code id="systemRefreshHostname">hostname</code></p>
					<p style="margin-top:12px;color:var(--fg)">
						This will check if the running system matches the flake by running:
					</p>
					<pre style="margin:12px 0;padding:12px;background:var(--bg-light);border-radius:6px;font-size:0.85rem;white-space:pre-wrap;word-break:break-word;"><code id="systemRefreshCommand">nix build --dry-run .#nixosConfigurations.hostname.config.system.build.toplevel</code></pre>
					<p style="color:var(--warning);font-size:0.9rem;">
						âš ï¸ <strong>This operation is heavy</strong> â€” it does a full flake evaluation and may take quite some time.
						The host may become less responsive during this time.
					</p>
				</div>
				<div class="modal-actions">
					<button class="modal-btn modal-btn-cancel" onclick="closeModal('systemRefreshDialog')">Cancel</button>
					<button class="modal-btn modal-btn-primary" onclick="confirmSystemRefresh()">Run Check</button>
				</div>
			</div>
		</div>

		<footer class="site-footer">
			<div class="footer-left">
				<span class="connection-indicator" id="ws-status">
					<span class="status-dot status-offline"></span>
					Connecting...
				</span>
				<span class="footer-sep">â€¢</span>
				<span>NixFleet { data.Version }</span>
				<a href="https://github.com/markus-barta/nixfleet" class="footer-link" target="_blank" rel="noopener">
					<svg class="icon"><use href="#icon-github"></use></svg>
					Source
				</a>
				<a href="https://www.gnu.org/licenses/agpl-3.0.html" class="footer-link" target="_blank" rel="noopener">
					<svg class="icon"><use href="#icon-license"></use></svg>
					AGPL-3.0
				</a>
			</div>
			<div class="footer-right">
				<span class="made-with">
					Made with <svg class="icon heart"><use href="#icon-heart"></use></svg> by
					<a href="https://x.com/markusbarta" target="_blank" rel="noopener">&#64;markusbarta</a> using
					Claude &amp; Cursor
				</span>
			</div>
		</footer>

		<!-- DEBUG: Raw streaming output (hidden by default, toggle via More menu) -->
		<div id="debug-panel" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: #1a1a2e; border-top: 2px solid #f00; z-index: 9999; max-height: 200px;">
			<div style="padding: 4px 8px; background: #f00; color: #fff; font-weight: bold;">DEBUG: Raw WebSocket Output (toggle via More â†’ Toggle Debug Panel)</div>
			<textarea id="debug-output" style="width: 100%; height: 150px; background: #0a0a1a; color: #0f0; font-family: monospace; font-size: 12px; border: none; resize: none;" readonly></textarea>
		</div>

		<!-- WebSocket and Alpine.js logic - P7000 Unified Host State Management -->
		<script>
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// CONSTANTS
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const HEARTBEAT_INTERVAL = parseInt(document.getElementById('config').dataset.heartbeatInterval) || 5;
			const CSRF_TOKEN = document.body.dataset.csrfToken;

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// SELECTION STORE (P1030) - Single Source of Truth for host selection
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			document.addEventListener('alpine:init', () => {
				Alpine.store('selection', {
					selected: [],
					lastSelected: null,

					toggle(id) {
						const idx = this.selected.indexOf(id);
						if (idx === -1) {
							this.selected.push(id);
						} else {
							this.selected.splice(idx, 1);
						}
						this.lastSelected = id;
					},

					select(id) {
						if (!this.selected.includes(id)) {
							this.selected.push(id);
						}
						this.lastSelected = id;
					},

					deselect(id) {
						const idx = this.selected.indexOf(id);
						if (idx !== -1) {
							this.selected.splice(idx, 1);
						}
					},

					isSelected(id) {
						return this.selected.includes(id);
					},

					selectAll() {
						const allIds = this._getAllHostIds();
						this.selected = [...allIds];
						this.lastSelected = allIds[allIds.length - 1] || null;
					},

					selectNone() {
						this.selected = [];
						this.lastSelected = null;
					},

					selectRange(targetId) {
						if (!this.lastSelected) {
							this.toggle(targetId);
							return;
						}
						const allIds = this._getAllHostIds();
						const startIdx = allIds.indexOf(this.lastSelected);
						const endIdx = allIds.indexOf(targetId);
						if (startIdx === -1 || endIdx === -1) {
							this.toggle(targetId);
							return;
						}
						const minIdx = Math.min(startIdx, endIdx);
						const maxIdx = Math.max(startIdx, endIdx);
						for (let i = minIdx; i <= maxIdx; i++) {
							if (!this.selected.includes(allIds[i])) {
								this.selected.push(allIds[i]);
							}
						}
					},

					get count() {
						return this.selected.length;
					},

					get onlineCount() {
						return this.selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						}).length;
					},

					get headerState() {
						const allIds = this._getAllHostIds();
						if (allIds.length === 0) return 'none';
						if (this.selected.length === 0) return 'none';
						if (this.selected.length === allIds.length) return 'all';
						return 'some';
					},

					_getAllHostIds() {
						const ids = [];
						document.querySelectorAll('tr[data-host-id]').forEach(row => {
							ids.push(row.dataset.hostId);
						});
						return ids;
					}
				});
			});

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// GLOBAL STATE (non-host-specific)
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const globalState = {
				pendingPR: null, // { number, title, url, mergeable } or null
				wsConnected: false,
				// P7240: Track timeouts for context bar
				timeouts: new Map() // hostId -> { command, startedAt, state }
			};

			// Hydrate globalState from config
			(function hydrateGlobalState() {
				const prData = document.getElementById('config').dataset.pendingPr;
				if (prData && prData !== 'null') {
					try {
						globalState.pendingPR = JSON.parse(prData);
					} catch (e) {
						console.warn('Failed to parse pendingPR:', e);
					}
				}
			})();

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// HOST STORE (Single Source of Truth) - P7000
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const hostStore = {
				_hosts: new Map(),

				// Initialize store from server-rendered DOM
				hydrate() {
					document.querySelectorAll('tr[data-host-id]').forEach((row) => {
						const id = row.dataset.hostId;
						if (this._hosts.has(id)) return;

						// Cache element references for O(1) access
						const card = document.querySelector(`.host-card[data-host-id="${id}"]`);

				this._hosts.set(id, {
					// Identity
					id: id,
					hostname: row.dataset.hostname || id,
					hostType: row.dataset.hostType || 'nixos',
					themeColor: row.dataset.themeColor || '#7aa2f7',

					// State
					online: !row.classList.contains('host-offline'),
					lastSeen: row.querySelector('[data-cell="last-seen"]')?.dataset.timestamp || null,
					pendingCommand: row.dataset.pendingCommand || null,

					// Data
					metrics: this._parseMetrics(row),
					updateStatus: this._parseUpdateStatus(row),
					generation: row.dataset.generation || null,
					agentVersion: row.dataset.agentVersion || null,
					agentOutdated: row.dataset.agentOutdated === 'true',
					availableOps: this._parseAvailableOps(row), // P5100: Server-driven available operations

					// Cached DOM references
					_elements: { row, card }
				});
					});
					console.log(`hostStore: hydrated ${this._hosts.size} hosts`);
				},

				_parseMetrics(row) {
					const cell = row.querySelector('[data-cell="metrics"]');
					if (!cell) return null;
					const cpu = cell.querySelector('[data-metric="cpu"]');
					const ram = cell.querySelector('[data-metric="ram"]');
					if (!cpu && !ram) return null;
					return {
						cpu: parseFloat(cpu?.dataset.value) || 0,
						ram: parseFloat(ram?.dataset.value) || 0,
						swap: parseFloat(ram?.dataset.swap) || 0,
						load: parseFloat(ram?.dataset.load) || 0
					};
				},

			_parseUpdateStatus(row) {
				const container = row.querySelector('.update-status');
				if (!container) return null;
				try {
					return {
						git: JSON.parse(container.dataset.git || 'null'),
						lock: JSON.parse(container.dataset.lock || 'null'),
						system: JSON.parse(container.dataset.system || 'null'),
						repoUrl: container.dataset.repoUrl || '',
						repoDir: container.dataset.repoDir || ''
					};
				} catch (e) {
					console.warn('Failed to parse updateStatus:', e);
					return null;
				}
			},

			// P5100: Parse available operations from data attribute
			_parseAvailableOps(row) {
				const opsStr = row.dataset.availableOps;
				if (!opsStr) return [];
				try {
					return JSON.parse(opsStr);
				} catch (e) {
					console.error('Failed to parse availableOps:', e);
					return [];
				}
			},

				get(id) {
					return this._hosts.get(id);
				},

				all() {
					return Array.from(this._hosts.values());
				},

				// Update host state and trigger render
				update(id, patch) {
					const current = this._hosts.get(id);
					if (!current) {
						console.warn(`hostStore: unknown host ${id}`);
						return;
					}

					// Start with shallow merge
					const next = { ...current, ...patch };

					// Deep merge for known nested objects
					if (patch.metrics && current.metrics) {
						next.metrics = { ...current.metrics, ...patch.metrics };
					}
					if (patch.updateStatus && current.updateStatus) {
						next.updateStatus = { ...current.updateStatus, ...patch.updateStatus };
					}

					// Preserve cached elements
					next._elements = current._elements;

					this._hosts.set(id, next);
					renderHost(id);
				},

				setOffline(id) {
					this.update(id, { online: false, pendingCommand: null });
				}
			};

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// RENDER (Single Render Function) - P7000
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			function renderHost(hostId) {
				const host = hostStore.get(hostId);
				if (!host) return;

				// Derived state
				const isOnline = host.online;
				const isBusy = !!host.pendingCommand;
				const buttonsEnabled = isOnline && !isBusy;

				// Use cached element references
				const { row, card } = host._elements || {};

				[row, card].filter(Boolean).forEach((el) => {
					// 1. Offline class
					el.classList.toggle('host-offline', !isOnline);

					// 2. Status indicator (ripple/dot)
					renderStatusIndicator(el, isOnline, isBusy);

					// 3. Progress badge
					renderProgressBadge(el, host.pendingCommand);

					// 4. Metrics
					if (host.metrics) {
						renderMetrics(el, host.metrics);
					}

					// 5. Agent version cell
					renderAgentVersion(el, host);

					// 6. Status compartments (Git/Lock/System)
					if (host.updateStatus) {
						renderUpdateStatus(el, host);
					}

					// 6b. P2800: Operation progress dots
					if (host.operationProgress) {
						renderOperationProgress(el, host.operationProgress);
					}

					// 6c. P7240: Timeout indicator in Status column
					renderTimeoutIndicator(el, host);

					// 6. Button states: swap between cmd-buttons and stop button
					const cmdButtons = el.querySelector('.cmd-buttons');
					const stopBtn = el.querySelector('.btn-stop');
					if (cmdButtons) {
						cmdButtons.style.display = isBusy ? 'none' : '';
						cmdButtons.querySelectorAll('button').forEach(btn => {
							btn.disabled = !buttonsEnabled;
						});
					}
					if (stopBtn) {
						stopBtn.style.display = isBusy ? '' : 'none';
					}

					// 7. Last seen
					const lastSeenCell = el.querySelector('[data-cell="last-seen"]');
					if (lastSeenCell && host.lastSeen) {
						lastSeenCell.dataset.timestamp = host.lastSeen;
						const result = formatLastSeen(host.lastSeen);
						lastSeenCell.textContent = result.text;
						lastSeenCell.className = result.className;
					}
				});
			}

			// Helper: Render status indicator
			function renderStatusIndicator(el, isOnline, isBusy) {
				const wrapper = el.querySelector('.status-wrapper') || el.querySelector('.status-with-badge');
				if (!wrapper) return;

				const existing = wrapper.querySelector('.status-ripple, .status-dot');

				let html;
				if (isOnline && !isBusy) {
					if (existing?.classList.contains('status-ripple')) {
						triggerHeartbeat(existing);
						return;
					}
					html = '<span class="status-ripple"><span class="hb-wave"></span><span class="hb-wave"></span><span class="hb-wave"></span><span class="hb-core"></span></span>';
				} else if (isBusy) {
					html = '<span class="status-dot status-running"></span>';
				} else {
					html = '<span class="status-dot status-offline"></span>';
				}

				if (existing) {
					const temp = document.createElement('div');
					temp.innerHTML = html;
					existing.replaceWith(temp.firstChild);
					if (isOnline && !isBusy) {
						triggerHeartbeat(wrapper.querySelector('.status-ripple'));
					}
				}
			}

			// Helper: Render progress badge
			function renderProgressBadge(el, pendingCommand) {
				const wrapper = el.querySelector('.status-wrapper') || el.querySelector('.status-with-badge');
				if (!wrapper) return;

				let badge = wrapper.querySelector('.progress-badge-mini');
				if (pendingCommand) {
					if (!badge) {
						badge = document.createElement('span');
						badge.className = 'progress-badge-mini';
						wrapper.appendChild(badge);
					}
					badge.textContent = pendingCommand;
				} else if (badge) {
					badge.remove();
				}
			}

			// Helper: Render metrics
			function renderMetrics(el, metrics) {
				const cell = el.querySelector('[data-cell="metrics"]');
				if (!cell) return;

				const cpuEl = cell.querySelector('[data-metric="cpu"]');
				const ramEl = cell.querySelector('[data-metric="ram"]');

				if (cpuEl) {
					const val = cpuEl.querySelector('.metric-val');
					if (val) val.textContent = Math.round(metrics.cpu) + '%';
					cpuEl.classList.toggle('metric-high', metrics.cpu >= 80);
					cpuEl.dataset.value = metrics.cpu;
				}

				if (ramEl) {
					const val = ramEl.querySelector('.metric-val');
					if (val) val.textContent = Math.round(metrics.ram) + '%';
					ramEl.classList.toggle('metric-high', metrics.ram >= 80);
					ramEl.dataset.value = metrics.ram;
					ramEl.dataset.swap = metrics.swap;
					ramEl.dataset.load = metrics.load;
					ramEl.title = `RAM: ${Math.round(metrics.ram)}%, Swap: ${Math.round(metrics.swap)}%, Load: ${metrics.load.toFixed(2)}`;
				}

				// Replace "â€”" placeholder if needed
				const naSpan = cell.querySelector('.metrics-na');
				if (naSpan) {
					cell.innerHTML = `
						<span class="metric" data-metric="cpu" data-value="${metrics.cpu}">
							<svg class="metric-icon"><use href="#icon-cpu"></use></svg>
							<span class="metric-val">${Math.round(metrics.cpu)}%</span>
						</span>
						<span class="metric" data-metric="ram" data-value="${metrics.ram}">
							<svg class="metric-icon"><use href="#icon-ram"></use></svg>
							<span class="metric-val">${Math.round(metrics.ram)}%</span>
						</span>
					`;
				}
			}

			// Helper: Render agent version cell
			function renderAgentVersion(el, host) {
				const cell = el.querySelector('[data-cell="agent-version"] .agent-version');
				if (!cell) return;

				cell.textContent = host.agentVersion || 'â€”';
				cell.className = 'agent-version';
				if (!host.agentVersion) {
					cell.classList.add('agent-version--unknown');
				} else if (host.agentOutdated) {
					cell.classList.add('agent-version--outdated');
				} else {
					cell.classList.add('agent-version--ok');
				}
			}

			// Helper: Render status compartments (Agent/Git/Lock/System)
			// P7300: Single dot per compartment with 5 color states
			// Colors: gray (unchecked), blue-pulse (working), green (ok), yellow (warning), red (error)
			function renderUpdateStatus(el, host) {
				const container = el.querySelector('.update-status');
				if (!container) return;

				const status = host.updateStatus;

				// Update Agent compartment (not from updateStatus)
				const agentBtn = container.querySelector('[data-compartment="agent"]');
				if (agentBtn) {
					const indicator = agentBtn.querySelector('.compartment-indicator');
					if (indicator) {
						indicator.className = 'compartment-indicator';
						if (!host.agentVersion) {
							indicator.classList.add('compartment-indicator--gray');
						} else if (host.agentOutdated) {
							indicator.classList.add('compartment-indicator--error');
						} else {
							indicator.classList.add('compartment-indicator--ok');
						}
					}
				}

				if (!status) return;

				// Update Git/Lock/System compartments
				['git', 'lock', 'system'].forEach((type) => {
					const btn = container.querySelector(`[data-compartment="${type}"]`);
					if (!btn) return;

					const check = status[type];
					
					// Update data-status attribute for CSS/hover
					btn.dataset.status = check?.status || 'unknown';
					
					// Toggle unknown class for dimming
					btn.classList.toggle('unknown', !check || !check.status || check.status === 'unknown');

					// Update single indicator dot
					const indicator = btn.querySelector('.compartment-indicator');
					if (indicator) {
						indicator.className = 'compartment-indicator';
						
						if (check && check.status) {
							// Map status to CSS class
							switch (check.status) {
								case 'ok':
									indicator.classList.add('compartment-indicator--ok');
									break;
								case 'outdated':
									indicator.classList.add('compartment-indicator--warning');
									break;
								case 'error':
									indicator.classList.add('compartment-indicator--error');
									break;
								default:
									indicator.classList.add('compartment-indicator--gray');
							}
						} else {
							indicator.classList.add('compartment-indicator--gray');
						}
					}

					// Lock-specific: agent outdated overrides indicator to error (red)
					if (type === 'lock' && indicator && host.agentOutdated) {
						indicator.className = 'compartment-indicator compartment-indicator--error';
					}
				});
			}

			// P2800: Render operation progress dots in Status column
			function renderOperationProgress(el, progress) {
				const container = el.querySelector('.status-progress');
				if (!container) return;

				// Phase mapping: name â†’ segment class
				const phases = {
					pull: { selector: '.segment-pull', total: 4 },
					lock: { selector: '.segment-lock', total: 2 },
					system: { selector: '.segment-system', total: 3 },
					tests: { selector: '.segment-tests', total: 8 }
				};

				Object.entries(phases).forEach(([name, config]) => {
					const segment = container.querySelector(config.selector);
					if (!segment) return;

					const phaseData = progress[name];
					const dots = segment.querySelectorAll('.progress-dot');

					dots.forEach((dot, i) => {
						// Reset classes
						dot.className = 'progress-dot';

						if (!phaseData) {
							// No data = idle state
							dot.classList.add('dot-idle');
							dot.textContent = 'â—';
							return;
						}

						switch (phaseData.status) {
							case 'complete':
								dot.classList.add('dot-complete');
								dot.textContent = 'â—';
								break;
							case 'error':
								if (i < phaseData.current) {
									dot.classList.add('dot-complete');
									dot.textContent = 'â—';
								} else {
									dot.classList.add('dot-error');
									dot.textContent = 'âœ—';
								}
								break;
							case 'in_progress':
								if (i < phaseData.current) {
									dot.classList.add('dot-complete');
									dot.textContent = 'â—';
								} else if (i === phaseData.current) {
									dot.classList.add('dot-in-progress');
									dot.textContent = 'â—';
								} else {
									dot.classList.add('dot-pending');
									dot.textContent = 'â—‹';
								}
								break;
							default: // pending
								dot.classList.add('dot-pending');
								dot.textContent = 'â—‹';
						}
					});
				});
			}

			// P7240: Render timeout indicator in Status column
			function renderTimeoutIndicator(el, host) {
				const statusCell = el.querySelector('[data-cell="status"]');
				if (!statusCell) return;

				const timeoutStates = ['running_warning', 'timeout_pending', 'killing', 'kill_failed'];
				const hostId = el.dataset.hostId;
				
				// Check if this host has a timeout state
				const timeout = globalState.timeouts.get(hostId);
				let existingIndicator = statusCell.querySelector('.timeout-status-indicator');
				
				if (timeout && timeoutStates.includes(host.commandState || timeout.state)) {
					// Calculate elapsed time
					const elapsed = Date.now() - timeout.startedAt;
					const minutes = Math.floor(elapsed / 60000);
					const seconds = Math.floor((elapsed % 60000) / 1000);
					const elapsedStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
					
					if (!existingIndicator) {
						// Create indicator
						existingIndicator = document.createElement('span');
						existingIndicator.className = 'timeout-status-indicator';
						existingIndicator.onclick = () => showLogPanel(hostId);
						statusCell.appendChild(existingIndicator);
					}
					
					// Update indicator content
					existingIndicator.innerHTML = `<svg class="icon"><use href="#icon-alert-triangle"></use></svg> ${elapsedStr}`;
					existingIndicator.title = `${timeout.command} timed out - click to see log`;
					
					// Hide progress dots when showing timeout
					const progressDots = statusCell.querySelector('.status-progress');
					if (progressDots) progressDots.style.display = 'none';
				} else {
					// Remove indicator if present
					if (existingIndicator) {
						existingIndicator.remove();
					}
					// Show progress dots again
					const progressDots = statusCell.querySelector('.status-progress');
					if (progressDots) progressDots.style.display = '';
				}
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// REFRESH HOST (On-demand API call) - P7000
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			async function refreshHost(hostId) {
				const host = hostStore.get(hostId);
				let btn = host?._elements?.row?.querySelector('.btn-refresh');
				if (!btn) {
					btn = document.querySelector(`button.btn-refresh[data-host-id="${hostId}"]`);
				}
				if (btn) btn.classList.add('loading');

				try {
					const resp = await fetch(`/api/hosts/${hostId}/refresh`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-CSRF-Token': CSRF_TOKEN
						}
					});

					if (resp.status === 404) {
						console.warn(`Host ${hostId} not found`);
						return;
					}

					if (!resp.ok) {
						console.error(`Refresh failed: ${resp.status} ${resp.statusText}`);
						return;
					}

					const data = await resp.json();

					// Update store with fresh data
					hostStore.update(hostId, {
						online: data.online,
						generation: data.generation,
						agentVersion: data.agent_version,
						agentOutdated: data.agent_outdated,
						updateStatus: data.update_status
					});

					// Update global PR state if included
					if (data.pending_pr !== undefined) {
						globalState.pendingPR = data.pending_pr;
					}

				} catch (err) {
					console.error('Refresh failed:', err);
				} finally {
					if (btn) btn.classList.remove('loading');
				}
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// WEBSOCKET - P7000 Simplified Messages
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			let ws = null;
			let reconnectAttempts = 0;
			const maxReconnectDelay = 30000;

			function connectWebSocket() {
				const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
				ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

				ws.onopen = () => {
					console.log('WebSocket connected');
					reconnectAttempts = 0;
					updateConnectionStatus(true);
				};

				ws.onclose = () => {
					console.log('WebSocket disconnected');
					updateConnectionStatus(false);
					scheduleReconnect();
				};

				ws.onerror = (err) => {
					console.error('WebSocket error:', err);
				};

				ws.onmessage = (event) => {
					try {
						const msg = JSON.parse(event.data);
						handleMessage(msg);
					} catch (e) {
						console.error('Failed to parse message:', e);
					}
				};
			}

			function updateConnectionStatus(connected) {
				globalState.wsConnected = connected;
				const el = document.getElementById('ws-status');
				if (connected) {
					el.className = 'connection-indicator connected';
					el.innerHTML = '<span class="status-dot status-online"></span> Connected';
				} else {
					el.className = 'connection-indicator disconnected';
					el.innerHTML = '<span class="status-dot status-offline"></span> Disconnected';
				}
			}

			function scheduleReconnect() {
				reconnectAttempts++;
				const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
				console.log(`Reconnecting in ${delay}ms...`);
				setTimeout(connectWebSocket, delay);
			}

			// P7000: Simplified message handler
			function handleMessage(msg) {
				if (!msg || !msg.type) {
					console.warn('Invalid message:', msg);
					return;
				}

				const payload = msg.payload || {};
				const hostId = payload.host_id;

				switch (msg.type) {
					case 'host_heartbeat':
						if (!hostId) return;
						const heartbeatUpdate = {
							online: true,
							lastSeen: payload.last_seen,
							metrics: payload.metrics
						};
						// Include update_status if present (compartment data)
						if (payload.update_status) {
							heartbeatUpdate.updateStatus = payload.update_status;
						}
						if (payload.generation) {
							heartbeatUpdate.generation = payload.generation;
						}
						hostStore.update(hostId, heartbeatUpdate);
						break;

					case 'host_status_update':
						// Full status update (after command completes or compartment refresh)
						if (!hostId) return;
						const statusUpdate = {};
						if (payload.update_status) {
							statusUpdate.updateStatus = payload.update_status;
						}
						if (payload.generation) {
							statusUpdate.generation = payload.generation;
						}
						hostStore.update(hostId, statusUpdate);
						break;

					case 'host_offline':
						if (!hostId) return;
						hostStore.setOffline(hostId);
						break;

					case 'command_queued':
						if (!hostId) return;
						hostStore.update(hostId, {
							pendingCommand: payload.command
						});
						// Show panel and trigger command start (not just show existing output)
						const panel = document.getElementById('output-panel');
						panel.classList.remove('hidden');
						window.dispatchEvent(new CustomEvent('output-start', { 
							detail: { hostId, command: payload.command } 
						}));
						break;

					case 'command_output':
						console.log('command_output received:', payload);
						// DEBUG: Write directly to debug textarea
						const debugTA = document.getElementById('debug-output');
						if (debugTA) {
							debugTA.value += `[${payload.host_id}] ${payload.line}\n`;
							debugTA.scrollTop = debugTA.scrollHeight;
						}
						appendLog(payload);
						break;

					case 'command_complete':
						if (!hostId) return;
						const host = hostStore.get(hostId);
						hostStore.update(hostId, {
							pendingCommand: null
						});
						window.dispatchEvent(new CustomEvent('log-complete', { detail: payload }));
						// P1010: Notify Action Bar of command completion
						window.dispatchEvent(new CustomEvent('command-complete', {
							detail: {
								hostId,
								hostname: host?.hostname || hostId,
								command: payload.command,
								exit_code: payload.exit_code || 0
							}
						}));
						break;

					case 'flake_update_job':
						// Keep for deployment progress display
						handleFlakeUpdateJob(payload);
						break;

					// P2800: State machine log messages
					case 'state_machine_log':
						handleStateMachineLog(payload);
						break;

				// P2700: Operation progress updates
				case 'operation_progress':
					if (!hostId) return;
					hostStore.update(hostId, {
						operationProgress: payload.progress
					});
					break;

				// P7240: Command state changes (timeout handling)
				case 'command_state_change':
					if (!hostId) return;
					handleCommandStateChange(hostId, payload);
					break;

				default:
					console.debug('Unknown WS message type:', msg.type);
			}
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// ACTIONS (User-initiated)
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// v3: sendCommand using Op Engine /api/dispatch endpoint
			function sendCommand(hostId, command, force = false) {
				const host = hostStore.get(hostId);
				const hostname = host?.hostname || hostId;

				// Immediate UI feedback
				hostStore.update(hostId, { pendingCommand: command });

				// P1010: Notify Action Bar of command start
				window.dispatchEvent(new CustomEvent('command-start', {
					detail: { hostId, hostname, command }
				}));

				// v3: Use new Op Engine dispatch endpoint
				fetch('/api/dispatch', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify({ 
						op: command,
						hosts: [hostId],
						force: force
					})
				}).then(resp => {
					if (!resp.ok) {
						return resp.json().then(data => {
							// Check for blocked status (pre-validation failed)
							if (data.results && data.results[0]?.status === 'blocked') {
								hostStore.update(hostId, { pendingCommand: null });
								showPreCheckDialog(hostId, hostname, command, {
									code: data.results[0].code,
									message: data.results[0].message
								});
								throw { handled: true };
							}
							throw new Error(data.error || 'Request failed');
						});
					}
					return resp.json();
				}).then(data => {
					if (!data) return;
					
					// Check individual host result
					const result = data.results?.[0];
					if (result?.status === 'blocked') {
						hostStore.update(hostId, { pendingCommand: null });
						showPreCheckDialog(hostId, hostname, command, {
							code: result.code,
							message: result.message
						});
						return;
					}
					if (result?.status === 'error') {
						throw new Error(result.error || 'Command failed');
					}
					console.log('Op dispatched:', command, result?.command_id);
				}).catch(err => {
					if (err.handled) return;
					
					console.error('Op dispatch failed:', err);
					const errorMsg = err.message || 'Unknown error';
					showToast(`Command failed: ${errorMsg}`, 'error');
					hostStore.update(hostId, { pendingCommand: null });
					window.dispatchEvent(new CustomEvent('command-complete', {
						detail: { hostId, hostname, command, exit_code: 1, error: errorMsg }
					}));
				});
			}

			// P2800: Show pre-check dialog when validation fails
			function showPreCheckDialog(hostId, hostname, command, validation) {
				const dialog = document.getElementById('preCheckDialog');
				if (!dialog) {
					// Fallback to toast if dialog doesn't exist
					showToast(`Cannot ${command}: ${validation.message}`, 'info');
					return;
				}
				
				// Populate dialog
				document.getElementById('preCheckHostname').textContent = hostname;
				document.getElementById('preCheckCommand').textContent = command;
				document.getElementById('preCheckMessage').textContent = validation.message;
				document.getElementById('preCheckCode').textContent = validation.code;
				
				// Store context for button actions
				dialog.dataset.hostId = hostId;
				dialog.dataset.command = command;
				
				// Show appropriate alternative actions based on code
				const altBtn = document.getElementById('preCheckAltAction');
				if (validation.code === 'git_outdated' && command === 'switch') {
					altBtn.textContent = 'Pull First';
					altBtn.onclick = () => { closeModal('preCheckDialog'); sendCommand(hostId, 'pull'); };
					altBtn.style.display = '';
				} else if (validation.code === 'already_current') {
					altBtn.style.display = 'none';
				} else {
					altBtn.textContent = 'Refresh Status';
					altBtn.onclick = () => { closeModal('preCheckDialog'); sendCommand(hostId, 'refresh-all'); };
					altBtn.style.display = '';
				}
				
				// Open the dialog
				dialog.classList.remove('hidden');
				dialog.classList.add('open');
			}
			
			// P2800: Force execute despite pre-check failure
			function forceCommand() {
				const dialog = document.getElementById('preCheckDialog');
				const hostId = dialog.dataset.hostId;
				const command = dialog.dataset.command;
				closeModal('preCheckDialog');
				sendCommand(hostId, command, true);
			}

			// System refresh confirmation dialog
			function showSystemRefreshDialog(hostId, hostname, description, status) {
				const dialog = document.getElementById('systemRefreshDialog');
				if (!dialog) return;

				// Store host info for confirm action
				dialog.dataset.hostId = hostId;

				// Populate hostname
				document.getElementById('systemRefreshHostname').textContent = hostname;

				// Show the exact command that will run
				// NixOS: nix build --dry-run .#nixosConfigurations.<host>.config.system.build.toplevel
				// macOS: nix build --dry-run .#homeConfigurations.<user>.activationPackage
				const hostRow = document.querySelector(`[data-host-id="${hostId}"]`);
				const hostType = hostRow?.dataset.hostType || 'nixos';
				let command;
				if (hostType === 'macos') {
					command = `nix build --dry-run .#homeConfigurations.${hostname}.activationPackage`;
				} else {
					command = `nix build --dry-run .#nixosConfigurations.${hostname}.config.system.build.toplevel`;
				}
				document.getElementById('systemRefreshCommand').textContent = command;

				// Show current status in log panel
				showLogPanel(hostId);
				appendLogLine(hostId, `â„¹ï¸ Current system status: ${description || status}`);

				// Open dialog
				dialog.classList.remove('hidden');
				dialog.classList.add('open');
			}

			function confirmSystemRefresh() {
				const dialog = document.getElementById('systemRefreshDialog');
				const hostId = dialog.dataset.hostId;
				closeModal('systemRefreshDialog');

				// Send refresh-system command
				appendLogLine(hostId, `ğŸ”„ Starting system status check (this may take 30-60s)...`);
				showToast('System check started...', 'info');
				sendCommand(hostId, 'refresh-system');
			}

			function mergeAndDeploy(prNumber) {
				if (!confirm('Merge PR #' + prNumber + ' and deploy to all online hosts?')) return;

				fetch('/api/flake-updates/merge-and-deploy', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify({ pr_number: prNumber })
				})
				.then(resp => {
					if (!resp.ok) throw new Error('Failed to start deployment');
					return resp.json();
				})
				.then(data => {
					console.log('Deployment started:', data.job_id);
				})
				.catch(err => {
					alert('Failed to start deployment: ' + err.message);
				});
			}

			function bulkCommand(command) {
				const onlineHosts = hostStore.all().filter(h => h.online);
				if (onlineHosts.length === 0) {
					alert('No online hosts to send command to');
					return;
				}

				const confirmMsg = `Send "${command}" to ${onlineHosts.length} online host(s)?`;
				if (!confirm(confirmMsg)) return;

				onlineHosts.forEach(host => {
					sendCommand(host.id, command);
				});
			}

			// P2500: Do All - Pull â†’ Switch â†’ Test on ALL online hosts
			async function bulkDoAll() {
				const onlineHosts = hostStore.all().filter(h => h.online);
				if (onlineHosts.length === 0) {
					alert('No online hosts to send command to');
					return;
				}

				const confirmMsg = `Run Pull â†’ Switch â†’ Test on ${onlineHosts.length} online host(s)?`;
				if (!confirm(confirmMsg)) return;

				let remainingHostIds = onlineHosts.map(h => h.id);

				// Helper: wait for all hosts to complete a command
				const waitForCompletion = (hostIds, command, timeoutMs = 300000) => {
					return new Promise((resolve) => {
						const pending = new Set(hostIds);
						const results = new Map();
						
						const handler = (e) => {
							const { hostId, command: cmd, exit_code } = e.detail;
							if (cmd === command && pending.has(hostId)) {
								pending.delete(hostId);
								results.set(hostId, { success: exit_code === 0, exit_code });
								if (pending.size === 0) {
									window.removeEventListener('command-complete', handler);
									clearTimeout(timer);
									resolve(results);
								}
							}
						};
						
						window.addEventListener('command-complete', handler);
						
						const timer = setTimeout(() => {
							window.removeEventListener('command-complete', handler);
							pending.forEach(id => results.set(id, { success: false, exit_code: -1, timeout: true }));
							resolve(results);
						}, timeoutMs);
					});
				};

				// Execute Pull â†’ Switch â†’ Test sequentially
				for (const command of ['pull', 'switch', 'test']) {
					if (remainingHostIds.length === 0) break;
					
					remainingHostIds.forEach(hostId => sendCommand(hostId, command));
					const results = await waitForCompletion(remainingHostIds, command);
					
					// Filter out failed hosts
					remainingHostIds = remainingHostIds.filter(id => {
						const result = results.get(id);
						return result && result.success;
					});
				}
			}

			function deleteHost(hostId) {
				if (!confirm(`Delete host "${hostId}"? This cannot be undone.`)) {
					return;
				}
				fetch(`/api/hosts/${hostId}`, {
					method: 'DELETE',
					headers: { 'X-CSRF-Token': CSRF_TOKEN }
				}).then(resp => {
					if (!resp.ok) {
						return resp.text().then(text => { throw new Error(text); });
					}
					return resp.json();
				}).then(data => {
					console.log('Host deleted:', data);
					document.querySelectorAll(`[data-host-id="${hostId}"]`).forEach(el => el.remove());
				}).catch(err => {
					console.error('Delete failed:', err);
					alert('Delete failed: ' + err.message);
				});
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// P4020: TABBED OUTPUT PANEL
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const MAX_LINES_PER_TAB = 1000;
			const MAX_SYSTEM_LOG_ENTRIES = 1000;

			// Locale: browser preference with de-AT fallback, always 24h
			const USER_LOCALE = navigator.language || 'de-AT';
			function formatTime(date, withSeconds = true) {
				const opts = { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' };
				return date.toLocaleTimeString(USER_LOCALE, opts);
			}

			function formatDuration(ms) {
				const seconds = Math.floor(ms / 1000);
				if (seconds < 60) return `${seconds}s`;
				const minutes = Math.floor(seconds / 60);
				const remainingSeconds = seconds % 60;
				if (remainingSeconds === 0) return `${minutes}m`;
				return `${minutes}m ${remainingSeconds}s`;
			}

			function appendLog(payload) {
				window.dispatchEvent(new CustomEvent('output-line', { detail: payload }));
			}

			// P2800: Helper to append a simple text line to the log
			function appendLogLine(hostId, text, type = 'info') {
				appendLog({
					host_id: hostId,
					output: text,
					is_stderr: type === 'error',
				});
			}

			function showLogPanel(hostId) {
				const panel = document.getElementById('output-panel');
				panel.classList.remove('hidden');
				// P4021: Switch to host tab without triggering command start
				window.dispatchEvent(new CustomEvent('show-output-tab', { detail: { hostId } }));
			}

			// P4020: Add system log entry
			function addSystemLogEntry(category, message, icon) {
				window.dispatchEvent(new CustomEvent('system-log-entry', {
					detail: { category, message, icon }
				}));
			}

			document.addEventListener('alpine:init', () => {
				Alpine.data('outputPanel', () => ({
					tabs: [],           // Array of { hostId, hostname, lines, indicator, phase, ... }
					activeTab: 'system', // 'system' or hostId - default to system log
					systemLog: [],      // System log entries
					collapsed: false,
					lineCounter: 0,
					logCounter: 0,
					// P4021: New state
					panelHeight: 300,   // Default height in pixels
					fontSize: 13,       // Font size in pixels
					isResizing: false,
					overflowOpen: false,
					relativeTimeInterval: null,

					init() {
						console.log('outputPanel init() called');
						// Restore panel state from localStorage
						const savedCollapsed = localStorage.getItem('outputPanel.collapsed');
						if (savedCollapsed !== null) {
							this.collapsed = savedCollapsed === 'true';
						}

						// P4021: Restore panel height
						const savedHeight = localStorage.getItem('outputPanel.height');
						if (savedHeight !== null) {
							this.panelHeight = parseInt(savedHeight, 10) || 300;
						}

						// Restore font size
						const savedFontSize = localStorage.getItem('outputPanel.fontSize');
						if (savedFontSize !== null) {
							this.fontSize = parseInt(savedFontSize, 10) || 13;
						}
						this.applyFontSize();

						// Listen for output lines
						window.addEventListener('output-line', (e) => this.handleOutputLine(e.detail));

						// Listen for command start
						window.addEventListener('output-start', (e) => this.handleCommandStart(e.detail));

						// Listen for command complete
						window.addEventListener('log-complete', (e) => this.handleCommandComplete(e.detail));

						// Listen for system log entries
						window.addEventListener('system-log-entry', (e) => this.addSystemLog(e.detail));

						// P2800: Listen for state machine log messages
						window.addEventListener('state-machine-log', (e) => this.handleStateMachineLog(e.detail));

						// P4021: Resize event handlers
						window.addEventListener('mousemove', (e) => this.handleResize(e));
						window.addEventListener('mouseup', () => this.stopResize());

						// P4021: Show output tab (from "View Output" menu)
						window.addEventListener('show-output-tab', (e) => this.showOutputTab(e.detail));

						// P4021: Update relative times every 30 seconds
						this.relativeTimeInterval = setInterval(() => this.updateRelativeTimes(), 30000);
					},

					// P4021: Show or switch to a host's output tab
					showOutputTab(detail) {
						const { hostId } = detail;
						if (!hostId) return;

						// Get or create tab (but don't reset it)
						let tab = this.tabs.find(t => t.hostId === hostId);
						if (!tab) {
							const host = hostStore.get(hostId);
							tab = {
								hostId: hostId,
								hostname: host?.hostname || hostId,
								themeColor: host?.themeColor || '#7aa2f7',
								lines: [],
								indicator: 'success',
								hasUnread: false,
								phase: '',
								phaseIcon: '',
								buildCount: 0,
								buildCurrent: 0,
								lastCommand: null,
							};
							this.tabs.push(tab);
						}

						// Switch to this tab
						this.activeTab = hostId;
						tab.hasUnread = false;

						// Uncollapse if collapsed
						if (this.collapsed) {
							this.collapsed = false;
							localStorage.setItem('outputPanel.collapsed', 'false');
						}
					},

					// Get or create tab for a host
					getOrCreateTab(hostId) {
						let tab = this.tabs.find(t => t.hostId === hostId);
						if (!tab) {
							const host = hostStore.get(hostId);
							tab = {
								hostId: hostId,
								hostname: host?.hostname || hostId,
								themeColor: host?.themeColor || '#7aa2f7',
								deviceType: host?.deviceType || 'desktop',
								lines: [],
								indicator: 'running',
								hasUnread: false,
								phase: '',
								phaseIcon: '',
								buildCount: 0,
								buildCurrent: 0,
								lastCommand: null,
								startTime: null,
							};
							this.tabs.push(tab);
						}
						return tab;
					},

					// P4021: Resize handlers
					startResize(e) {
						this.isResizing = true;
						this.resizeStartY = e.clientY;
						this.resizeStartHeight = this.panelHeight;
						e.preventDefault();
					},

					handleResize(e) {
						if (!this.isResizing) return;
						// Handle at bottom: drag down = expand (positive delta)
						const delta = e.clientY - this.resizeStartY;
						const newHeight = Math.max(100, Math.min(600, this.resizeStartHeight + delta));
						this.panelHeight = newHeight;
					},

					stopResize() {
						if (this.isResizing) {
							this.isResizing = false;
							localStorage.setItem('outputPanel.height', this.panelHeight);
						}
					},

					// P4021: Keyboard shortcuts
					handleKeyboard(e) {
						// Only handle if panel is visible
						const panel = document.getElementById('output-panel');
						if (panel.classList.contains('hidden')) return;

						// Ctrl+1-9 for tabs
						if (e.ctrlKey && e.key >= '1' && e.key <= '9') {
							const index = parseInt(e.key, 10) - 1;
							if (index === 0 && this.systemLog.length > 0) {
								this.switchTab('system');
								e.preventDefault();
							} else {
								const tabIndex = this.systemLog.length > 0 ? index - 1 : index;
								if (tabIndex >= 0 && tabIndex < this.tabs.length) {
									this.switchTab(this.tabs[tabIndex].hostId);
									e.preventDefault();
								}
							}
						}

						// Ctrl+W to close active tab
						if (e.ctrlKey && e.key === 'w' && this.activeTab) {
							this.closeTab(this.activeTab);
							e.preventDefault();
						}

						// Escape to collapse
						if (e.key === 'Escape' && !this.collapsed) {
							this.toggleCollapse();
							e.preventDefault();
						}
					},

					// P4021: Update relative times for system log
					updateRelativeTimes() {
						const now = new Date();
						this.systemLog.forEach(entry => {
							entry.relativeTime = this.formatRelativeTime(entry.timestamp, now);
						});
					},

					// P4021: Format relative time
					formatRelativeTime(timestamp, now = new Date()) {
						const diffMs = now - new Date(timestamp);
						const diffSec = Math.floor(diffMs / 1000);
						const diffMin = Math.floor(diffSec / 60);
						const diffHour = Math.floor(diffMin / 60);

						if (diffSec < 5) return 'just now';
						if (diffSec < 60) return diffSec + 's ago';
						if (diffMin < 60) return diffMin + ' min ago';
						if (diffHour < 24) return diffHour + 'h ago';
						return Math.floor(diffHour / 24) + 'd ago';
					},

					// Add status entry as a log line (flat log per host)
					addStatusHistory(hostId, category, icon, message) {
						const tab = this.tabs.find(t => t.hostId === hostId);
						if (!tab) return;

						const now = new Date();
						const timeStr = formatTime(now);

						tab.lines.push({
							id: ++this.lineCounter,
							text: `${timeStr} ${icon} ${message}`,
							isStatus: true,
							isSuccess: category === 'success',
							isError: category === 'error',
						});

						// Trim if too many lines
						if (tab.lines.length > MAX_LINES_PER_TAB) {
							tab.lines = tab.lines.slice(-MAX_LINES_PER_TAB);
						}
					},

					handleCommandStart(detail) {
						const { hostId, command } = detail;
						const tab = this.getOrCreateTab(hostId);

						// // Add START separator
						// const now = new Date();
						// const timeStr = formatTime(now, true);
						// tab.lines.push({
						// 	id: ++this.lineCounter,
						// 	text: `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ${command || 'command'} START (${timeStr}) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`,
						// 	isSeparator: true,
						// });

						// Reset progress
						tab.phase = '';
						tab.phaseIcon = '';
						tab.buildCount = 0;
						tab.buildCurrent = 0;
						tab.indicator = 'running';
						tab.lastCommand = command;
						tab.startTime = Date.now();

						// Switch to this tab
						this.activeTab = hostId;

						// P4021: Add to status history
						this.addStatusHistory(hostId, 'pending', 'â§–', `${command || 'Command'} started`);

						// Add to system log
						const host = hostStore.get(hostId);
						this.addSystemLog({
							category: 'info',
							message: `${host?.hostname || hostId}: ${command || 'Command'} started`,
							icon: 'â„¹'
						});
					},

					handleOutputLine(payload) {
						console.log('handleOutputLine called:', payload);
						const hostId = payload.host_id;
						if (!hostId) return;

						const tab = this.getOrCreateTab(hostId);
						const text = payload.line || payload.output || '';
						console.log('Adding line to tab:', hostId, text, 'current lines:', tab.lines.length);

						// Parse progress
						this.parseProgress(tab, text);

						// Add line - MUST explicitly set isSeparator/isStatus to false
						// Alpine.js has issues with undefined in x-show expressions
						const newLine = {
							id: ++this.lineCounter,
							text: text,
							isError: payload.is_error || payload.stream === 'stderr' || payload.is_stderr,
							isSuccess: payload.isSuccess || false,
							isSeparator: false,  // Explicit false, not undefined
							isStatus: false,     // Explicit false, not undefined
						};
						tab.lines.push(newLine);

						// Trim old lines
						if (tab.lines.length > MAX_LINES_PER_TAB) {
							tab.lines = tab.lines.slice(-MAX_LINES_PER_TAB);
						}

						// Mark unread if not active tab
						if (this.activeTab !== hostId) {
							tab.hasUnread = true;
							if (tab.indicator !== 'running' && tab.indicator !== 'error') {
								tab.indicator = 'unread';
							}
						}

						// Auto-scroll
						this.$nextTick(() => {
							const el = this.$refs.outputContent;
							if (el && this.activeTab === hostId) {
								el.scrollTop = el.scrollHeight;
							}
						});
					},

					handleCommandComplete(detail) {
						const hostId = detail.host_id;
						if (!hostId) return;

						const tab = this.tabs.find(t => t.hostId === hostId);
						if (!tab) return;

						const exitCode = detail.exit_code || 0;
						const success = exitCode === 0;

						tab.phase = success ? 'Complete' : 'Failed';
						tab.phaseIcon = success ? 'âœ“' : 'âœ—';
						tab.indicator = success ? 'success' : 'error';

						// Calculate duration
						let durationStr = '';
						if (tab.startTime) {
							const durationMs = Date.now() - tab.startTime;
							durationStr = ` (execution time ${formatDuration(durationMs)})`;
							tab.startTime = null; // Reset for next command
						}

						// P4021: Add to status history
						const statusMsg = `${tab.lastCommand || 'Command'} ${success ? 'completed' : 'failed'} (exit ${exitCode})${durationStr}`;
						this.addStatusHistory(hostId, success ? 'success' : 'error', success ? 'âœ“' : 'âœ—', statusMsg);

						// Add to system log
						const host = hostStore.get(hostId);
						this.addSystemLog({
							category: success ? 'success' : 'error',
							message: `${host?.hostname || hostId}: ${statusMsg}`,
							icon: success ? 'âœ“' : 'âœ—'
						});
					},

					parseProgress(tab, line) {
						if (line.includes('evaluating derivation')) {
							tab.phase = 'Evaluation';
							tab.phaseIcon = 'â†’';
						} else if (line.includes('these derivations will be built')) {
							const match = line.match(/these (\d+) derivations/);
							if (match) tab.buildCount = parseInt(match[1], 10);
							tab.phase = 'Building';
							tab.phaseIcon = 'â—';
						} else if (line.includes("building '/nix/store/")) {
							tab.buildCurrent++;
							tab.phase = 'Building';
							tab.phaseIcon = 'â—';
						} else if (line.includes('activating the configuration')) {
							tab.phase = 'Activation';
							tab.phaseIcon = 'â–¶';
						} else if (line.includes('switching to configuration')) {
							tab.phase = 'Switch';
							tab.phaseIcon = 'â†’';
						} else if (line.includes('setting up /etc')) {
							tab.phase = 'Setup';
							tab.phaseIcon = 'â—‹';
						} else if (line.includes('will be fetched')) {
							tab.phase = 'Fetching';
							tab.phaseIcon = 'â†“';
						}
					},

					addSystemLog(detail) {
						const now = new Date();
						const timeStr = formatTime(now, true);

						this.systemLog.unshift({
							id: ++this.logCounter,
							category: detail.category || 'info',
							message: detail.message,
							icon: detail.icon || 'â„¹',
							timestamp: now,
							timeDisplay: timeStr,
							relativeTime: 'just now',  // P4021: Dual timestamp format
						});

						// Trim old entries
						if (this.systemLog.length > MAX_SYSTEM_LOG_ENTRIES) {
							this.systemLog = this.systemLog.slice(0, MAX_SYSTEM_LOG_ENTRIES);
						}

						// Show panel if hidden
						const panel = document.getElementById('output-panel');
						panel.classList.remove('hidden');
					},

					handleStateMachineLog(detail) {
						// Map P2800 log levels to system log categories
						const levelMap = {
							'success': { category: 'success', icon: 'âœ“' },
							'warning': { category: 'warning', icon: 'âš ' },
							'error': { category: 'error', icon: 'âœ—' },
							'info': { category: 'info', icon: 'â„¹' },
						};
						const mapping = levelMap[detail.level?.toLowerCase()] || levelMap.info;

						// Add to system log
						this.addSystemLog({
							category: mapping.category,
							message: `${detail.host_id}: ${detail.message}`,
							icon: mapping.icon,
						});

						// P4021: Also add to host's status history
						if (detail.host_id) {
							this.addStatusHistory(detail.host_id, mapping.category, mapping.icon, detail.message);
						}
					},

					switchTab(tabId) {
						this.activeTab = tabId;

						// Clear unread for host tabs
						if (tabId !== 'system') {
							const tab = this.tabs.find(t => t.hostId === tabId);
							if (tab) {
								tab.hasUnread = false;
								// Reset indicator if was 'unread'
								if (tab.indicator === 'unread') {
									tab.indicator = 'success';
								}
							}
						}

						// Scroll to bottom
						this.$nextTick(() => {
							const el = this.$refs.outputContent;
							if (el) el.scrollTop = el.scrollHeight;
						});
					},

					closeTab(tabId) {
						if (tabId === 'system') {
							this.systemLog = [];
							if (this.activeTab === 'system') {
								this.activeTab = this.tabs.length > 0 ? this.tabs[0].hostId : null;
							}
						} else {
							const index = this.tabs.findIndex(t => t.hostId === tabId);
							if (index !== -1) {
								this.tabs.splice(index, 1);
								if (this.activeTab === tabId) {
									// Switch to another tab
									if (this.tabs.length > 0) {
										this.activeTab = this.tabs[Math.max(0, index - 1)].hostId;
									} else if (this.systemLog.length > 0) {
										this.activeTab = 'system';
									} else {
										this.activeTab = null;
									}
								}
							}
						}

						// Hide panel if no tabs
						if (this.tabs.length === 0 && this.systemLog.length === 0) {
							const panel = document.getElementById('output-panel');
							panel.classList.add('hidden');
						}
					},

					closeAllTabs() {
						this.tabs = [];
						this.activeTab = this.systemLog.length > 0 ? 'system' : null;

						if (this.systemLog.length === 0) {
							const panel = document.getElementById('output-panel');
							panel.classList.add('hidden');
						}
					},

					toggleCollapse() {
						this.collapsed = !this.collapsed;
						localStorage.setItem('outputPanel.collapsed', this.collapsed);
					},

					applyFontSize() {
						const content = this.$refs.outputContent;
						if (content) {
							content.style.fontSize = this.fontSize + 'px';
						}
					},

					increaseFontSize() {
						if (this.fontSize < 20) {
							this.fontSize += 1;
							localStorage.setItem('outputPanel.fontSize', this.fontSize);
							this.applyFontSize();
						}
					},

					decreaseFontSize() {
						if (this.fontSize > 9) {
							this.fontSize -= 1;
							localStorage.setItem('outputPanel.fontSize', this.fontSize);
							this.applyFontSize();
						}
					},

					getActiveTabData() {
						if (this.activeTab === 'system') return null;
						return this.tabs.find(t => t.hostId === this.activeTab);
					},

					// Alpine getters for reactivity
					get activeTabLines() {
						const tab = this.tabs.find(t => t.hostId === this.activeTab);
						return tab ? tab.lines : [];
					},
					get activeTabColor() {
						const tab = this.tabs.find(t => t.hostId === this.activeTab);
						return tab ? tab.themeColor : '#7aa2f7';
					},

					// Get all hosts from hostStore for dropdown
					getAllHosts() {
						return hostStore.all().map(h => ({
							id: h.id,
							hostname: h.hostname,
							themeColor: h.themeColor || '#7aa2f7'
						}));
					},

					// Check if a host tab exists
					hasTab(hostId) {
						return this.tabs.some(t => t.hostId === hostId);
					},

					// Get indicator class for a host (from tab or default)
					getHostTabIndicator(hostId) {
						const tab = this.tabs.find(t => t.hostId === hostId);
						return tab?.indicator || '';
					},

					// Toggle a host tab on/off
					toggleHostTab(hostId, hostname, themeColor) {
						const existing = this.tabs.find(t => t.hostId === hostId);
						if (existing) {
							// Close this tab
							this.closeTab(hostId);
						} else {
							// Create tab and switch to it
							const tab = {
								hostId: hostId,
								hostname: hostname,
								themeColor: themeColor || '#7aa2f7',
								lines: [],
								indicator: '',
								hasUnread: false,
								phase: '',
								phaseIcon: '',
								buildCount: 0,
								buildCurrent: 0,
								lastCommand: null,
							};
							this.tabs.push(tab);
							this.activeTab = hostId;
						}
					},

					clearActiveTab() {
						let count = 0;
						let name = 'System';
						if (this.activeTab === 'system') {
							count = this.systemLog.length;
							this.systemLog = [];
						} else {
							const tab = this.getActiveTabData();
							if (tab) {
								count = tab.lines.length;
								name = tab.hostname;
								tab.lines = [];
							}
						}
						showToast(`Cleared ${count} lines from ${name}`, 'success');
					},

					copyActiveTab() {
						let text = '';
						let name = 'System';
						if (this.activeTab === 'system') {
							text = this.systemLog.map(e => `${e.timeDisplay} ${e.icon} ${e.message}`).join('\n');
						} else {
							const tab = this.getActiveTabData();
							if (tab) {
								text = tab.lines.map(l => l.text).join('\n');
								name = tab.hostname;
							}
						}
						const lineCount = text ? text.split('\n').length : 0;
						navigator.clipboard.writeText(text).then(() => {
							showToast(`Copied ${lineCount} lines from ${name}`, 'success');
						}).catch(() => {
							showToast('Failed to copy to clipboard', 'error');
						});
					},

					get systemLogIndicator() {
						// Return indicator class based on latest entry
						if (this.systemLog.length === 0) return '';
						const latest = this.systemLog[0];
						return latest.category;
					},
				}));
			});

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// UTILITIES
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			function formatLastSeen(isoString) {
				if (!isoString) return { text: 'â€”', className: '' };

				const date = new Date(isoString);
				const now = new Date();
				const diffMs = now - date;
				const diffSec = Math.max(0, Math.floor(diffMs / 1000));

				let text;
				if (diffSec < 60) {
					text = diffSec + 's';
				} else if (diffSec < 3600) {
					text = Math.floor(diffSec / 60) + 'm';
				} else if (diffSec < 86400) {
					text = Math.floor(diffSec / 3600) + 'h';
				} else {
					text = Math.floor(diffSec / 86400) + 'd';
				}

				let className;
				if (diffSec <= HEARTBEAT_INTERVAL * 2) {
					className = 'last-seen-ok';
				} else if (diffSec <= HEARTBEAT_INTERVAL * 10) {
					className = 'last-seen-warn';
				} else {
					className = 'last-seen-stale';
				}

				return { text, className };
			}

			function triggerHeartbeat(rippleEl) {
				if (!rippleEl) return;
				rippleEl.classList.add('heartbeat');
				setTimeout(() => rippleEl.classList.remove('heartbeat'), 1500);
			}

			function handleFlakeUpdateJob(job) {
				// P2600: Show deploy progress via toast
				const state = job.state || 'unknown';
				const message = job.message || '';
				
				switch (state) {
					case 'merging':
						showToast(`Merging PR #${job.pr_number || '?'}...`, 'info');
						break;
					case 'deploying':
						const hostCount = job.host_count || 'all';
						showToast(`Deploying to ${hostCount} hosts...`, 'info');
						break;
					case 'complete':
						showToast(message || 'Deploy complete!', 'success');
						break;
					case 'error':
						showToast(message || 'Deploy failed', 'error');
						break;
					default:
						// Log unknown states for debugging
						console.log('Flake update job:', state, message);
				}
			}

			// P2800: Handle state machine log messages
			function handleStateMachineLog(log) {
				// Dispatch to System Log component
				window.dispatchEvent(new CustomEvent('state-machine-log', { detail: log }));
				
				// Show important messages as toasts
				if (log.level === 'error') {
					showToast(`${log.host_id || 'System'}: ${log.message}`, 'error');
				} else if (log.level === 'warning' && log.state === 'VALIDATINGâ†’BLOCKED') {
					// Show blocked action warnings
					showToast(`${log.host_id}: ${log.message}`, 'info');
				}
			}

			// P7240: Handle command state changes for timeout UI
			function handleCommandStateChange(hostId, payload) {
				const state = payload.state;
				const host = hostStore.get(hostId);
				const hostname = host?.hostname || hostId;

				// States that indicate timeout
				const timeoutStates = ['running_warning', 'timeout_pending', 'killing', 'kill_failed'];
				
				if (timeoutStates.includes(state)) {
					// Add/update timeout tracking
					if (!globalState.timeouts.has(hostId)) {
						globalState.timeouts.set(hostId, {
							hostname,
							command: host?.pendingCommand || 'unknown',
							startedAt: Date.now() - (payload.elapsed_ms || 0),
							state
						});
					} else {
						const existing = globalState.timeouts.get(hostId);
						existing.state = state;
					}
					
					// Dispatch event for context bar update
					window.dispatchEvent(new CustomEvent('timeout-update', { detail: { hostId, state, hostname } }));
					
					// Show toast for timeout_pending (needs user action)
					if (state === 'timeout_pending') {
						showToast(`âš ï¸ ${hostname}: command timed out - action required`, 'warning');
					}
				} else {
					// Command completed or state cleared - remove timeout
					if (globalState.timeouts.has(hostId)) {
						globalState.timeouts.delete(hostId);
						window.dispatchEvent(new CustomEvent('timeout-cleared', { detail: { hostId } }));
					}
				}

				// Update host store with command state
				hostStore.update(hostId, { commandState: state });
			}

			// P7240: Timeout action API calls
			async function handleTimeoutAction(hostId, action, minutes = 5) {
				try {
					const resp = await fetch(`/api/hosts/${hostId}/timeout-action`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-CSRF-Token': CSRF_TOKEN
						},
						body: JSON.stringify({ action, minutes })
					});
					
					if (!resp.ok) {
						const text = await resp.text();
						throw new Error(text);
					}
					
					const host = hostStore.get(hostId);
					const hostname = host?.hostname || hostId;
					
					switch (action) {
						case 'wait':
							showToast(`${hostname}: extended timeout by ${minutes} minutes`, 'info');
							break;
						case 'kill':
							showToast(`${hostname}: kill signal sent`, 'warning');
							break;
						case 'ignore':
							showToast(`${hostname}: timeout ignored`, 'info');
							break;
					}
					
					// Remove from local timeout tracking
					globalState.timeouts.delete(hostId);
					window.dispatchEvent(new CustomEvent('timeout-cleared', { detail: { hostId } }));
					
				} catch (err) {
					showToast(`Failed to ${action}: ${err.message}`, 'error');
				}
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// MODALS & DROPDOWNS (Keep existing, no changes)
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			function toggleDropdown(btn) {
				const dropdown = btn.closest('.dropdown');
				const wasOpen = dropdown.classList.contains('open');
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				if (!wasOpen) dropdown.classList.add('open');
			}

			document.addEventListener('click', (e) => {
				if (!e.target.closest('.dropdown')) {
					document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				}
			});

			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') {
					document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
					document.querySelectorAll('.modal-overlay.open').forEach(m => m.classList.remove('open'));
					closeBulkMenu();
				}
			});

			// P2100: Bulk menu with keyboard navigation
			let bulkMenuFocusedIndex = -1;

			function toggleBulkMenu(e) {
				e.stopPropagation();
				const menu = document.getElementById('bulk-actions-menu');
				const wasOpen = menu.classList.contains('open');
				menu.classList.toggle('open');
				if (!wasOpen) {
					bulkMenuFocusedIndex = 0;
					focusBulkMenuItem(0);
				} else {
					bulkMenuFocusedIndex = -1;
				}
			}

			function closeBulkMenu() {
				const menu = document.getElementById('bulk-actions-menu');
				if (menu) menu.classList.remove('open');
				bulkMenuFocusedIndex = -1;
			}

			// P4021: Force clear all caches and reload
			async function forceRefresh() {
				closeBulkMenu();
				try {
					// Clear browser caches if available (Service Worker caches)
					if ('caches' in window) {
						const names = await caches.keys();
						await Promise.all(names.map(n => caches.delete(n)));
					}
				} catch (e) {
					console.log('Cache clear failed:', e);
				}
				// Force reload bypassing cache
				location.reload(true);
			}

			function toggleDebugPanel() {
				closeBulkMenu();
				const panel = document.getElementById('debug-panel');
				if (panel) {
					panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
				}
			}

			function focusBulkMenuItem(idx) {
				const menu = document.getElementById('bulk-actions-menu');
				if (!menu) return;
				const items = [...menu.querySelectorAll('.dropdown-item')];
				if (items.length === 0) return;
				bulkMenuFocusedIndex = ((idx % items.length) + items.length) % items.length;
				items[bulkMenuFocusedIndex].focus();
			}

			function handleBulkMenuKeydown(e) {
				const menu = document.getElementById('bulk-actions-menu');
				if (!menu || !menu.classList.contains('open')) return;

				if (e.key === 'ArrowDown') {
					e.preventDefault();
					focusBulkMenuItem(bulkMenuFocusedIndex + 1);
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					focusBulkMenuItem(bulkMenuFocusedIndex - 1);
				} else if (e.key === 'Escape') {
					e.preventDefault();
					closeBulkMenu();
					// Return focus to the button
					const btn = document.querySelector('.bulk-actions-dropdown .btn');
					if (btn) btn.focus();
				}
			}

			document.addEventListener('click', (e) => {
				if (!e.target.closest('.bulk-actions-dropdown')) {
					closeBulkMenu();
				}
			});

			function unlockActions(btn) {
				const hostId = btn.dataset.hostId;
				hostStore.update(hostId, { pendingCommand: null });
				btn.closest('.dropdown').classList.remove('open');
			}

			function downloadLogs(hostId) {
				window.open(`/api/hosts/${hostId}/logs?download=true`, '_blank');
			}

			let pendingRemoveHostId = null;

			function confirmRemoveHost(hostId, hostname) {
				pendingRemoveHostId = hostId;
				document.getElementById('removeHostName').textContent = hostname;
				document.getElementById('removeHostModal').classList.add('open');
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
			}

			function doRemoveHost() {
				if (!pendingRemoveHostId) return;
				fetch(`/api/hosts/${pendingRemoveHostId}`, {
					method: 'DELETE',
					headers: { 'X-CSRF-Token': CSRF_TOKEN }
				}).then(resp => {
					if (!resp.ok) throw new Error('Failed to remove host');
					return resp.json();
				}).then(() => {
					document.querySelectorAll(`[data-host-id="${pendingRemoveHostId}"]`).forEach(el => el.remove());
					closeModal('removeHostModal');
				}).catch(err => {
					alert('Failed to remove host: ' + err.message);
				});
			}

			function closeModal(modalId) {
				document.getElementById(modalId).classList.remove('open');
				pendingRemoveHostId = null;
			}

			// P6900: Reboot modal functions
			let pendingRebootHostId = null;
			let pendingRebootHostname = null;

		function showRebootModal(hostId, hostname) {
			// P5100: Server decides if reboot is available (via availableOps)
			// If button was enabled, host is ready for reboot
			pendingRebootHostId = hostId;
			pendingRebootHostname = hostname;
				document.getElementById('rebootHostName').textContent = hostname;
				document.getElementById('rebootTotp').value = '';
				document.getElementById('rebootConfirmBtn').disabled = true;
				document.getElementById('rebootModal').classList.add('open');
				document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
				// Auto-focus TOTP input
				setTimeout(() => document.getElementById('rebootTotp').focus(), 100);
			}

			function closeRebootModal() {
				document.getElementById('rebootModal').classList.remove('open');
				pendingRebootHostId = null;
				pendingRebootHostname = null;
			}

			function validateRebootTotp(input) {
				const value = input.value.replace(/\D/g, ''); // Remove non-digits
				input.value = value;
				document.getElementById('rebootConfirmBtn').disabled = value.length !== 6;
			}

			async function doReboot() {
				if (!pendingRebootHostId) return;

				const totpInput = document.getElementById('rebootTotp');
				const confirmBtn = document.getElementById('rebootConfirmBtn');
				const btnText = document.getElementById('rebootBtnText');
				const btnSpinner = document.getElementById('rebootBtnSpinner');
				const totp = totpInput.value;

				// Disable button and show loading state
				confirmBtn.disabled = true;
				btnText.style.display = 'none';
				btnSpinner.style.display = 'inline';

				try {
					const resp = await fetch(`/api/hosts/${pendingRebootHostId}/reboot`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-CSRF-Token': CSRF_TOKEN
						},
						body: JSON.stringify({ totp })
					});

					const data = await resp.json();

					if (resp.status === 401) {
						showToast('Invalid TOTP code', 'error');
						totpInput.focus();
						totpInput.select();
						confirmBtn.disabled = false;
						btnText.style.display = 'inline';
						btnSpinner.style.display = 'none';
						return;
					}

					if (resp.status === 429) {
						showToast(data.error || 'Too many reboot attempts. Please wait.', 'error');
						closeRebootModal();
						return;
					}

					if (!resp.ok) {
						showToast(data.error || `Reboot failed: ${resp.statusText}`, 'error');
						confirmBtn.disabled = false;
						btnText.style.display = 'inline';
						btnSpinner.style.display = 'none';
						return;
					}

					// Success
					closeRebootModal();
					showToast(`Reboot command sent to ${pendingRebootHostname}`, 'info');
				} catch (err) {
					showToast(`Network error: ${err.message}`, 'error');
					confirmBtn.disabled = false;
					btnText.style.display = 'inline';
					btnSpinner.style.display = 'none';
				}
			}

			function openAddHostModal() {
				document.getElementById('addHostModal').classList.add('open');
			}

			function doAddHost() {
				const form = document.getElementById('addHostForm');
				const formData = new FormData(form);
				const data = Object.fromEntries(formData.entries());
				fetch('/api/hosts', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify(data)
				}).then(resp => {
					if (!resp.ok) throw new Error('Failed to add host');
					return resp.json();
				}).then(() => {
					closeModal('addHostModal');
					window.location.reload();
				}).catch(err => {
					alert('Failed to add host: ' + err.message);
				});
			}

			document.querySelectorAll('.modal-overlay').forEach(overlay => {
				overlay.addEventListener('click', (e) => {
					if (e.target === overlay) overlay.classList.remove('open');
				});
			});

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// P2950: COLOR PICKER
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			function openColorPicker(hostId, hostname, currentColor) {
				document.getElementById('colorPickerHostId').value = hostId;
				document.getElementById('colorPickerHostname').textContent = hostname;
				document.getElementById('colorPickerInput').value = currentColor;
				document.getElementById('colorPickerHex').value = currentColor;
				document.getElementById('colorPickerPalette').value = '';
				
				// Clear previous selection
				document.querySelectorAll('.color-preset.selected').forEach(btn => btn.classList.remove('selected'));
				
				// Check if current color matches a preset
				document.querySelectorAll('.color-preset').forEach(btn => {
					if (btn.dataset.color.toLowerCase() === currentColor.toLowerCase()) {
						btn.classList.add('selected');
						document.getElementById('colorPickerPalette').value = btn.dataset.palette;
					}
				});
				
				updateColorPreview(currentColor);
				document.getElementById('colorPickerModal').classList.add('open');
			}

			function selectPreset(btn) {
				document.querySelectorAll('.color-preset.selected').forEach(b => b.classList.remove('selected'));
				btn.classList.add('selected');
				const color = btn.dataset.color;
				document.getElementById('colorPickerInput').value = color;
				document.getElementById('colorPickerHex').value = color;
				document.getElementById('colorPickerPalette').value = btn.dataset.palette;
				updateColorPreview(color);
			}

			function syncHexInput(value) {
				if (/^#[0-9a-fA-F]{6}$/.test(value)) {
					document.getElementById('colorPickerInput').value = value;
					document.getElementById('colorPickerPalette').value = ''; // Custom color
					document.querySelectorAll('.color-preset.selected').forEach(b => b.classList.remove('selected'));
					updateColorPreview(value);
				}
			}

			function updateColorPreview(hex) {
				// Generate gradient preview using HSL manipulation
				const hsl = hexToHSL(hex);
				const row = document.getElementById('colorPreviewRow');
				
				// Generate gradient stops
				const stops = [
					hslToHex(hsl.h, hsl.s, 0.75),      // lightest
					hex,                                 // primary
					hslToHex(hsl.h, hsl.s, hsl.l * 0.75), // secondary
					hslToHex(hsl.h, hsl.s, 0.20),      // midDark
					hslToHex(hsl.h, hsl.s, 0.12),      // dark
					hslToHex(hsl.h, hsl.s, 0.08),      // darker
					hslToHex(hsl.h, hsl.s, 0.05),      // darkest
				];
				
				const segments = row.querySelectorAll('.preview-segment');
				segments.forEach((seg, i) => {
					seg.style.background = stops[i];
				});
			}

			function hexToHSL(hex) {
				hex = hex.replace('#', '');
				const r = parseInt(hex.substr(0, 2), 16) / 255;
				const g = parseInt(hex.substr(2, 2), 16) / 255;
				const b = parseInt(hex.substr(4, 2), 16) / 255;
				
				const max = Math.max(r, g, b), min = Math.min(r, g, b);
				const l = (max + min) / 2;
				let h, s;
				
				if (max === min) {
					h = s = 0;
				} else {
					const d = max - min;
					s = d / (1 - Math.abs(2 * l - 1));
					switch (max) {
						case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
						case g: h = ((b - r) / d + 2) / 6; break;
						case b: h = ((r - g) / d + 4) / 6; break;
					}
				}
				return { h: h * 360, s, l };
			}

			function hslToHex(h, s, l) {
				h = ((h % 360) + 360) % 360;
				s = Math.max(0, Math.min(1, s));
				l = Math.max(0, Math.min(1, l));
				
				const c = (1 - Math.abs(2 * l - 1)) * s;
				const x = c * (1 - Math.abs((h / 60) % 2 - 1));
				const m = l - c / 2;
				let r, g, b;
				
				if (h < 60) { r = c; g = x; b = 0; }
				else if (h < 120) { r = x; g = c; b = 0; }
				else if (h < 180) { r = 0; g = c; b = x; }
				else if (h < 240) { r = 0; g = x; b = c; }
				else if (h < 300) { r = x; g = 0; b = c; }
				else { r = c; g = 0; b = x; }
				
				const toHex = v => Math.round((v + m) * 255).toString(16).padStart(2, '0');
				return '#' + toHex(r) + toHex(g) + toHex(b);
			}

			function applyColor() {
				const hostId = document.getElementById('colorPickerHostId').value;
				const color = document.getElementById('colorPickerHex').value;
				const palette = document.getElementById('colorPickerPalette').value;
				
				// Open log panel to show progress
				showLogPanel(hostId);
				
				fetch(`/api/hosts/${hostId}/theme-color`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRF-Token': CSRF_TOKEN
					},
					body: JSON.stringify({ 
						color: color,
						palette: palette || null  // null means custom color
					})
				}).then(resp => {
					if (!resp.ok) return resp.text().then(t => { throw new Error(t); });
					return resp.json();
				}).then(data => {
					closeModal('colorPickerModal');
					showToast(`Color updated for ${hostId}. Changes will apply after rebuild.`, 'success');
					
					// Update the row's gradient immediately for visual feedback
					const row = document.querySelector(`tr[data-host-id="${hostId}"]`);
					if (row) {
						row.dataset.themeColor = color;
						const rgb = hexToRGB(color);
						row.style.background = `linear-gradient(to right, rgba(${rgb}, 0.02) 0%, rgba(${rgb}, 0.10) 25%, rgba(${rgb}, 0.02) 50%, transparent 100%)`;
					}
				}).catch(err => {
					alert('Failed to apply color: ' + err.message);
				});
			}

			function hexToRGB(hex) {
				hex = hex.replace('#', '');
				const r = parseInt(hex.substr(0, 2), 16);
				const g = parseInt(hex.substr(2, 2), 16);
				const b = parseInt(hex.substr(4, 2), 16);
				return `${r}, ${g}, ${b}`;
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// ROW SELECTION HANDLERS (P1030)
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			function handleHeaderCheckboxClick() {
				const store = Alpine.store('selection');
				if (store.headerState === 'none') {
					store.selectAll();
				} else {
					store.selectNone();
				}
			}

			function handleCheckboxClick(event, hostId) {
				event.stopPropagation();
				const store = Alpine.store('selection');
				if (event.shiftKey && store.lastSelected) {
					store.selectRange(hostId);
				} else {
					store.toggle(hostId);
				}
			}

			// Keyboard shortcuts for selection
			document.addEventListener('keydown', (e) => {
				if (e.target.matches('input, textarea, [contenteditable]')) return;

				// Ctrl/Cmd + A: Select all
				if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
					e.preventDefault();
					Alpine.store('selection').selectAll();
				}

				// Escape: Clear selection (if any)
				if (e.key === 'Escape') {
					const store = Alpine.store('selection');
					if (store.count > 0) {
						e.preventDefault();
						store.selectNone();
					}
				}
			});

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// CLICKABLE COMPARTMENTS (P1020)
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const compartmentCooldowns = new Map();
			const COOLDOWN_MS = 500;

			// P7300: Hover shows info description (no action preview)
			function handleCompartmentHover(btn) {
				const hostId = btn.dataset.hostId;
				const hostname = btn.dataset.hostname;
				const compartment = btn.dataset.compartment;
				const description = btn.dataset.description || '';

				// P7300: Compartments are info-only, show description in context bar
				// Map compartment to an info display (no action)
				window.dispatchEvent(new CustomEvent('action-preview', {
					detail: { hostId, hostname, command: 'info', compartment, description }
				}));
			}

			function handleCompartmentLeave() {
				window.dispatchEvent(new CustomEvent('action-clear'));
			}

			// P7300: Compartment click = INFO ONLY
			// - Safe lightweight checks allowed (git status refresh)
			// - NO host modification (no pull, switch)
			// - NO heavy ops (no nix build --dry-run)
			// For actions, use the ellipsis menu
			function handleCompartmentClick(btn) {
				const hostId = btn.dataset.hostId;
				const hostname = btn.dataset.hostname;
				const compartment = btn.dataset.compartment;
				const description = btn.dataset.description || '';

				// Rate limiting (prevent spam clicks)
				const cooldownKey = `${hostId}-${compartment}`;
				if (compartmentCooldowns.has(cooldownKey)) return;

				compartmentCooldowns.set(cooldownKey, true);
				btn.classList.add('rate-limited');
				setTimeout(() => {
					compartmentCooldowns.delete(cooldownKey);
					btn.classList.remove('rate-limited');
				}, COOLDOWN_MS);

				// P7230: All compartment clicks show toast + log
				// Toast = short TL;DR, Log = detailed info
				const status = btn.dataset.status || 'unknown';
				const toastType = status === 'ok' ? 'success' : 
								  status === 'error' ? 'error' : 
								  status === 'outdated' ? 'warning' : 'info';

				switch (compartment) {
					case 'agent':
						// P7230: Agent: run check-version command to compare running vs installed
						showLogPanel(hostId);
						appendLogLine(hostId, `ğŸ” Checking agent version...`);
						showToast(`Agent: checking version...`, 'info');
						sendCommand(hostId, 'check-version');
						break;

					case 'git':
						// Git: lightweight refresh (dashboard-side GitHub API call)
						showLogPanel(hostId);
						appendLogLine(hostId, `ğŸ”„ Refreshing git status...`);
						showToast(`Git: refreshing...`, 'info');
						window.dispatchEvent(new CustomEvent('output-start', {
							detail: { hostId, command: 'refresh-git' }
						}));

						fetch(`/api/hosts/${hostId}/refresh-git`, {
							method: 'POST',
							headers: { 'X-CSRF-Token': CSRF_TOKEN }
						}).then(resp => {
							if (!resp.ok) throw new Error('Failed to refresh git status');
							return resp.json();
						}).then(data => {
							const msg = `Git: ${data.status} - ${data.message}`;
							appendLogLine(hostId, `âœ“ ${msg}`);
							showToast(msg, data.status === 'ok' ? 'success' : 'warning');
							refreshHost(hostId);
							window.dispatchEvent(new CustomEvent('log-complete', {
								detail: { host_id: hostId, command: 'refresh-git', exit_code: 0 }
							}));
						}).catch(err => {
							appendLogLine(hostId, `âœ— ${err.message}`, 'error');
							showToast(`Git: ${err.message}`, 'error');
							window.dispatchEvent(new CustomEvent('log-complete', {
								detail: { host_id: hostId, command: 'refresh-git', exit_code: 1, error: err.message }
							}));
						});
						break;

					case 'lock':
						// Lock: lightweight refresh (agent reads flake.lock - fast)
						showLogPanel(hostId);
						appendLogLine(hostId, `ğŸ”„ Refreshing lock status...`);
						showToast(`Lock: ${description || 'checking...'}`, toastType);
						sendCommand(hostId, 'refresh-lock');
						break;

					case 'system':
						// System: show confirmation dialog (refresh is expensive)
						showSystemRefreshDialog(hostId, hostname, description, status);
						break;

					default:
						showToast(`Unknown compartment: ${compartment}`, 'error');
				}
			}

			function showToast(message, type = 'info') {
				const existing = document.querySelector('.toast');
				if (existing) existing.remove();

				const toast = document.createElement('div');
				toast.className = `toast toast-${type}`;
				toast.textContent = message;
				document.body.appendChild(toast);

				requestAnimationFrame(() => toast.classList.add('show'));

				setTimeout(() => {
					toast.classList.remove('show');
					setTimeout(() => toast.remove(), 300);
				}, 3000);
			}

			// P1060: Clipboard utility
			async function copyToClipboard(text, message) {
				try {
					await navigator.clipboard.writeText(text);
					showToast(message, 'success');
				} catch (err) {
					console.error('Failed to copy:', err);
					showToast('Failed to copy to clipboard', 'error');
				}
			}

			// Copy hostname to clipboard (used by clickable hostnames)
			async function copyHostname(hostname) {
				await copyToClipboard(hostname, 'Copied hostname to clipboard');
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// CONTEXT BAR COMPONENT - Unified hover preview + selection actions
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// P2500: Enhanced Context Bar with full descriptions and PR support
			document.addEventListener('alpine:init', () => {
				Alpine.data('contextBar', () => ({
					// Hover state
					hoverAction: null,
					hostnameHover: null, // For hostname copy hint
					_clearTimer: null,
					_hostnameClearTimer: null,
					// P7240: Timeout tracking
					timeouts: [],
					_elapsedInterval: null,

					init() {
						// Listen for hover events from compartments
						window.addEventListener('action-preview', (e) => this.handlePreview(e.detail));
						window.addEventListener('action-clear', () => this.handleClear());
						// Listen for hostname hover events
						window.addEventListener('hostname-hover', (e) => this.handleHostnameHover(e.detail));
						window.addEventListener('hostname-clear', () => this.handleHostnameClear());
						// P7240: Listen for timeout events
						window.addEventListener('timeout-update', (e) => this.handleTimeoutUpdate(e.detail));
						window.addEventListener('timeout-cleared', (e) => this.handleTimeoutCleared(e.detail));
						
						// Update elapsed times every second
						this._elapsedInterval = setInterval(() => this.updateElapsedTimes(), 1000);
					},

					// Computed properties
					get selectedCount() {
						return Alpine.store('selection').selected.length;
					},

					get onlineCount() {
						const selected = Alpine.store('selection').selected;
						return selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						}).length;
					},

					get pendingPR() {
						return globalState.pendingPR;
					},

					get hasContent() {
						return this.hoverAction !== null || this.hostnameHover !== null || 
						       this.selectedCount > 0 || this.pendingPR !== null || this.timeouts.length > 0;
					},

					get selectionText() {
						const total = this.selectedCount;
						const online = this.onlineCount;
						if (total === 0) return '';
						const hostWord = total === 1 ? 'host' : 'hosts';
						if (online === total) return `${total} ${hostWord}`;
						return `${total} ${hostWord} (${online} online)`;
					},

					// Hover handlers - P2500: now includes description
					handlePreview(detail) {
						if (this._clearTimer) {
							clearTimeout(this._clearTimer);
							this._clearTimer = null;
						}
						this.hoverAction = {
							command: detail.command,
							hostname: detail.hostname,
							hostId: detail.hostId,
							description: detail.description || ''
						};
					},

					handleClear() {
						// Debounce clearing to prevent flicker
						this._clearTimer = setTimeout(() => {
							this.hoverAction = null;
							this._clearTimer = null;
						}, 200);
					},

					// Hostname hover handlers for copy hint
					handleHostnameHover(detail) {
						if (this._hostnameClearTimer) {
							clearTimeout(this._hostnameClearTimer);
							this._hostnameClearTimer = null;
						}
						this.hostnameHover = detail.hostname;
					},

					handleHostnameClear() {
						this._hostnameClearTimer = setTimeout(() => {
							this.hostnameHover = null;
							this._hostnameClearTimer = null;
						}, 200);
					},

					// P7240: Timeout handlers
					handleTimeoutUpdate(detail) {
						const existing = this.timeouts.find(t => t.hostId === detail.hostId);
						if (existing) {
							existing.state = detail.state;
						} else {
							const timeout = globalState.timeouts.get(detail.hostId);
							if (timeout) {
								this.timeouts.push({
									hostId: detail.hostId,
									hostname: timeout.hostname,
									command: timeout.command,
									startedAt: timeout.startedAt,
									state: timeout.state,
									elapsed: this.formatElapsed(Date.now() - timeout.startedAt)
								});
							}
						}
					},

					handleTimeoutCleared(detail) {
						this.timeouts = this.timeouts.filter(t => t.hostId !== detail.hostId);
					},

					updateElapsedTimes() {
						const now = Date.now();
						this.timeouts.forEach(t => {
							t.elapsed = this.formatElapsed(now - t.startedAt);
						});
					},

					formatElapsed(ms) {
						const seconds = Math.floor(ms / 1000);
						const minutes = Math.floor(seconds / 60);
						const secs = seconds % 60;
						return `${minutes}:${secs.toString().padStart(2, '0')}`;
					},

					timeoutWait(hostId) {
						handleTimeoutAction(hostId, 'wait', 5);
					},

					timeoutKill(hostId) {
						handleTimeoutAction(hostId, 'kill');
					},

					timeoutIgnore(hostId) {
						handleTimeoutAction(hostId, 'ignore');
					},

					// Bulk actions
					bulkCommand(command) {
						const selected = Alpine.store('selection').selected;
						const onlineHostIds = selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						});
						if (onlineHostIds.length === 0) return;
						onlineHostIds.forEach(hostId => sendCommand(hostId, command));
					},

					// Do All: Pull â†’ Switch â†’ Test in sequence, waiting for completion
					async doAll() {
						const selected = Alpine.store('selection').selected;
						let remainingHosts = selected.filter(id => {
							const host = hostStore.get(id);
							return host && host.online;
						});
						if (remainingHosts.length === 0) return;

						// Helper: wait for all hosts to complete a command
						const waitForCompletion = (hostIds, command, timeoutMs = 300000) => {
							return new Promise((resolve) => {
								const pending = new Set(hostIds);
								const results = new Map(); // hostId -> { success, exit_code }
								
								const handler = (e) => {
									const { hostId, command: cmd, exit_code } = e.detail;
									if (cmd === command && pending.has(hostId)) {
										pending.delete(hostId);
										results.set(hostId, { success: exit_code === 0, exit_code });
										if (pending.size === 0) {
											window.removeEventListener('command-complete', handler);
											clearTimeout(timer);
											resolve(results);
										}
									}
								};
								
								window.addEventListener('command-complete', handler);
								
								// Timeout fallback
								const timer = setTimeout(() => {
									window.removeEventListener('command-complete', handler);
									// Mark remaining as failed
									pending.forEach(id => results.set(id, { success: false, exit_code: -1, timeout: true }));
									resolve(results);
								}, timeoutMs);
							});
						};

						// Execute Pull â†’ Switch â†’ Test sequentially
						const commands = ['pull', 'switch', 'test'];
						for (const command of commands) {
							if (remainingHosts.length === 0) break;
							
							// Send command to all remaining hosts
							remainingHosts.forEach(hostId => sendCommand(hostId, command));
							
							// Wait for all to complete
							const results = await waitForCompletion(remainingHosts, command);
							
							// Filter out hosts that failed (don't continue with them)
							remainingHosts = remainingHosts.filter(id => {
								const result = results.get(id);
								return result && result.success;
							});
						}
					},

					// P2500: Merge and deploy PR
					mergeAndDeployPR() {
						if (!this.pendingPR) return;
						mergeAndDeploy(this.pendingPR.number);
					},

					// P2500: Get human-readable PR description for sysop context
					getPRDescription() {
						const pr = this.pendingPR;
						if (!pr) return '';
						
						// Build context-rich description
						const parts = [];
						if (pr.title) {
							parts.push(pr.title);
						} else {
							parts.push('Ready to merge');
						}
						
						// Add info about how many hosts would be affected
						const totalHosts = hostStore.all().length;
						const onlineHosts = hostStore.all().filter(h => h.online).length;
						if (totalHosts > 0) {
							parts.push(`â€¢ will deploy to ${onlineHosts}/${totalHosts} hosts`);
						}
						
						return parts.join(' ');
					},

					clearSelection() {
						Alpine.store('selection').selectNone();
					}
				}));

				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				// DEPENDENCY DIALOG COMPONENT (P1040)
				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				Alpine.data('dependencyDialog', () => ({
					show: false,
					title: '',
					message: '',
					hosts: [],
					executing: false,
					progressText: '',
					cancelled: false,
					_completionHandlers: [],

					init() {
						window.addEventListener('show-dependency-dialog', (e) => this.open(e.detail));
					},

					open(detail) {
						this.title = detail.title;
						this.message = detail.message;
						this.hosts = detail.hosts;
						this.executing = false;
						this.progressText = '';
						this.cancelled = false;
						this.show = true;
					},

					close() {
						if (this.executing) return;
						this.show = false;
						this._cleanup();
					},

					handleEscape() {
						if (this.executing) {
							this.cancelExecution();
						} else {
							this.close();
						}
					},

					async choose(action) {
						switch (action) {
							case 'pull':
								sendCommand(this.hosts[0].id, 'pull');
								this.show = false;
								break;
							case 'switch':
								sendCommand(this.hosts[0].id, 'switch');
								this.show = false;
								break;
							case 'pull-switch':
								await this.executePullThenSwitch([this.hosts[0]]);
								break;
							case 'switch-all':
								this.hosts.forEach(h => sendCommand(h.id, 'switch'));
								this.show = false;
								break;
							case 'pull-switch-all':
								await this.executePullThenSwitch(this.hosts);
								break;
						}
					},

					async executePullThenSwitch(hosts) {
						this.executing = true;
						this.cancelled = false;

						const hostsToPull = hosts.filter(h => h.needsPull);
						const hostsToSwitchOnly = hosts.filter(h => !h.needsPull);

						try {
							if (hostsToPull.length > 0) {
								this.progressText = `Pulling ${hostsToPull.length} host${hostsToPull.length > 1 ? 's' : ''}...`;
								await Promise.all(hostsToPull.map(h => {
									if (this.cancelled) throw new Error('Cancelled');
									return this._sendCommandAndWait(h.id, 'pull');
								}));
							}

							if (this.cancelled) {
								this._showCancelled();
								return;
							}

							const allToSwitch = [...hostsToPull, ...hostsToSwitchOnly];
							this.progressText = `Switching ${allToSwitch.length} host${allToSwitch.length > 1 ? 's' : ''}...`;
							allToSwitch.forEach(h => {
								if (!this.cancelled) sendCommand(h.id, 'switch');
							});

							this.show = false;
							this._cleanup();
						} catch (err) {
							if (err.message === 'Cancelled') {
								this._showCancelled();
							} else {
								console.error('Pull+Switch failed:', err);
								this.progressText = `Error: ${err.message}`;
								setTimeout(() => { this.executing = false; }, 2000);
							}
						}
					},

					cancelExecution() {
						this.cancelled = true;
						this.progressText = 'Cancelling...';
					},

					_showCancelled() {
						this.progressText = 'Cancelled';
						setTimeout(() => {
							this.show = false;
							this.executing = false;
							this._cleanup();
						}, 1000);
					},

					_sendCommandAndWait(hostId, command) {
						return new Promise((resolve, reject) => {
							const handler = (e) => {
								const detail = e.detail;
								if (detail.hostId === hostId) {
									window.removeEventListener('command-complete', handler);
									const idx = this._completionHandlers.indexOf(handler);
									if (idx !== -1) this._completionHandlers.splice(idx, 1);
									if (detail.exit_code === 0) {
										resolve();
									} else {
										reject(new Error(`${command} failed on ${hostId} (exit ${detail.exit_code})`));
									}
								}
							};
							window.addEventListener('command-complete', handler);
							this._completionHandlers.push(handler);
							sendCommand(hostId, command);
						});
					},

					_cleanup() {
						this._completionHandlers.forEach(handler => {
							window.removeEventListener('command-complete', handler);
						});
						this._completionHandlers = [];
					}
				}));
			});

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// DEPENDENCY CHECK HELPER (P1040)
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			function checkDependenciesAndExecute(hostIds, command) {
				if (command !== 'switch') {
					hostIds.forEach(id => sendCommand(id, command));
					return;
				}

				const hostsNeedingPull = [];
				const hostsReady = [];

				hostIds.forEach(id => {
					const host = hostStore.get(id);
					if (!host) return;

					const gitStatus = host.updateStatus?.git?.status;
					if (gitStatus === 'outdated') {
						hostsNeedingPull.push({ id: host.id, hostname: host.hostname, needsPull: true });
					} else {
						hostsReady.push({ id: host.id, hostname: host.hostname, needsPull: false });
					}
				});

				if (hostsNeedingPull.length === 0) {
					hostIds.forEach(id => sendCommand(id, 'switch'));
					return;
				}

				const allHosts = [...hostsNeedingPull, ...hostsReady];
				const isSingle = allHosts.length === 1;

				window.dispatchEvent(new CustomEvent('show-dependency-dialog', {
					detail: {
						title: isSingle
							? `Git is behind on ${allHosts[0].hostname}`
							: `${hostsNeedingPull.length} of ${allHosts.length} hosts need Pull first`,
						message: 'Running Switch without Pull may deploy old code.',
						hosts: allHosts
					}
				}));
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// INIT - P7000
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			hostStore.hydrate();
			connectWebSocket();

			// Update last-seen every second
			setInterval(() => {
				hostStore.all().forEach(host => {
					if (host.lastSeen) {
						const { row, card } = host._elements || {};
						[row, card].filter(Boolean).forEach(el => {
							const cell = el.querySelector('[data-cell="last-seen"]');
							if (cell) {
								const result = formatLastSeen(host.lastSeen);
								cell.textContent = result.text;
								cell.className = result.className;
							}
						});
					}
				});
			}, 1000);

			// P7100: Safety net - refresh all online hosts every 5 minutes
			// Ensures stale data is eventually corrected even if WebSocket messages are missed
			setInterval(() => {
				hostStore.all().filter(h => h.online).forEach(host => {
					refreshHost(host.id);
				});
			}, 5 * 60 * 1000);
		</script>
	}
}

// P2500: ContextBar - Unified bar with stacked rows for PR, hover, and selection
templ ContextBar() {
	<div
		id="context-bar"
		class="context-bar"
		x-data="contextBar"
		:class="{ 'context-bar-empty': !hasContent }"
	>
		<!-- Row 1: PR info (when pending PR) -->
		<template x-if="pendingPR && pendingPR.mergeable">
			<div class="context-row context-row-pr">
				<div class="context-row-info">
					<svg class="icon icon-pr"><use href="#icon-git-pull-request"></use></svg>
					<span class="pr-label">PR #<span x-text="pendingPR.number"></span></span>
					<span class="pr-detail" x-text="getPRDescription()"></span>
				</div>
				<button class="btn btn-merge" @click="mergeAndDeployPR()">
					<svg class="icon"><use href="#icon-git-merge"></use></svg>
					<span>Merge & Deploy</span>
				</button>
			</div>
		</template>

		<!-- Row 2: Hover context (when hovering a compartment) -->
		<template x-if="hoverAction">
			<div class="context-row context-row-hover">
				<span class="context-host" x-text="hoverAction.hostname"></span>
				<span class="context-description" x-text="hoverAction.description"></span>
			</div>
		</template>

		<!-- Row 2b: Hostname copy hint (when hovering hostname) -->
		<template x-if="hostnameHover && !hoverAction">
			<div class="context-row context-row-hover">
				<span class="context-host" x-text="hostnameHover"></span>
				<span class="context-description">Click to copy hostname</span>
			</div>
		</template>

		<!-- Row 3: Selection + Actions (when hosts selected) -->
		<template x-if="$store.selection.selected.length > 0">
			<div class="context-row context-row-selection">
				<div class="context-row-info">
					<svg class="icon icon-check"><use href="#icon-check-square"></use></svg>
					<span x-text="selectionText"></span>
				</div>
				<div class="context-actions">
					<button
						class="btn btn-context"
						:disabled="onlineCount === 0"
						@click="bulkCommand('pull')"
					>
						<svg class="icon"><use href="#icon-download"></use></svg>
						<span class="btn-label">Pull</span>
					</button>
					<button
						class="btn btn-context"
						:disabled="onlineCount === 0"
						@click="bulkCommand('switch')"
					>
						<svg class="icon"><use href="#icon-refresh"></use></svg>
						<span class="btn-label">Switch</span>
					</button>
					<button
						class="btn btn-context"
						:disabled="onlineCount === 0"
						@click="bulkCommand('test')"
					>
						<svg class="icon"><use href="#icon-flask"></use></svg>
						<span class="btn-label">Test</span>
					</button>
					<button
						class="btn btn-primary btn-do-all"
						:disabled="onlineCount === 0"
						@click="doAll()"
					>
						<svg class="icon"><use href="#icon-play"></use></svg>
						<span class="btn-label">Do All</span>
					</button>
					<button
						class="btn btn-clear"
						@click="clearSelection()"
					>
						<svg class="icon"><use href="#icon-x"></use></svg>
					</button>
				</div>
			</div>
		</template>

		<!-- P7240: Timeout notifications (stacked) -->
		<template x-for="timeout in timeouts" :key="timeout.hostId">
			<div class="context-row context-row-timeout">
				<div class="context-row-info">
					<svg class="icon timeout-icon"><use href="#icon-alert-triangle"></use></svg>
					<span class="timeout-host" x-text="timeout.hostname"></span>
					<span class="timeout-detail">
						<span x-text="timeout.command"></span> timed out
					</span>
					<span class="timeout-elapsed" x-text="timeout.elapsed"></span>
				</div>
				<div class="timeout-actions">
					<button class="btn-timeout btn-timeout-wait" @click="timeoutWait(timeout.hostId)">
						Wait 5m
					</button>
					<button class="btn-timeout btn-timeout-kill" @click="timeoutKill(timeout.hostId)">
						Kill
					</button>
					<button class="btn-timeout btn-timeout-ignore" @click="timeoutIgnore(timeout.hostId)">
						Ã—
					</button>
				</div>
			</div>
		</template>
	</div>
}

// DependencyDialog renders the dependency warning modal (P1040)
templ DependencyDialog() {
	<div
		id="dependency-dialog"
		class="modal-overlay"
		x-data="dependencyDialog"
		x-show="show"
		x-cloak
		@keydown.escape.window="handleEscape()"
		@click.self="close()"
	>
		<div class="modal dialog-modal" @click.stop>
			<div class="dialog-header">
				<svg class="dialog-icon warning"><use href="#icon-alert-triangle"></use></svg>
				<h3 class="dialog-title" x-text="title"></h3>
			</div>

			<div class="dialog-body">
				<p class="dialog-message" x-text="message"></p>

				<!-- Host list for multi-host -->
				<template x-if="hosts.length > 1">
					<ul class="dialog-host-list">
						<template x-for="host in hosts" :key="host.id">
							<li :class="{ 'needs-action': host.needsPull }">
								<span class="host-name" x-text="host.hostname"></span>
								<span class="host-status" x-text="host.needsPull ? 'Git is behind' : 'OK (will switch)'"></span>
							</li>
						</template>
					</ul>
				</template>
			</div>

			<div class="dialog-footer">
				<button type="button" class="btn btn-cancel" @click="close()">
					Cancel
				</button>

				<div class="dialog-actions">
					<!-- Single-host buttons -->
					<template x-if="hosts.length === 1">
						<div class="dialog-action-group">
							<button type="button" class="btn" @click="choose('pull')">
								Pull Only
							</button>
							<button type="button" class="btn" @click="choose('switch')">
								Switch Anyway
							</button>
							<button type="button" class="btn btn-primary" @click="choose('pull-switch')">
								Pull + Switch
							</button>
						</div>
					</template>

					<!-- Multi-host buttons -->
					<template x-if="hosts.length > 1">
						<div class="dialog-action-group">
							<button type="button" class="btn" @click="choose('switch-all')">
								Switch All Anyway
							</button>
							<button type="button" class="btn btn-primary" @click="choose('pull-switch-all')">
								Pull + Switch All
							</button>
						</div>
					</template>
				</div>
			</div>

			<!-- Progress overlay -->
			<div class="dialog-progress" x-show="executing" x-cloak>
				<div class="progress-content">
					<svg class="icon spinning"><use href="#icon-loader"></use></svg>
					<span x-text="progressText"></span>
					<button type="button" class="btn btn-cancel-small" @click="cancelExecution()">
						Cancel
					</button>
				</div>
			</div>
		</div>
	</div>
}

// FleetTargetLine renders the fleet target info in the header
templ FleetTargetLine(target FleetTarget) {
	<div class="fleet-target">
		<!-- Agent version always shown first -->
		<span class="target-agent-label">Agent:</span>
		<span class="target-agent" title={ "Expected agent version: " + target.AgentVer }>{ target.AgentVer }</span>
		if target.HasData {
			<span class="target-separator">â€¢</span>
			<span class="target-label">Config:</span>
			<svg class="target-icon"><use href="#icon-git-branch"></use></svg>
			<a
				href={ templ.SafeURL("https://github.com/" + target.RepoURL + "/commit/" + target.GitFull) }
				target="_blank"
				rel="noopener"
				class="target-commit"
				title={ "Latest commit: " + target.Message }
			>
				{ target.GitCommit }
			</a>
			<span class="target-branch">({ target.Branch }, { target.TimeAgo })</span>
		}
	</div>
}

// P7000: FlakeUpdateBanner removed - functionality moved to Bulk Actions dropdown

// HostCard renders a host as a card (mobile view)
templ HostCard(host Host, csrfToken string) {
	<div class={ "host-card", templ.KV("host-offline", !host.Online) } data-host-id={ host.ID } x-data="{ expanded: false }">
		<div class="host-card-header" @click="expanded = !expanded">
			<div class="host-name">
				<span class="status-with-badge">
					@StatusIndicator(host)
					if host.PendingCommand != "" {
						<span class="progress-badge-mini">{ host.PendingCommand }</span>
					}
				</span>
				<span
					class="hostname hostname-copyable"
					style={ hostnameColorStyle(host.ThemeColor) }
					data-hostname={ host.Hostname }
					@mouseenter="$dispatch('hostname-hover', { hostname: $el.dataset.hostname })"
					@mouseleave="$dispatch('hostname-clear')"
					@click.stop="copyHostname($el.dataset.hostname)"
					title="Click to copy hostname"
				>{ host.Hostname }</span>
			</div>
			<span class="chevron" :class="{ 'expanded': expanded }">â–¼</span>
		</div>
		<div class="host-card-body" x-show="expanded">
			<div class="host-card-row">
				<span class="host-card-label">Type</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@osTypeIcon(host.HostType)
					{ host.HostType }
				</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Location</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@locationIcon(host.Location)
					{ host.Location }
				</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Device</span>
				<span style="display: flex; align-items: center; gap: 0.5rem;">
					@deviceTypeIcon(host.DeviceType)
					{ host.DeviceType }
				</span>
			</div>
			if host.Metrics != nil {
				<div class="host-card-row">
					<span class="host-card-label">Metrics</span>
					<span class="metrics-cell">
						<span class={ metricsClass("cpu", host.Metrics.CPU) }><svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.CPU) }</span></span>
						<span class={ metricsClass("ram", host.Metrics.RAM) }><svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.RAM) }</span></span>
						<span class="metric"><span class="metric-val">{ formatLoad(host.Metrics.Load) }</span></span>
					</span>
				</div>
			}
			if host.TestProgress != nil {
				<div class="host-card-row">
					<span class="host-card-label">Tests</span>
					@TestsCell(host.TestProgress)
				</div>
			}
			<div class="host-card-row">
				<span class="host-card-label">OS Version</span>
				<span>{ valueOrDash(host.OSVersion) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Generation</span>
				<span>{ valueOrDash(host.Generation) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Agent</span>
				<span>{ valueOrDash(host.AgentVersion) }</span>
			</div>
			<div class="host-card-row">
				<span class="host-card-label">Last Seen</span>
				<span data-cell="last-seen" data-timestamp={ host.LastSeen }>{ valueOrDash(host.LastSeen) }</span>
			</div>
			<div class="host-card-actions">
				@CommandButton(host.ID, "pull", "Pull", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "switch", "Switch", "btn", host.Online && host.PendingCommand == "")
				@CommandButton(host.ID, "test", "Test", "btn", host.Online && host.PendingCommand == "")
				@DeleteButton(host.ID, !host.Online)
			</div>
		</div>
	</div>
}

// HostRow renders a host as a table row (desktop view)
// P7000: data-* attributes for client-side hydration
// P1030: x-data for Alpine.js selection bindings
templ HostRow(host Host, csrfToken string) {
	<tr
		data-host-id={ host.ID }
		data-hostname={ host.Hostname }
		data-host-type={ host.HostType }
		data-theme-color={ host.ThemeColor }
		data-generation={ host.Generation }
		data-agent-version={ host.AgentVersion }
		data-agent-outdated={ strconv.FormatBool(host.AgentOutdated) }
		data-pending-command={ host.PendingCommand }
		data-available-ops={ marshalJSON(host.AvailableOps) }
		class={ templ.KV("host-offline", !host.Online) }
		style={ hostRowStyle(host) }
		x-data
		x-bind:class={ selectionClassBinding(host.ID) }
	>
		<!-- P7230: Selection checkbox moved to first column -->
		<td class="col-select">
			<button
				type="button"
				class="select-toggle row-select-toggle"
				@click={ checkboxClickHandler(host.ID) }
				x-bind:class={ rowSelectedClass(host.ID) }
				title="Select host"
			>
				<svg class="icon" x-bind:style={ iconVisibility(host.ID, false) }><use href="#icon-square"></use></svg>
				<svg class="icon" x-bind:style={ iconVisibility(host.ID, true) }><use href="#icon-check-square"></use></svg>
			</button>
		</td>
		<td class="status-cell-with-badge">
			<span class="status-wrapper">
				@StatusIndicator(host)
				<!-- P7230: Device type icon prefix before hostname -->
				<span class="hostname-device-icon" style={ typeIconColorStyle(host.ThemeColor) }>
					@deviceTypeIcon(host.DeviceType)
				</span>
				<span
					class="hostname hostname-copyable"
					style={ hostnameColorStyle(host.ThemeColor) }
					data-hostname={ host.Hostname }
					@mouseenter="$dispatch('hostname-hover', { hostname: $el.dataset.hostname })"
					@mouseleave="$dispatch('hostname-clear')"
					@click.stop="copyHostname($el.dataset.hostname)"
					title="Click to copy hostname"
				>{ host.Hostname }</span>
				if host.PendingCommand != "" {
					<span class="progress-badge-mini">{ host.PendingCommand }</span>
				}
			</span>
		</td>
		<!-- P2700: Composite TYPE column (Location + Device + OS) -->
		<td class="col-center col-type">
			@CompositeTypeCell(host)
		</td>
		<td class="metrics-cell" data-cell="metrics">
			if host.Metrics != nil {
				<span class={ metricsClass("cpu", host.Metrics.CPU) } data-metric="cpu" title={ "CPU: " + formatPercent(host.Metrics.CPU) }>
					<svg class="metric-icon"><use href="#icon-cpu"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.CPU) }</span>
				</span>
				<span class={ metricsClass("ram", host.Metrics.RAM) } data-metric="ram" title={ "RAM: " + formatPercent(host.Metrics.RAM) + ", Swap: " + formatPercent(host.Metrics.Swap) + ", Load: " + formatLoad(host.Metrics.Load) }>
					<svg class="metric-icon"><use href="#icon-ram"></use></svg><span class="metric-val">{ formatPercent(host.Metrics.RAM) }</span>
				</span>
			} else {
				<span class="metrics-na">â€”</span>
			}
		</td>
		<td class="col-right col-last-seen" data-cell="last-seen" data-timestamp={ host.LastSeen }>{ valueOrDash(host.LastSeen) }</td>
		<td class="agent-version-cell" data-cell="agent-version">
			@AgentVersionCell(host)
		</td>
		<td class="status-cell" data-cell="status">
			@UpdateStatusCell(host)
		</td>
		<td class="col-menu">
			@ActionDropdown(host)
		</td>
	</tr>
}

// StatusIndicator renders the appropriate status indicator (ripple for online, dot for offline)
templ StatusIndicator(host Host) {
	if host.Online && host.PendingCommand == "" {
		<span class="status-ripple">
			<span class="hb-wave"></span>
			<span class="hb-wave"></span>
			<span class="hb-wave"></span>
			<span class="hb-core"></span>
		</span>
	} else if host.PendingCommand != "" {
		<span class="status-dot status-running"></span>
	} else {
		<span class="status-dot status-offline"></span>
	}
}

// CommandButton renders a command button with proper onclick handling and SVG icon
templ CommandButton(hostID, command, label, classes string, enabled bool) {
	if enabled {
		<button 
			class={ classes }
			data-host-id={ hostID }
			data-command={ command }
			onclick="sendCommand(this.dataset.hostId, this.dataset.command)"
			title={ commandTitle(command) }
		>
			@commandIcon(command)
			if label != "" {
				{ label }
			}
		</button>
	} else {
		<button class={ classes } disabled title={ commandTitle(command) }>
			@commandIcon(command)
			if label != "" {
				{ label }
			}
		</button>
	}
}

// commandTitle returns a human-readable title for button tooltips
func commandTitle(command string) string {
	switch command {
	case "pull":
		return "Pull latest code from Git"
	case "switch":
		return "Apply configuration (nixos-rebuild switch)"
	case "test":
		return "Test configuration (nixos-rebuild test)"
	case "stop":
		return "Stop running command"
	default:
		return command
	}
}

// commandIcon renders the SVG icon for a command
templ commandIcon(command string) {
	switch command {
		case "pull":
			<svg class="icon"><use href="#icon-download"></use></svg>
		case "switch":
			<svg class="icon"><use href="#icon-refresh"></use></svg>
		case "test":
			<svg class="icon"><use href="#icon-flask"></use></svg>
		case "stop":
			<svg class="icon"><use href="#icon-stop"></use></svg>
		default:
			// No icon for unknown commands
	}
}

// osTypeIcon renders the OS type icon (NixOS or macOS)
templ osTypeIcon(hostType string) {
	switch hostType {
		case "nixos":
			<svg class="icon type-icon" title="NixOS"><use href="#icon-nixos"></use></svg>
		case "macos":
			<svg class="icon type-icon" title="macOS"><use href="#icon-apple"></use></svg>
		default:
			<span>{ hostType }</span>
	}
}

// locationIcon renders the location icon
templ locationIcon(location string) {
	switch location {
		case "home":
			<svg class="icon location-icon" title="Home"><use href="#icon-home"></use></svg>
		case "work":
			<svg class="icon location-icon" title="Work"><use href="#icon-office"></use></svg>
		case "cloud":
			<svg class="icon location-icon" title="Cloud"><use href="#icon-cloud"></use></svg>
		default:
			<svg class="icon location-icon" title="Home"><use href="#icon-home"></use></svg>
	}
}

// deviceTypeIcon renders the device type icon
templ deviceTypeIcon(deviceType string) {
	switch deviceType {
		case "server":
			<svg class="icon device-icon" title="Server"><use href="#icon-server"></use></svg>
		case "desktop":
			<svg class="icon device-icon" title="Desktop"><use href="#icon-desktop"></use></svg>
		case "laptop":
			<svg class="icon device-icon" title="Laptop"><use href="#icon-laptop"></use></svg>
		case "gaming":
			<svg class="icon device-icon" title="Gaming"><use href="#icon-game"></use></svg>
		default:
			<svg class="icon device-icon" title="Desktop"><use href="#icon-desktop"></use></svg>
	}
}

// TestsCell renders the test progress/results cell
templ TestsCell(progress *TestProgress) {
	if progress != nil {
		if progress.Running {
			<span class="test-progress">{ strconv.Itoa(progress.Current) }/{ strconv.Itoa(progress.Total) }</span>
		} else if progress.Result != "" {
			if progress.Passed == progress.Total {
				<span class="test-result pass">{ progress.Result }</span>
			} else {
				<span class="test-result fail">{ progress.Result }</span>
			}
		} else {
			<span class="tests-na">â€”</span>
		}
	} else {
		<span class="tests-na">â€”</span>
	}
}

// P2700: CompositeTypeCell renders the combined Location/Device/OS type cell
// Main icon is device type, superscript is location, subscript is OS
// All icons use 100% primary host theme color
templ CompositeTypeCell(host Host) {
	<div
		class="type-composite type-compact"
		data-host-id={ host.ID }
		data-location={ host.Location }
		data-device={ host.DeviceType }
		data-os={ host.HostType }
		title={ compositeTypeTitle(host) }
		style={ typeIconColorStyle(host.ThemeColor) }
	>
		<!-- LOC icon (left) -->
		<span class="type-loc-icon">
			@locationIcon(host.Location)
		</span>
		<!-- OS icon (right) -->
		<span class="type-os-icon">
			@osTypeIcon(host.HostType)
		</span>
	</div>
}

// typeIconColorStyle returns inline style for type column icons
func typeIconColorStyle(themeColor string) string {
	if themeColor == "" {
		themeColor = "#7aa2f7" // Default blue
	}
	return fmt.Sprintf("--type-color: %s", themeColor)
}

// hostnameColorStyle returns inline style for hostname text color
func hostnameColorStyle(themeColor string) string {
	if themeColor == "" {
		themeColor = "#7aa2f7" // Default blue
	}
	return fmt.Sprintf("color: %s", themeColor)
}

// P2700: StatusProgressCell renders the segmented progress bar + test results
templ StatusProgressCell(host Host) {
	<div
		class="status-progress"
		data-host-id={ host.ID }
		data-pending={ host.PendingCommand }
	>
		<!-- PULL segment (4 dots) -->
		<span class="progress-segment segment-pull" data-phase="pull">
			@progressDots(getPhaseProgress(host.OperationProgress, "pull"), 4)
		</span>
		<!-- LOCK segment (2 dots) -->
		<span class="progress-segment segment-lock" data-phase="lock">
			@progressDots(getPhaseProgress(host.OperationProgress, "lock"), 2)
		</span>
		<!-- SYSTEM segment (3 dots) -->
		<span class="progress-segment segment-system" data-phase="system">
			@progressDots(getPhaseProgress(host.OperationProgress, "system"), 3)
		</span>
		<!-- TESTS segment (variable, max 8) -->
		<span class="progress-segment segment-tests" data-phase="tests">
			@testsDots(host)
		</span>
	</div>
}

// progressDots renders dots for a progress phase
templ progressDots(progress *PhaseProgress, total int) {
	for i := 0; i < total; i++ {
		<span class={ progressDotClass(progress, i) }>{ progressDotChar(progress, i) }</span>
	}
}

// testsDots renders dots for test results
templ testsDots(host Host) {
	if host.TestProgress != nil && host.TestProgress.Total > 0 {
		for i := 0; i < minInt(host.TestProgress.Total, 8); i++ {
			<span class={ testDotClass(host.TestProgress, i) }>{ testDotChar(host.TestProgress, i) }</span>
		}
	} else if host.OperationProgress != nil && host.OperationProgress.Tests != nil {
		for i := 0; i < minInt(host.OperationProgress.Tests.Total, 8); i++ {
			<span class={ operationTestDotClass(host.OperationProgress.Tests, i) }>{ operationTestDotChar(host.OperationProgress.Tests, i) }</span>
		}
	} else {
		<span class="tests-dash">â€”</span>
	}
}

// AgentVersionCell renders the agent version with status indicator
templ AgentVersionCell(host Host) {
	<span class={ agentVersionCellClass(host) } title={ agentContextDescription(host) }>
		{ valueOrDash(host.AgentVersion) }
	</span>
}

// UpdateStatusCell renders the status compartments (Agent/Git/Lock/System)
// P7300: Single dot per compartment with 5 color states
// Colors: gray (unchecked), blue-pulse (working), green (ok), yellow (warning), red (error)
templ UpdateStatusCell(host Host) {
	<div
		class="update-status"
		data-host-id={ host.ID }
		data-git={ updateStatusJSON(host.UpdateStatus, "git") }
		data-lock={ updateStatusJSON(host.UpdateStatus, "lock") }
		data-system={ updateStatusJSON(host.UpdateStatus, "system") }
		data-repo-url={ host.RepoURL }
		data-repo-dir={ host.RepoDir }
	>
		<!-- Agent compartment -->
		<button
			type="button"
			class={ agentCompartmentButtonClass(host) }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="agent"
			data-status={ getAgentStatus(host) }
			data-action="info"
			data-description={ agentContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			<svg class="update-icon"><use href="#icon-robot"></use></svg>
			<span class={ agentIndicatorClass(host) }></span>
		</button>
		<!-- Git compartment -->
		<button
			type="button"
			class={ compartmentButtonClass(host.UpdateStatus, "git") }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="git"
			data-status={ getCompartmentStatus(host.UpdateStatus, "git") }
			data-action={ getCompartmentActionType(host.UpdateStatus, "git") }
			data-description={ gitContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			<svg class="update-icon"><use href="#icon-git-branch"></use></svg>
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "git") }></span>
		</button>
		<!-- Lock compartment -->
		<button
			type="button"
			class={ lockCompartmentButtonClass(host) }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="lock"
			data-status={ getLockStatus(host) }
			data-action={ getLockActionType(host) }
			data-description={ lockContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			<svg class="update-icon"><use href="#icon-lock"></use></svg>
			<span class={ lockIndicatorClass(host) }></span>
		</button>
		<!-- System compartment -->
		<button
			type="button"
			class={ compartmentButtonClass(host.UpdateStatus, "system") }
			data-host-id={ host.ID }
			data-hostname={ host.Hostname }
			data-compartment="system"
			data-status={ getCompartmentStatus(host.UpdateStatus, "system") }
			data-action={ getCompartmentActionType(host.UpdateStatus, "system") }
			data-description={ systemContextDescription(host) }
			onmouseenter="handleCompartmentHover(this)"
			onmouseleave="handleCompartmentLeave()"
			onclick="handleCompartmentClick(this)"
		>
			if host.HostType == "macos" {
				<svg class="update-icon"><use href="#icon-home"></use></svg>
			} else {
				<svg class="update-icon"><use href="#icon-nixos"></use></svg>
			}
			<span class={ compartmentIndicatorClass(host.UpdateStatus, "system") }></span>
		</button>
	</div>
}

// ActionDropdown renders the per-host action dropdown menu
// P1060: ActionDropdown with reorganized menu (Test at top, grouped items)
// P2100: Added keyboard navigation (arrow keys, escape)
templ ActionDropdown(host Host) {
	<div class="dropdown" x-data="{
		open: false,
		focusedIndex: -1,
		get items() { return [...this.$refs.menu.querySelectorAll('.dropdown-item:not([disabled])')]; },
		focusItem(idx) {
			const items = this.items;
			if (items.length === 0) return;
			this.focusedIndex = ((idx % items.length) + items.length) % items.length;
			items[this.focusedIndex].focus();
		},
		toggle() {
			this.open = !this.open;
			if (this.open) {
				this.$nextTick(() => this.focusItem(0));
			} else {
				this.focusedIndex = -1;
			}
		}
	}">
		<button
			type="button"
			class="dropdown-toggle"
			@click="toggle()"
			@click.outside="open = false; focusedIndex = -1"
			@keydown.arrow-down.prevent="if (!open) { toggle() } else { focusItem(focusedIndex + 1) }"
			@keydown.escape.prevent="open = false; focusedIndex = -1"
			title="More actions"
		>
			<svg class="icon"><use href="#icon-more-vertical"></use></svg>
		</button>
		<div class="dropdown-menu" x-ref="menu" x-show="open" x-cloak
			@keydown.arrow-down.prevent="focusItem(focusedIndex + 1)"
			@keydown.arrow-up.prevent="focusItem(focusedIndex - 1)"
			@keydown.escape.prevent="open = false; focusedIndex = -1; $el.previousElementSibling.focus()"
			@keydown.tab="open = false; focusedIndex = -1"
			@click="open = false; focusedIndex = -1">
		<!-- P2500: Deployment Group -->
		<!-- P5100: Server-driven UI - buttons disabled based on availableOps -->
		<button
			type="button"
			class="dropdown-item"
			onclick={ sendCommandScript(host.ID, "pull") }
			disabled?={ !isOpAvailable(host, "pull") }
		>
			<svg class="icon"><use href="#icon-download"></use></svg>
			<span>Pull</span>
		</button>
		<button
			type="button"
			class="dropdown-item"
			onclick={ sendCommandScript(host.ID, "switch") }
			disabled?={ !isOpAvailable(host, "switch") }
		>
			<svg class="icon"><use href="#icon-refresh"></use></svg>
			<span>Switch</span>
		</button>
		<button
			type="button"
			class="dropdown-item"
			onclick={ sendCommandScript(host.ID, "test") }
			disabled?={ !isOpAvailable(host, "test") }
		>
			<svg class="icon"><use href="#icon-flask"></use></svg>
			<span>Test</span>
		</button>
			if host.PendingCommand != "" {
				<button
					type="button"
					class="dropdown-item"
					onclick={ sendCommandScript(host.ID, "stop") }
				>
					<svg class="icon"><use href="#icon-stop"></use></svg>
					<span>Stop</span>
				</button>
			}
			<hr class="dropdown-divider"/>
		<!-- P2500: Management Group -->
		<!-- P5100: Server-driven UI - buttons disabled based on availableOps -->
		<button
			type="button"
			class="dropdown-item"
			onclick={ sendCommandScript(host.ID, "restart") }
			disabled?={ !host.Online }
		>
			<svg class="icon"><use href="#icon-refresh-cw"></use></svg>
			<span>Restart Agent</span>
		</button>
		<!-- P6900: Reboot Host (requires TOTP) -->
		<button
			type="button"
			class="dropdown-item danger"
			onclick={ showRebootModalScript(host.ID, host.Hostname) }
			disabled?={ !isOpAvailable(host, "reboot") }
		>
			<svg class="icon"><use href="#icon-power"></use></svg>
			<span>Reboot Host</span>
		</button>
		<!-- P7200: Force Update Agent (when agent is outdated) -->
		if host.AgentOutdated {
			<button
				type="button"
				class="dropdown-item warning"
				onclick={ sendCommandScript(host.ID, "force-update") }
				disabled?={ !host.Online }
			>
				<svg class="icon"><use href="#icon-alert-triangle"></use></svg>
				<span>Force Update Agent</span>
			</button>
		}
			<hr class="dropdown-divider"/>
			<!-- P2950: Color picker -->
			<button
				type="button"
				class="dropdown-item"
				onclick={ openColorPickerScript(host.ID, host.Hostname, host.ThemeColor) }
			>
				<svg class="icon"><use href="#icon-palette"></use></svg>
				<span>Change Color</span>
			</button>
			<hr class="dropdown-divider"/>
			<!-- P2500: Diagnostics Group -->
			<button
				type="button"
				class="dropdown-item"
				onclick={ showLogsScript(host.ID) }
			>
				<svg class="icon"><use href="#icon-terminal"></use></svg>
				<span>View Output</span>
			</button>
			<button
				type="button"
				class="dropdown-item"
				onclick={ downloadLogsScript(host.ID) }
			>
				<svg class="icon"><use href="#icon-file"></use></svg>
				<span>Download Logs</span>
			</button>
			<hr class="dropdown-divider"/>
			<!-- P2500: Danger Zone -->
			<button
				type="button"
				class="dropdown-item danger"
				onclick={ removeHostScript(host.ID, host.Hostname) }
			>
				<svg class="icon"><use href="#icon-trash"></use></svg>
				<span>Remove Host</span>
			</button>
		</div>
	</div>
}

// P1060: Script helpers for ActionDropdown
func sendCommandScript(hostID, command string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("sendCommand('%s', '%s')", hostID, command)}
}

// P5100: Check if an operation is available for a host (server-side logic)
func isOpAvailable(host Host, op string) bool {
	for _, availableOp := range host.AvailableOps {
		if availableOp == op {
			return true
		}
	}
	return false
}

// P5100: Marshal to JSON for data attributes
func marshalJSON(v any) string {
	b, err := json.Marshal(v)
	if err != nil {
		return "[]"
	}
	return string(b)
}

func copyHostnameScript(hostname string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("copyToClipboard('%s', 'Hostname copied')", hostname)}
}

func copySSHScript(host Host) templ.ComponentScript {
	user := "mba"
	if host.HostType == "macos" {
		user = "markus"
	}
	sshCmd := fmt.Sprintf("ssh %s@%s", user, host.Hostname)
	return templ.ComponentScript{Call: fmt.Sprintf("copyToClipboard('%s', 'SSH command copied')", sshCmd)}
}

func downloadLogsScript(hostID string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("downloadLogs('%s')", hostID)}
}

func showLogsScript(hostID string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("showLogPanel('%s')", hostID)}
}

func removeHostScript(hostID, hostname string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("confirmRemoveHost('%s', '%s')", hostID, hostname)}
}

// P2950: Open color picker modal
func openColorPickerScript(hostID, hostname, currentColor string) templ.ComponentScript {
	if currentColor == "" {
		currentColor = "#7aa2f7" // Default blue
	}
	return templ.ComponentScript{Call: fmt.Sprintf("openColorPicker('%s', '%s', '%s')", hostID, hostname, currentColor)}
}

// P6900: Open reboot confirmation modal with TOTP
func showRebootModalScript(hostID, hostname string) templ.ComponentScript {
	return templ.ComponentScript{Call: fmt.Sprintf("showRebootModal('%s', '%s')", hostID, hostname)}
}

// DeleteButton renders a delete button for offline hosts
templ DeleteButton(hostID string, enabled bool) {
	if enabled {
		<button 
			class="btn btn-danger"
			data-host-id={ hostID }
			onclick="deleteHost(this.dataset.hostId)"
			title="Delete offline host"
		>
			<svg class="icon"><use href="#icon-trash"></use></svg>
		</button>
	} else {
		<button class="btn btn-danger" disabled title="Cannot delete online host">
			<svg class="icon"><use href="#icon-trash"></use></svg>
		</button>
	}
}

// Helper functions
func statusClass(host Host) string {
	if host.PendingCommand != "" {
		return "status-running"
	}
	if host.Online {
		return "status-online"
	}
	return "status-offline"
}

func hostColorStyle(host Host) string {
	if host.ThemeColor != "" {
		return "color: " + host.ThemeColor
	}
	return ""
}

// hostRowStyle returns inline CSS for row gradient background using host's theme color
func hostRowStyle(host Host) string {
	if host.ThemeColor == "" {
		return ""
	}
	// Convert hex to RGB for rgba() usage
	rgb := hexToRGB(host.ThemeColor)
	if rgb == "" {
		return ""
	}
	// Gradient: 0% (2%) â†’ 25% (10%) â†’ 50% (2%) â†’ 100% (0%) - subtle tint
	return fmt.Sprintf("background: linear-gradient(to right, rgba(%s, 0.02) 0%%, rgba(%s, 0.10) 25%%, rgba(%s, 0.02) 50%%, transparent 100%%)", rgb, rgb, rgb)
}

// hexToRGB converts hex color (#rrggbb or #rgb) to "r, g, b" string for rgba()
func hexToRGB(hex string) string {
	hex = strings.TrimPrefix(hex, "#")
	if len(hex) == 3 {
		// Expand #rgb to #rrggbb
		hex = string(hex[0]) + string(hex[0]) + string(hex[1]) + string(hex[1]) + string(hex[2]) + string(hex[2])
	}
	if len(hex) != 6 {
		return ""
	}
	r, err1 := strconv.ParseInt(hex[0:2], 16, 64)
	g, err2 := strconv.ParseInt(hex[2:4], 16, 64)
	b, err3 := strconv.ParseInt(hex[4:6], 16, 64)
	if err1 != nil || err2 != nil || err3 != nil {
		return ""
	}
	return fmt.Sprintf("%d, %d, %d", r, g, b)
}

func valueOrDash(v string) string {
	if v == "" {
		return "â€”"
	}
	return v
}

// visibleWhen returns CSS display style based on condition
func visibleWhen(visible bool) string {
	if visible {
		return ""
	}
	return "display: none"
}

// P1030: Helper functions for Alpine.js selection bindings
func selectionClassBinding(hostID string) string {
	return fmt.Sprintf("{ 'selected': $store.selection.isSelected('%s') }", hostID)
}

func checkboxClickHandler(hostID string) string {
	return fmt.Sprintf("handleCheckboxClick($event, '%s')", hostID)
}

func rowSelectedClass(hostID string) string {
	return fmt.Sprintf("{ 'is-selected': $store.selection.isSelected('%s') }", hostID)
}

func iconVisibility(hostID string, checked bool) string {
	if checked {
		return fmt.Sprintf("$store.selection.isSelected('%s') ? '' : 'display: none'", hostID)
	}
	return fmt.Sprintf("$store.selection.isSelected('%s') ? 'display: none' : ''", hostID)
}

func formatPercent(v float64) string {
	return strconv.FormatFloat(v, 'f', 0, 64) + "%"
}

func formatLoad(v float64) string {
	return strconv.FormatFloat(v, 'f', 2, 64)
}

func metricsClass(metricType string, value float64) string {
	base := "metric " + metricType
	if value >= 80 {
		return base + " high"
	}
	return base
}

// updateCompartmentClass returns CSS classes for an update status compartment
// P5100: Simplified - only indicator dot shows status, compartment styling is constant
func updateCompartmentClass(status *UpdateStatus, compartment string) string {
	base := "update-compartment"
	if status == nil {
		return base + " unknown" // Slightly dimmed for stale/unknown data
	}
	
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	
	// Only add "unknown" class for dimming effect, all other states look the same
	if check.Status == "" || check.Status == "unknown" {
		return base + " unknown"
	}
	return base
}

// compartmentIndicatorClass returns CSS classes for the status indicator dot
// P7300: Single dot with 5 states: gray, working, ok, warning, error
func compartmentIndicatorClass(status *UpdateStatus, compartment string) string {
	base := "compartment-indicator"
	if status == nil {
		return base + " compartment-indicator--gray"
	}
	
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	
	switch check.Status {
	case "ok":
		return base + " compartment-indicator--ok"
	case "outdated":
		return base + " compartment-indicator--warning"
	case "error":
		return base + " compartment-indicator--error"
	case "working":
		return base + " compartment-indicator--working"
	default:
		return base + " compartment-indicator--gray"
	}
}

// lockCompartmentClass returns CSS classes for Lock compartment
// P5100: Simplified - only indicator dot shows status (including agent outdated)
func lockCompartmentClass(host Host) string {
	base := "update-compartment"
	
	// Only add "unknown" class for dimming effect when no status data
	if host.UpdateStatus == nil {
		return base + " unknown"
	}
	
	if host.UpdateStatus.Lock.Status == "" || host.UpdateStatus.Lock.Status == "unknown" {
		return base + " unknown"
	}
	return base
}

// lockIndicatorClass returns CSS classes for Lock indicator dot (worst status wins)
func lockIndicatorClass(host Host) string {
	base := "compartment-indicator"
	
	// Agent outdated = error (red) - this is the worst status
	if host.AgentOutdated {
		return base + " compartment-indicator--error"
	}
	
	if host.UpdateStatus == nil {
		return base + " compartment-indicator--gray"
	}
	
	switch host.UpdateStatus.Lock.Status {
	case "ok":
		return base + " compartment-indicator--ok"
	case "outdated":
		return base + " compartment-indicator--warning"
	case "error":
		return base + " compartment-indicator--error"
	case "working":
		return base + " compartment-indicator--working"
	default:
		return base + " compartment-indicator--gray"
	}
}

// P7300: Agent version cell and compartment helper functions

// agentVersionCellClass returns CSS classes for agent version cell
func agentVersionCellClass(host Host) string {
	base := "agent-version"
	if host.AgentVersion == "" {
		return base + " agent-version--unknown"
	}
	if host.AgentOutdated {
		return base + " agent-version--outdated"
	}
	return base + " agent-version--ok"
}

// agentCompartmentButtonClass returns CSS classes for Agent compartment button
func agentCompartmentButtonClass(host Host) string {
	base := "compartment-btn"
	if host.AgentVersion == "" {
		return base + " unknown"
	}
	return base
}

// getAgentStatus returns status string for Agent compartment
func getAgentStatus(host Host) string {
	if host.AgentVersion == "" {
		return "unknown"
	}
	if host.AgentOutdated {
		return "outdated"
	}
	return "ok"
}

// agentIndicatorClass returns CSS class for Agent indicator dot
func agentIndicatorClass(host Host) string {
	base := "compartment-indicator"
	if host.AgentVersion == "" {
		return base + " compartment-indicator--gray"
	}
	if host.AgentOutdated {
		return base + " compartment-indicator--error"
	}
	return base + " compartment-indicator--ok"
}

// agentContextDescription returns context bar description for Agent compartment
func agentContextDescription(host Host) string {
	if host.AgentVersion == "" {
		return "Agent version unknown"
	}
	if host.AgentOutdated {
		return fmt.Sprintf("Agent %s (outdated, expected %s)", host.AgentVersion, host.ExpectedAgentVersion)
	}
	return fmt.Sprintf("Agent %s (current)", host.AgentVersion)
}

// P1020: compartmentButtonClass returns CSS classes for clickable compartment button
func compartmentButtonClass(status *UpdateStatus, compartment string) string {
	base := "compartment-btn"
	if status == nil {
		return base + " unknown"
	}

	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "system":
		check = status.System
	}

	if check.Status == "" || check.Status == "unknown" {
		return base + " unknown"
	}
	return base
}

// P1020: lockCompartmentButtonClass returns CSS classes for Lock button
func lockCompartmentButtonClass(host Host) string {
	base := "compartment-btn"
	if host.UpdateStatus == nil {
		return base + " unknown"
	}
	if host.UpdateStatus.Lock.Status == "" || host.UpdateStatus.Lock.Status == "unknown" {
		return base + " unknown"
	}
	// Lock outdated is info-only (no action)
	if host.UpdateStatus.Lock.Status == "outdated" && !host.AgentOutdated {
		return base + " info-only"
	}
	return base
}

// P1020: getCompartmentStatus returns status string for data attribute
func getCompartmentStatus(status *UpdateStatus, compartment string) string {
	if status == nil {
		return "unknown"
	}
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	if check.Status == "" {
		return "unknown"
	}
	return check.Status
}

// P1020: getLockStatus returns status for Lock (considers agent outdated)
func getLockStatus(host Host) string {
	if host.AgentOutdated {
		return "error"
	}
	if host.UpdateStatus == nil {
		return "unknown"
	}
	return host.UpdateStatus.Lock.Status
}

// P1020: getCompartmentActionType returns action type for routing
func getCompartmentActionType(status *UpdateStatus, compartment string) string {
	if status == nil {
		return "refresh"
	}

	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
		switch check.Status {
		case "ok":
			return "refresh"
		case "outdated":
			return "pull"
		case "error":
			return "error"
		default:
			return "refresh"
		}
	case "system":
		check = status.System
		switch check.Status {
		case "ok":
			return "refresh"
		case "outdated":
			return "switch"
		case "error":
			return "error"
		default:
			return "refresh"
		}
	}
	return "refresh"
}

// P1020: getLockActionType returns action type for Lock compartment
func getLockActionType(host Host) string {
	if host.AgentOutdated {
		return "switch"
	}
	if host.UpdateStatus == nil {
		return "refresh"
	}
	switch host.UpdateStatus.Lock.Status {
	case "ok":
		return "refresh"
	case "outdated":
		return "info" // No action, just info
	case "error":
		return "error"
	default:
		return "refresh"
	}
}

// P2500: Context bar description functions
// These return concise, human-readable descriptions for the context bar

// gitContextDescription returns a short description for context bar
func gitContextDescription(host Host) string {
	status := host.UpdateStatus
	if status == nil {
		return "Checking git status..."
	}
	check := status.Git
	switch check.Status {
	case "ok":
		return "Code is up to date"
	case "outdated":
		if check.Message != "" {
			return check.Message
		}
		return "Code is behind â€” click to pull"
	case "error":
		if check.Message != "" {
			return check.Message
		}
		return "Git check failed"
	default:
		return "Checking git status..."
	}
}

// lockContextDescription returns a short description for context bar (flake.lock status)
func lockContextDescription(host Host) string {
	status := host.UpdateStatus
	if status == nil {
		return "Checking dependencies..."
	}
	check := status.Lock
	switch check.Status {
	case "ok":
		return fmt.Sprintf("Dependencies up to date (flake.lock synced)")
	case "outdated":
		if check.Message != "" {
			return check.Message
		}
		return "flake.lock outdated â€” merge PR to update dependencies"
	case "error":
		if check.Message != "" {
			return check.Message
		}
		return "Lock check failed"
	default:
		return "Checking dependencies..."
	}
}

// systemContextDescription returns a short description for context bar
func systemContextDescription(host Host) string {
	status := host.UpdateStatus
	isMac := host.HostType == "macos"
	if status == nil {
		if isMac {
			return "Checking Home Manager..."
		}
		return "Checking system..."
	}
	check := status.System
	switch check.Status {
	case "ok":
		if host.Generation != "" {
			return fmt.Sprintf("Configuration applied (gen %s)", host.Generation)
		}
		if isMac {
			return "Home Manager up to date"
		}
		return "System up to date"
	case "outdated":
		if check.Message != "" {
			return check.Message
		}
		if isMac {
			return "Home Manager changed â€” click to switch"
		}
		return "Config changed â€” click to switch"
	case "error":
		if check.Message != "" {
			return check.Message
		}
		return "System check failed"
	default:
		if isMac {
			return "Checking Home Manager..."
		}
		return "Checking system..."
	}
}

// formatStatus converts status codes to human-readable text
func formatStatus(status string) string {
	switch status {
	case "ok":
		return "âœ“ Up to date"
	case "outdated":
		return "âš  Needs update"
	case "error":
		return "âœ— Error"
	default:
		return "? Unknown"
	}
}

// formatTimestamp formats an ISO timestamp for display
func formatTimestamp(ts string) string {
	// Just return as-is for now; can be enhanced later
	if len(ts) > 19 {
		return ts[:19] // Trim to "2024-12-17T10:30:00"
	}
	return ts
}

// updateStatusJSON returns JSON for a compartment's status (P7000 hydration)
func updateStatusJSON(status *UpdateStatus, compartment string) string {
	if status == nil {
		return "null"
	}
	var check StatusCheck
	switch compartment {
	case "git":
		check = status.Git
	case "lock":
		check = status.Lock
	case "system":
		check = status.System
	}
	data, err := json.Marshal(check)
	if err != nil {
		return "null"
	}
	return string(data)
}

// pendingPRJSON returns JSON for pending PR or "null" (P7000 hydration)
func pendingPRJSON(pr *PendingPR) string {
	if pr == nil {
		return "null"
	}
	data, err := json.Marshal(pr)
	if err != nil {
		return "null"
	}
	return string(data)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// P2700: Composite TYPE and STATUS column helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// compositeTypeTitle returns tooltip text for the composite type cell
func compositeTypeTitle(host Host) string {
	loc := host.Location
	if loc == "" {
		loc = "home"
	}
	dev := host.DeviceType
	if dev == "" {
		dev = "desktop"
	}
	os := host.HostType
	if os == "" {
		os = "nixos"
	}
	return fmt.Sprintf("%s: %s %s running %s", host.Hostname, capitalizeWord(loc), dev, os)
}

// capitalizeWord capitalizes the first letter of a word
func capitalizeWord(s string) string {
	if s == "" {
		return s
	}
	if s[0] >= 'a' && s[0] <= 'z' {
		return string(s[0]-32) + s[1:]
	}
	return s
}

// getPhaseProgress extracts phase progress from OperationProgress
func getPhaseProgress(op *OperationProgress, phase string) *PhaseProgress {
	if op == nil {
		return nil
	}
	switch phase {
	case "pull":
		return op.Pull
	case "lock":
		return op.Lock
	case "system":
		return op.System
	default:
		return nil
	}
}

// progressDotClass returns CSS class for a progress dot
func progressDotClass(p *PhaseProgress, step int) string {
	base := "progress-dot"
	if p == nil {
		// Idle state: show as 90% transparent green (completed)
		return base + " dot-idle"
	}
	
	switch p.Status {
	case "complete":
		return base + " dot-complete"
	case "error":
		if step < p.Current {
			return base + " dot-complete"
		}
		return base + " dot-error"
	case "in_progress":
		if step < p.Current {
			return base + " dot-complete"
		}
		if step == p.Current {
			return base + " dot-in-progress"
		}
		return base + " dot-pending"
	default: // pending
		return base + " dot-pending"
	}
}

// progressDotChar returns the character for a progress dot
func progressDotChar(p *PhaseProgress, step int) string {
	if p == nil {
		return "â—" // Idle: completed
	}
	
	switch p.Status {
	case "complete":
		return "â—"
	case "error":
		if step < p.Current {
			return "â—"
		}
		return "âœ—"
	case "in_progress":
		if step < p.Current {
			return "â—"
		}
		if step == p.Current {
			return "â—"
		}
		return "â—‹"
	default:
		return "â—‹"
	}
}

// testDotClass returns CSS class for a test result dot
func testDotClass(tp *TestProgress, idx int) string {
	base := "progress-dot test-dot"
	if tp == nil {
		return base + " dot-pending"
	}
	
	if tp.Running {
		if idx < tp.Current-1 {
			// Already ran
			if idx < tp.Passed {
				return base + " dot-complete"
			}
			return base + " dot-error"
		}
		if idx == tp.Current-1 {
			return base + " dot-in-progress"
		}
		return base + " dot-pending"
	}
	
	// Completed: show results
	if idx < tp.Passed {
		return base + " dot-complete"
	}
	if idx < tp.Total {
		return base + " dot-error"
	}
	return base + " dot-pending"
}

// testDotChar returns character for a test result dot
func testDotChar(tp *TestProgress, idx int) string {
	if tp == nil {
		return "â—‹"
	}
	
	if tp.Running {
		if idx < tp.Current-1 {
			if idx < tp.Passed {
				return "â—"
			}
			return "âœ—"
		}
		if idx == tp.Current-1 {
			return "â—"
		}
		return "â—‹"
	}
	
	if idx < tp.Passed {
		return "â—"
	}
	if idx < tp.Total {
		return "âœ—"
	}
	return "â—‹"
}

// operationTestDotClass returns CSS class for operation test dots
func operationTestDotClass(tp *TestsProgress, idx int) string {
	base := "progress-dot test-dot"
	if tp == nil || idx >= len(tp.Results) {
		return base + " dot-pending"
	}
	
	switch tp.Results[idx] {
	case "pass":
		return base + " dot-complete"
	case "fail":
		return base + " dot-error"
	default:
		if tp.Status == "in_progress" && idx == tp.Current {
			return base + " dot-in-progress"
		}
		return base + " dot-pending"
	}
}

// operationTestDotChar returns character for operation test dots
func operationTestDotChar(tp *TestsProgress, idx int) string {
	if tp == nil || idx >= len(tp.Results) {
		return "â—‹"
	}
	
	switch tp.Results[idx] {
	case "pass":
		return "â—"
	case "fail":
		return "âœ—"
	default:
		if tp.Status == "in_progress" && idx == tp.Current {
			return "â—"
		}
		return "â—‹"
	}
}

// minInt returns the minimum of two integers
func minInt(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// updateCompartmentTitle returns the tooltip for an update status compartment (legacy, kept for JS)
func updateCompartmentTitle(status *UpdateStatus, compartment string, hostType string) string {
	if status == nil {
		switch compartment {
		case "git":
			return "Git: Checking..."
		case "lock":
			return "Lock: Checking..."
		case "system":
			if hostType == "macos" {
				return "Home Manager: Checking..."
			}
			return "System: Checking..."
		}
		return "Checking..."
	}
	
	var check StatusCheck
	var label string
	switch compartment {
	case "git":
		check = status.Git
		label = "Git"
	case "lock":
		check = status.Lock
		label = "Lock"
	case "system":
		check = status.System
		if hostType == "macos" {
			label = "Home Manager"
		} else {
			label = "System"
		}
	}
	
	if check.Message != "" {
		return label + ": " + check.Message
	}
	
	switch check.Status {
	case "ok":
		return label + ": Up to date"
	case "outdated":
		return label + ": Needs attention"
	case "error":
		return label + ": Error"
	default:
		return label + ": Unknown"
	}
}

